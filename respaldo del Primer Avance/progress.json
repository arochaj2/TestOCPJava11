[
  {
    "number": 1,
    "chapter": 1,
    "question": "Which of the following are not valid variable names? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [
      0,
      2
    ],
    "options": [
      "_",
      "_blue",
      "2blue",
      "blue$",
      "Blue"
    ],
    "explanation": "An identifier name must begin with a letter, dollar sign ($), or underscore (_). Num\nbers are permitted only for subsequent characters. Therefore, option C is not a valid variable \nname. Additionally, an identifier may not be a single underscore, making option A an invalid \nvariable name."
  },
  {
    "number": 2,
    "chapter": 1,
    "question": "What is the value of tip after executing the following code snippet?\nint meal \u003d 5;\nint tip \u003d 2;\nvar total \u003d meal + (meal\u003e6 ? tip++ : tip--);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "1",
      "2",
      "3",
      "7",
      "None of the above"
    ],
    "explanation": "In a ternary expression, only one of the two right-most expressions is evaluated. Since\nmeal\u003e6 is false, tip-- is evaluated, and tip++ is skipped. The result is that tip is \nchanged from 2 to 1, making option A the correct answer. The value of total is 7, since the \npost-decrement operator was used on tip, although you did not need to know this to solve \nthe question."
  },
  {
    "number": 3,
    "chapter": 1,
    "question": "Which is equivalent to var q \u003d 4.0f;?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "float q \u003d 4.0f;",
      "Float q \u003d 4.0f;",
      "double q \u003d 4.0f;",
      "Double q \u003d 4.0f;",
      "Object q \u003d 4.0f;"
    ],
    "explanation": "The f in 4.0f means the type is a float, making option A correct. Local variable type\ninference chooses an exact match rather than using autoboxing to choose Float."
  },
  {
    "number": 4,
    "chapter": 1,
    "question": "What is the output of the following?\n12: var b \u003d \"12\";\n13: b +\u003d \"3\";\n14: b.reverse();\n15: System.out.println(b.toString());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "12",
      "123",
      "321",
      "The code does not compile."
    ],
    "explanation": "Trick question. There is no reverse method on the String class. There is one on the\nStringBuilder class. Therefore, the code does not compile, and option D is correct."
  },
  {
    "number": 5,
    "chapter": 1,
    "question": "What is the output of the following?\n5: var line \u003d new StringBuilder(\"-\");\n6: var anotherLine \u003d line.append(\"-\");\n7: System.out.print(line \u003d\u003d anotherLine);\n8: System.out.print(\" \");\n9: System.out.print(line.length());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "false 1",
      "false 2",
      "true 1",
      "true 2",
      "It does not compile."
    ],
    "explanation": "A StringBuilder is mutable, so the length is 2 after line 6 completes. The \nStringBuilder methods return a reference to the same object, so you can chain method \ncalls. Therefore, line and anotherLine refer to the same object. This means that line 7 \nprints true. Then on line 9, both references point to the same object of length 2, and option \nD is correct."
  },
  {
    "number": 6,
    "chapter": 1,
    "question": "Given the following Venn diagram and the boolean variables, apples, oranges, and \nbananas, which expression most closely represents the filled-in region of the diagram?",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "apples \u0026\u0026 oranges \u0026\u0026 !bananas",
      "orange || (oranges \u0026\u0026 !bananas)",
      "(apples || bananas) \u0026\u0026 oranges",
      "oranges \u0026\u0026 apples",
      "(apples || oranges) \u0026\u0026 !bananas",
      "apples ^ oranges"
    ],
    "explanation": "The diagram represents all cases where apples or oranges is true, but bananas is\nfalse, making option E correct. Option A is close but is correct only if the top overlapping \nportion of apples and oranges was filled in. For fun, you should try to draw the diagrams \nthat would represent the other answers."
  },
  {
    "number": 7,
    "chapter": 1,
    "question": "What is the output of the following?\n5: var line \u003d new String(\"-\");\n6: var anotherLine \u003d line.concat(\"-\");\n7: System.out.print(line \u003d\u003d anotherLine);\n8: System.out.print(\" \");\n9: System.out.print(line.length());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "false 1",
      "false 2",
      "true 1",
      "true 2",
      "Does not compile"
    ],
    "explanation": "A String is immutable, so a different object is returned on line 6. The object \nanotherLine points to is of length 2 after line 6 completes. However, the original line \nreference still points to an object of length 1 . Therefore, option A is correct."
  },
  {
    "number": 8,
    "chapter": 1,
    "question": "Which can fill in the blank? (Choose two.)\npublic void math() {\n   _____ pi \u003d 3.14;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "byte",
      "double",
      "float",
      "short",
      "var"
    ],
    "explanation": "Options A and D are incorrect because byte and short do not store values with dec\nimal points. Option C is tempting. However, 3 .14 is automatically a double. It requires \ncasting to float or writing  3 .14f to be assigned to a float. Therefore, option B is correct. \nAdditionally, option E is correct because local variable type inference is able to automatically \ndetermine the type is double."
  },
  {
    "number": 9,
    "chapter": 1,
    "question": "Fill in the blanks: The operators !\u003d, _______, _______, _______, and ++ are listed in the same \nor increasing level of operator precedence. (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "\u003d\u003d, *, !",
      "/, %, *",
      "*, --, /",
      "!, *, %",
      "+\u003d, \u0026\u0026, *",
      "*, \u003c, /"
    ],
    "explanation": "Option A is correct and lists the operators in the same or increasing level of operator\nprecedence. In option B, the three operators actually have the same operator precedence, so \nit is correct. Option C is incorrect, as division (/) has a lower precedence than the decre-\nment operator (--). Option D is incorrect because the logical complement operator (!) has \na higher order of precedence than the other two operators. Option E lists the operators in \nthe correct order, but they don’t fit within not equals (!\u003d) and the increment operator (++) \nas listed in the question. In particular, compound addition operator (+\u003d) and short-circuit\nlogical operator (\u0026\u0026) have a lower precedence than the not equals operator (!\u003d). Finally, \noption F is incorrect because the relational operator (\u003c) does not fit between multiplication \noperator (*) and the division operator (/) in order of precedence."
  },
  {
    "number": 10,
    "chapter": 1,
    "question": "How many of these compile?\n18: Comparator\u003cString\u003e c1 \u003d (j, k) -\u003e 0;\n19: Comparator\u003cString\u003e c2 \u003d (String j, String k) -\u003e 0;\n20: Comparator\u003cString\u003e c3 \u003d (var j, String k) -\u003e 0;\n21: Comparator\u003cString\u003e c4 \u003d (var j, k) -\u003e 0;\n22: Comparator\u003cString\u003e c5 \u003d (var j, var k) -\u003e 0;",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5"
    ],
    "explanation": "Line 18 compiles because neither type is specified for the lambda parameters. Lines 19\nand 22 compile because the lambda parameters use a type or var consistently. These are the \nthree lines that compile, making option D correct. Lines 20 and 21 do not compile because \nvar must be used for all parameters in a lambda if it is used for any."
  },
  {
    "number": 11,
    "chapter": 1,
    "question": "The author of this method forgot to include the data type. Which of the following reference \ntypes can best fill in the blank to complete this method?\npublic static void secret(___________ mystery) {\n   char ch \u003d mystery.charAt(3);\n   mystery \u003d mystery.insert(1, \"more\");\n   int num \u003d mystery.length();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "String",
      "StringBuilder",
      "Both",
      "Neither"
    ],
    "explanation": "The charAt() and length() methods are declared on both String and \nStringBuilder. However, the insert() method is declared only on a StringBuilder \nand not a String. Therefore, option B is correct."
  },
  {
    "number": 12,
    "chapter": 1,
    "question": "What is the output of the following?\nvar teams \u003d new StringBuilder(\"333\");\nteams.append(\" 806\");\nteams.append(\" 1601\");\nSystem.out.print(teams);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "333",
      "333 806 1601",
      "The code compiles but outputs something else.",
      "The code does not compile."
    ],
    "explanation": "Since StringBuilder is mutable, each call to append adds to the value. When calling\nprint, toString() is automatically called, and 333 806 1601 is output. Therefore, \noption B is correct."
  },
  {
    "number": 13,
    "chapter": 1,
    "question": "Which of the following declarations does not compile?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "double num1, int num2 \u003d 0;",
      "int num1, num2;",
      "int num1, num2 \u003d 0;",
      "int num1 \u003d 0, num2 \u003d 0;",
      "All of the above",
      "None of the above"
    ],
    "explanation": "Option A does not compile because Java does not allow declaring different types as\npart of the same declaration. The other three options show various legal combinations of \ncombining multiple variables in the same declarations with optional default values."
  },
  {
    "number": 14,
    "chapter": 1,
    "question": "Given the file Magnet.java shown, which of the marked lines can you independently insert \nthe line var color; into and still have the code compile?\n// line a1\npublic class Magnet {\n   // line a2\n   public void attach() {\n      // line a3\n   }\n   // line a4\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "a2",
      "a3",
      "a2 and a3",
      "a1, a2, a3, and a4",
      "None of the above"
    ],
    "explanation": "Local variable type inference requires a value, so that the type can be inferred. The state\nment var color; without a value is not allowed, making option E the answer."
  },
  {
    "number": 15,
    "chapter": 1,
    "question": "Which is one of the lines output by this code?\n10: var list \u003d new ArrayList\u003cInteger\u003e();\n11: list.add(10);\n12: list.add(9);\n13: list.add(8);\n14:\n15: var num \u003d 9;\n16: list.removeIf(x -\u003e {int keep \u003d num; return x !\u003d keep;});\n17: System.out.println(list);\n18:\n19: list.removeIf(x -\u003e {int keep \u003d num; return x \u003d\u003d keep;});\n20: System.out.println(list);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "[]",
      "[8, 10]",
      "[8, 9, 10]",
      "[10, 8]",
      "The code does not compile."
    ],
    "explanation": "The code starts by creating a list of three elements. On line 16, it removes two elements\nand then removes the final one on line 19 . This prints an empty list, making option A the \ncorrect answer. Note that num is effectively final, so can be used in a lambda."
  },
  {
    "number": 16,
    "chapter": 1,
    "question": "Which of the following can fill in the blank so the code prints true?\nvar happy \u003d \" :) - (: \";\nvar really \u003d happy.trim();\nvar question \u003d _____________________;\nSystem.out.println(really.equals(question));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "happy.substring(0, happy.length() - 1)",
      "happy.substring(0, happy.length())",
      "happy.substring(1, happy.length() - 1)",
      "happy.substring(1, happy.length())"
    ],
    "explanation": "The trim() method returns a String with all leading and trailing white space removed.\nIn this question, that’s the seven-character String: \":) - (:\". Options A and B are \nincorrect because they do not remove the first blank space in happy. Option D is incorrect \nbecause it does not remove the last character in happy. Therefore, option C is correct."
  },
  {
    "number": 17,
    "chapter": 1,
    "question": "How many of the following lines contain a compiler error?\ndouble num1 \u003d 2.718;\ndouble num2 \u003d 2._718;\ndouble num3 \u003d 2.7_1_8;\ndouble num4 \u003d _2.718;",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "Underscores are allowed between any two digits in a numeric literal, causing num4 to fail\nto compile. Additionally, underscores are not allowed adjacent to a decimal point, causing a \ncompiler error in num2 . Since two lines have errors, option C is the correct answer."
  },
  {
    "number": 18,
    "chapter": 1,
    "question": "What is the output of the following application?\npublic class Airplane {\n   static int start \u003d 2;\n   final int end;\n   public Airplane(int x) {\n      x \u003d 4;\n      end \u003d x;\n   }\n   public void fly(int distance) {\n      System.out.print(end-start+\" \");\n      System.out.print(distance);\n   }\n   public static void main(String... start) {\n      new Airplane(10).fly(5);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "2 5",
      "8 5",
      "6 5",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The code compiles, so option D is incorrect. The input to the constructor is ignored, \nmaking the assignment of end to be 4 . Since start is 2, the subtraction of 4 by 2 results in \nthe application printing 2, followed by 5, making option A the correct answer."
  },
  {
    "number": 19,
    "chapter": 1,
    "question": "What is the output of the following class?\n1: package rocket;\n2: public class Countdown {\n3:    public static void main(String[] args) {\n4:       var builder \u003d \"54321\";\n5:       builder \u003d builder.substring(4);\n6:       System.out.println(builder.charAt(2));\n7:    }\n8: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "2",
      "3",
      "4",
      "None of the above"
    ],
    "explanation": "Line 4 creates a String of length 5. Since String is immutable, line 5 creates a new\nString with the value 1 and assigns it to builder. Remember that indexes in Java begin \nwith zero, so the substring() method is taking the values from the fifth element through \nthe end. Since the first element is the last element, there’s only one character in there. Then \nline 6 tries to retrieve the second indexed element. Since there is only one element, this gives a \nStringIndexOutOfBoundsException, and option D is correct."
  },
  {
    "number": 20,
    "chapter": 1,
    "question": "What is the output of the following application?\npackage transporter;\npublic class Rematerialize {\n   public static void main(String[] input) {\n      int init \u003d 11;\n      int split \u003d 3;\n      int partA \u003d init / split;\n      int partB \u003d init % split;\n      int result \u003d split * (partB + partA);\n      System.out.print(result);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "9",
      "11",
      "12",
      "15",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The code compiles and runs without issue, making option E incorrect. In this\nexample, partA is the integer division of the two numbers. Since 3 does not divide 11\nevenly, it is rounded down to 3 . The variable partB is the remainder from the first expres-\nsion, which is 2 . The results are added together, resulting in the expression 3 * 5, or 15, and \nmaking option D correct."
  },
  {
    "number": 21,
    "chapter": 1,
    "question": "What is the result of the following code?\nvar sb \u003d new StringBuilder(\"radical\")\n   .insert(sb.length(), \"robots\");\nSystem.out.println(sb);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "radicarobots",
      "radicalrobots",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "Calling the constructor and then insert() is an example of method chaining. However,\nthe sb.length() call is a problem. The sb reference doesn’t exist until after the chained \ncalls complete. Just because it happens to be on a separate line doesn’t change when the refer-\nence is created. Since the code does not compile, option C is correct."
  },
  {
    "number": 22,
    "chapter": 1,
    "question": "Given the following code snippet, what is the value of dinner after it is executed?\nint time \u003d 9;\nint day \u003d 3;\nvar dinner \u003d ++time \u003e\u003d 10 ? day-- \u003c\u003d 2 \n   ? \"Takeout\" : \"Salad\" : \"Leftovers\";",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Takeout",
      "Leftovers",
      "Salad",
      "The code does not compile but would compile if parentheses were added.",
      "None of the above."
    ],
    "explanation": "While parentheses are recommended for ternary operations, especially embedded ones,\nthey are not required, so option D is incorrect. The first expression evaluates to 10 \u003e\u003d 10, \nso the first branch of the ternary operation is selected, and \"Leftovers\" can be eliminated. \nThe expression in the second ternary operation evaluates to 3 \u003c\u003d 2, which is false, so \n\"Salad\" is selected, and option C is correct."
  },
  {
    "number": 23,
    "chapter": 1,
    "question": "What is the output of the following?\nvar teams \u003d new String(\"694\");\nteams.concat(\" 1155\");\nteams.concat(\" 2265\");\nteams.concat(\" 2869\");\nSystem.out.println(teams);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "694",
      "694 1155 2265 2869",
      "The code compiles but outputs something else.",
      "The code does not compile."
    ],
    "explanation": "Since String is immutable, each call to concat() returns a new object with the new\nvalue. However, that return value is ignored, and the teams variable never changes in value. \nTherefore, it stays as 694, and option A is correct."
  },
  {
    "number": 24,
    "chapter": 1,
    "question": "How many of the following lines compile?\nbool b \u003d null;\nBool bl \u003d null;\nint i \u003d null;\nInteger in \u003d null;\nString s \u003d null;",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "First, bool and Bool are not valid Java types. They should be boolean and Boolean,\nrespectively. Next, objects are allowed to have a null reference while primitives cannot. \nSince Integer and String are objects, those lines compile. Finally, the line with int is a \nprimitive, so assigning null to it does not compile. Therefore, option C is correct."
  },
  {
    "number": 25,
    "chapter": 1,
    "question": "What is the output of the following code snippet?\nint height \u003d 2, length \u003d 3;\nboolean w \u003d height \u003e 1 | --length \u003c 4;\nvar x \u003d height!\u003d2 ? length++ : height;\nboolean z \u003d height % length \u003d\u003d 0;\nSystem.out.println(w + \"-\" + x + \"-\" + z);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "true-2-true",
      "false-2-false",
      "true-2-false",
      "true-3-false",
      "true-3-true",
      "false-3-false"
    ],
    "explanation": "In the first expression, height \u003e 1 is true. Since it uses the logical operator (|), which\nevaluates both sides, the right side is still executed, resulting in length being assigned a \nvalue of 2 and w assigned a value of true. In the second expression, only the right-hand side \nof the expression is evaluated, so x is assigned a value of 2, and length is unchanged. The \nlast expression evaluates to 2 % 2, which is 0, so z is assigned a value of 0 ."
  },
  {
    "number": 26,
    "chapter": 1,
    "question": "What is the output of the following?\n1: public class Legos {\n2:    public static void main(String[] args) {\n3:       var sb \u003d new StringBuilder();\n4:       sb.append(\"red\");\n5:       sb.deleteCharAt(0);\n6:       sb.delete(1, 2);\n7:       System.out.println(sb);\n8:    }\n9: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "e",
      "d",
      "ed",
      "None of the above"
    ],
    "explanation": "Line 3 creates an empty StringBuilder. Line 4 adds three characters to it. Line 5\nremoves the first character, resulting in ed. Line 6 deletes the characters starting at position \n1 and ending right before position 2, which removes the character at index 1, which is d. The \nonly character left is e, so option A is correct."
  },
  {
    "number": 27,
    "chapter": 1,
    "question": "Which is a true statement?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "If s.contains(\"abc\") is true, then s.equals(\"abc\") is also true.",
      "If s.contains(\"abc\") is true, then s.startsWith(\"abc\") is also true.",
      "If s.startsWith(\"abc\") is true, then s.equals(\"abc\") is also true.",
      "If s.startsWith(\"abc\") is true, then s.contains(\"abc\") is also true."
    ],
    "explanation": "Options A and B are not true if the String is \"deabc\". Option C is not true if the\nString is \"abcde\". Option D is true in all cases."
  },
  {
    "number": 28,
    "chapter": 1,
    "question": "What is the output of the following code snippet?\nboolean carrot \u003d true;\nBoolean potato \u003d false;\nvar broccoli \u003d true;\ncarrot \u003d carrot \u0026 potato;\nbroccoli \u003d broccoli ? !carrot : potato;\npotato \u003d !broccoli ^ carrot;\nSystem.out.println(carrot + \",\" + potato + \",\" + broccoli);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "true,false,true",
      "true,true,true",
      "false,false,false",
      "false,true,true",
      "false,false,true",
      "The code does not compile."
    ],
    "explanation": "The code compiles, so option F is incorrect. The first expression evaluates to true \u0026\nfalse, which sets carrot to false. The next expression resolves to true ? true : \nfalse, which results in broccoli being set to true. The last expression reduces to false \n^ false, which sets potato to false. Therefore, option E is the correct output."
  },
  {
    "number": 29,
    "chapter": 1,
    "question": "What does this code output?\nvar babies \u003d Arrays.asList(\"chick\", \"cygnet\", \"duckling\");\nbabies.replaceAll(x -\u003e { var newValue \u003d \"baby\";\nreturn newValue; });\nSystem.out.println(babies);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "[baby]",
      "[baby, baby, baby]",
      "[chick, cygnet, duckling]",
      "None of the above.",
      "The code does not compile."
    ],
    "explanation": "The code successfully defines a local variable inside the lambda. Each value is replaced\nwith baby. Since we have a List, all three are output, and option B is the correct answer."
  },
  {
    "number": 30,
    "chapter": 1,
    "question": "What is the output of the following class?\n1: package rocket;\n2: public class Countdown {\n3:    public static void main(String[] args) {\n4:       var builder \u003d new StringBuilder(\"54321\");\n5:       builder.substring(2);\n6:       System.out.println(builder.charAt(1));\n7:    }\n8: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "1",
      "2",
      "3",
      "4",
      "Does not compile"
    ],
    "explanation": "Line 4 creates a StringBuilder of length 5. Pay attention to the substring()\nmethod in StringBuilder. It returns a String with the value 321 . It does not change \nthe StringBuilder itself. Then line 6 retrieves the second indexed element from that \nunchanged value, which is 4 . Therefore, option D is correct."
  },
  {
    "number": 1,
    "chapter": 2,
    "question": "Variables declared as which of the following are never permitted in a switch statement? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5,
      1,
      5
    ],
    "options": [
      "var",
      "double",
      "int",
      "String",
      "char",
      "Object"
    ],
    "explanation": "A switch statement supports the primitive types byte, short, char, and int and\nthe wrapper classes Character, Byte, Short, and Integer. It also supports String \nand enumerated types. Finally, it permits var if it can be resolved to one of the previous \ntypes. Floating-point types like float and double are not supported; therefore, option B \nis correct. Object is also not supported since it could include any class, making option F \ncorrect as well."
  },
  {
    "number": 2,
    "chapter": 2,
    "question": "What happens when running the following code snippet?\n3: var gas \u003d true;\n4: do (\n5:    System.out.println(\"helium\");\n6:    gas \u003d gas ^ gas;\n7:    gas \u003d !gas;\n8: ) while (!gas);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "It completes successfully without output.",
      "It outputs helium once.",
      "It outputs helium repeatedly.",
      "Line 6 does not compile.",
      "None of the above."
    ],
    "explanation": "The code does not compile because parentheses, (), are used instead of braces, {}, mak\ning option E the correct answer. If the code was fixed to use braces, then option B would be \nthe correct answer. The exclusive or (^) of two true values is false. Therefore, gas would \nbe true at the end of the first loop and would exit since the loop condition !gas is false."
  },
  {
    "number": 3,
    "chapter": 2,
    "question": "What is output by the following?\n10: int m \u003d 0, n \u003d 0;\n11: while (m \u003c 5) {\n12:    n++;\n13:    if (m \u003d\u003d 3) \n14:       continue;\n15:   \n16:    switch (m) {\n17:       case 0:\n18:       case 1:\n19:          n++;\n20:       default:\n21:          n++;\n22:    }\n23:    m++;\n24: }\n25: System.out.println(m + \" \" + n);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "3 10",
      "3 12",
      "5 10",
      "5 12",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "When getting this type of question, the best approach is to write down the values of\nthe variables. Both start out as 0 on line 10 . On the first iteration of the loop, n becomes \n1, while m remains 0, so the clause in the if statement doesn’t run. In the switch state-\nment, the value of m remains 0, so it matches the first case. Since there is no break, the \ndefault block is also executed, and n is incremented twice and is now 3 . Finally, m is incre-\nmented to 1 .\nOn the second iteration of the loop, m goes from 1 to 2, and n goes from 3 to 6 . On the third \niteration, m goes from 2 to 3, and n goes from 6 to 8 . On the fourth iteration m is 3, and \nthe continue is executed with only n increasing in value by 1 . This pattern continues with \nthe loop never terminating, while n continues to increase by 1 . Since the execution does not \ncomplete, option F is the correct answer."
  },
  {
    "number": 4,
    "chapter": 2,
    "question": "Given the following, which can fill in the blank and allow the code to compile? \n(Choose three.)\nvar quest \u003d ;\nfor(var zelda : quest) {\n   System.out.print(zelda);\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      4
    ],
    "userAnswers": [
      1,
      3,
      4
    ],
    "options": [
      "3",
      "new int[] {3}",
      "new StringBuilder(\"3\")",
      "List.of(3)",
      "new String[3]",
      "\"Link\""
    ],
    "explanation": "A for-each loop accepts arrays and classes that implement java.lang.Iterable, \nsuch as List. For these reasons, options B, D, and E are correct. Option A is incorrect \nbecause it is a primitive value. Options C and F are incorrect because StringBuilder and \nString do not implement Iterable."
  },
  {
    "number": 5,
    "chapter": 2,
    "question": "Which of the following rules about a default branch in a switch statement are correct? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "A switch statement is required to declare a default statement.",
      "A default statement must be placed after all case statements.",
      "A default statement can be placed between any case statements.",
      "Unlike a case statement, a default statement does not take a parameter value.",
      "A switch statement can contain more than one default statement.",
      "A default statement can be used only when at least one case statement is present."
    ],
    "explanation": "A default statement inside a switch statement is optional and can be placed in any\norder within the switch’s case statements, making options A and B incorrect and option \nC correct. Option D is also correct because a default statement does not take a parameter \nvalue. Options E and F are incorrect rules about switch statements. "
  },
  {
    "number": 6,
    "chapter": 2,
    "question": "What does the following method output?\nvoid dance() {\n   var singer \u003d 0;\n   while (singer)\n      System.out.print(singer++);\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "The code does not compile.",
      "The method completes with no output.",
      "The method prints 0 and then terminates.",
      "The method enters an infinite loop.",
      "None of the above."
    ],
    "explanation": "A while loop requires a boolean condition. While singer is a variable, it is not a\nboolean. Therefore, the code does not compile, and option A is correct."
  },
  {
    "number": 7,
    "chapter": 2,
    "question": "Which are true statements comparing for-each and traditional for loops? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      5
    ],
    "userAnswers": [
      0,
      5
    ],
    "options": [
      "Both can iterate through an array starting with the first element.",
      "Only the for-each loop can iterate through an array starting with the first element.",
      "Only the traditional for loop can iterate through an array starting with the first element.",
      "Both can iterate through an array starting from the end.",
      "Only the for-each loop can iterate through an array starting from the end.",
      "Only the traditional for loop can iterate through an array starting from the end."
    ],
    "explanation": "A traditional for loop gives you full control over the order of iteration. This means\nyou can iterate through the array backward or forward. By contrast, with a for-each loop, \nthe iteration order is determined for you. With an array, this means starting with index 0 . \nOptions A and F match this scenario."
  },
  {
    "number": 8,
    "chapter": 2,
    "question": "What is the output of the following application?\npackage planning;\npublic class ThePlan {\n   public static void main(String[] input) {\n      var plan \u003d 1;\n      plan \u003d plan++ + --plan;\n      if(plan\u003d\u003d1) {\n         System.out.print(\"Plan A\");\n      } else { if(plan\u003d\u003d2) System.out.print(\"Plan B\");\n      } else System.out.print(\"Plan C\"); }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Plan A",
      "Plan B",
      "Plan C",
      "The class does not compile.",
      "None of the above."
    ],
    "explanation": "This code does not compile because it has two else statements as part of a single if\nstatement. Notice that the second if statement is not connected to the last else statement. \nFor this reason, option D is the correct answer."
  },
  {
    "number": 9,
    "chapter": 2,
    "question": "What is true about the following code? (Choose two.)\n23: var race \u003d \"\";\n24: loop:\n25: do {\n26:    race +\u003d \"x\";\n27:    break loop;\n28: } while (true);\n29: System.out.println(race);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "It outputs x.",
      "It does not compile.",
      "It is an infinite loop.",
      "With lines 25 and 28 removed, it outputs x.",
      "With lines 25 and 28 removed, it does not compile.",
      "With lines 25 and 28 removed, it is an infinite loop."
    ],
    "explanation": "The code compiles as is. Due to the break statement on line 27, the loop executes only\nonce. It prints a single x, which means option A is the first correct answer. While the label on \nline 24 is present with lines 25 and 28 removed, it no longer points to a loop. This causes the \ncode to not compile, and option E is the other correct answer."
  },
  {
    "number": 10,
    "chapter": 2,
    "question": "Which of the following can replace the body of the perform() method to produce the same \noutput on any nonempty input? (Choose two.)\npublic void perform(String[] circus) {\n   for (int i\u003dcircus.length-1; i\u003e\u003d0; i--)\n      System.out.print(circus[i]);\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "for (int i\u003dcircus.length; i\u003e0; i--)\n   System.out.print(circus[i-1]);",
      "for-reversed (String c \u003d circus)\n   System.out.print(c);",
      "for (var c : circus)\n   System.out.print(c);",
      "for(var i\u003d0; i\u003c circus.length; i++)\n   System.out.print(circus[circus.length-i-1]);",
      "for (int i\u003dcircus.length; i\u003e0; i--)\n   System.out.print(circus[i+1]);",
      "for-each (String c circus)\n   System.out.print(c);"
    ],
    "explanation": "The method prints the elements of the array in the reverse order in which they are\ndefined. Option A correctly accomplishes this using a different starting value for the loop. \nOptions B and F do not compile, as they do not use the correct syntax in a for-each loop. \nOption C compiles and runs without issue, but prints the items in their natural ordering,  \nas opposed to the reverse ordering. Option D is correct, as it increments in positive order \nbut reverses the output within the body of the for loop. Finally, option E is incorrect.  \nThe first element read is circus[circus.length+1], which results in an  \nArrayIndexOut OfBoundsException."
  },
  {
    "number": 11,
    "chapter": 2,
    "question": "What does the following code snippet output?\nvar bottles \u003d List.of(\"glass\", \"plastic\", \"can\");\nfor (int type \u003d 1; type \u003c bottles.size();) {\n   System.out.print(bottles.get(type) + \"-\");\n   if(type \u003c bottles.size()) break;\n}\nSystem.out.print(\"end\");",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "glass-end",
      "glass-plastic-can-end",
      "plastic-end",
      "plastic-can-end",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The first time through the loop, type is 1, and plastic- is output. The break\nstatement then terminates the loop, with end bring printed. If the break keyword was \nremoved, then this would be an infinite loop because type is not incremented between loop \nexecutions."
  },
  {
    "number": 12,
    "chapter": 2,
    "question": "What is the result of executing the following code snippet?\nfinal var GOOD \u003d 100;\nvar score \u003d 10;\nswitch (score) {\n   default:\n   1 : System.out.print(\"1-\");\n   -1 : System.out.print(\"2-\"); break;\n   4,5 : System.out.print(\"3-\");\n   6 : System.out.print(\"4-\");\n   9 : System.out.print(\"5-\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "1-",
      "1-2-",
      "2-",
      "3-",
      "4-",
      "None of the above"
    ],
    "explanation": "The code does not compile because the switch statement is missing the case keyword\nfor each value. Also, two case values cannot be combined as in 4,5."
  },
  {
    "number": 13,
    "chapter": 2,
    "question": "What is the output of the following application?\npackage dinosaur;\npublic class Park {\n   public final static void main(String... arguments) {\n      int pterodactyl \u003d 8;\n      long triceratops \u003d 3;\n      if(pterodactyl % 3 \u003e 1 + 1)\n         triceratops++;\n         triceratops--;\n      System.out.print(triceratops);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "2",
      "3",
      "4",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "First, determine whether the if statement’s expression is executed. The expression \n8 % 3 evaluates to 2 .  The right-hand side of the expression is evaluated next since + has a \nhigher precedence than \u003e. Since 2 \u003e 2 is false, the expression triceratops++ is not \ncalled. Notice there are no braces, {}, in the if statement. Despite the triceratops–– line \nbeing indented, it is not part of the if statement. Therefore, triceratops–– is always exe-\ncuted, resulting in a value of 2 for triceratops, and making option A the correct answer."
  },
  {
    "number": 14,
    "chapter": 2,
    "question": "What variable type of red allows the following application to compile?\npackage tornado;\npublic class Kansas {\n   public static void main(String[] args) {\n      int colorOfRainbow \u003d 10;\n       red \u003d 5;\n      switch(colorOfRainbow) {\n         default:\n            System.out.print(\"Home\");\n            break;\n         case red:\n            System.out.print(\"Away\");\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "long",
      "double",
      "int",
      "var",
      "String",
      "None of the above"
    ],
    "explanation": "The value of a case statement must be a constant, a literal value, or a final variable.\nSince red is missing the final attribute, no variable type allows the code to compile, mak-\ning option F the correct answer. If the final modifier was added to the declaration of red, \nthen int or var would be correct. The other options use types that are incompatible with \nswitch statements or with colorOfRainbow."
  },
  {
    "number": 15,
    "chapter": 2,
    "question": "How many lines of the magic() method contain compilation errors?\n10: public void magic() {\n11:    do {\n12:       int trick \u003d 0;\n13:       LOOP: do {\n14:          trick++;\n15:       } while (trick \u003c 2--);\n16:       continue LOOP;\n17:    } while (1 \u003e 2);\n18:    System.out.println(trick);\n19: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "Line 15 does not compile because the post-decrement operator can be applied only to var\niables, not values. Line 16 also does not compile because the label LOOP is out of scope after \nline 15 .  Finally, line 18 does not compile because trick is declared within the do/while \nloop and out of scope after line 17 .  For these reasons, option D is the correct answer."
  },
  {
    "number": 16,
    "chapter": 2,
    "question": "How many of these statements can be inserted after the println to have the code flow follow \nthe arrow in this diagram?",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "One",
      "Two",
      "Three",
      "Four",
      "Five",
      "None of above"
    ],
    "explanation": "If the code follows the arrow, then it prints each letter once, breaking out of the inner\nloop on every iteration. Since a break without a label applies to the innermost structure, \nbreak and break numbers are equivalent, and both of these are correct answers.  \nLikewise, continue and continue numbers are both equivalent although both wrong \nin this case since they resume operation of the inner loop. That leaves break letters and \ncontinue letters. In this case, break letters stops the outer loop after printing just \none letter, so it is incorrect. On the other hand, continue letters exits the inner loop \nand returns control to the outer loop, which is the desired behavior. Since three statements \nare correct, option C is correct."
  },
  {
    "number": 17,
    "chapter": 2,
    "question": "What is the output of the following application?\npackage dessert;\npublic class IceCream {\n   public final static void main(String... args) {\n      var flavors \u003d 30;\n      int eaten \u003d 0;\n      switch(flavors) {\n         case 30: eaten++;\n         case 40: eaten+\u003d2;\n         default: eaten--;\n      }\n      System.out.print(eaten);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "1",
      "2",
      "3",
      "The code does not compile because var cannot be used in a switch statement.",
      "The code does not compile for another reason.",
      "None of the above."
    ],
    "explanation": "The code compiles without issue, so options D and E are incorrect. A var can be used in a\nswitch statement, provided the underlying type resolves to a supported switch type. Next, \nnotice there are no break statements. Once the matching case statement, 30, is reached, all \nremaining case statements will be executed. The variable eaten is increased by 1, then 2, \nthen reduced by 1, resulting in a final value of 2, making option B the correct answer."
  },
  {
    "number": 18,
    "chapter": 2,
    "question": "Which of the following statements compile and create infinite loops at runtime? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      5
    ],
    "userAnswers": [
      0,
      3,
      5
    ],
    "options": [
      "while (!false) {}",
      "do {}",
      "for( : ) {}",
      "do {} while (true);",
      "while {}",
      "for( ; ; ) {}"
    ],
    "explanation": "A while loop and do/while loop both require a boolean expression, making\noptions A and D correct and options B and E incorrect. Option C is incorrect because a for-\neach statement requires an assignment type and an object to iterate on. Option F is correct \nand shows a traditional for loop with no arguments."
  },
  {
    "number": 19,
    "chapter": 2,
    "question": "Which of the following iterates a different number of times than the others?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "for (int k\u003d0; k \u003c 5; k++) {}",
      "for (int k\u003d1; k \u003c\u003d 5; k++) {}",
      "int k\u003d0; do { } while(k++ \u003c 5);",
      "int k\u003d0; while (k++ \u003c 5) {}",
      "All of these iterate the same number of times."
    ],
    "explanation": "Option A goes through five indexes on the iterations: 0, 1, 2, 3, and 4. Option B also goes\nthrough five indexes: 1, 2, 3, 4, and 5 .  Option D goes through five iterations as well, from 0 \nto 4 .  However, option C goes through six iterations since the loop condition is at the end of \nthe loop. Therefore, it is not like the others, and option C is the correct answer."
  },
  {
    "number": 20,
    "chapter": 2,
    "question": "What is the output of the following code snippet?\nint count \u003d 0;\nvar stops \u003d new String[] { \"Washington\", \"Monroe\",\n   \"Jackson\", \"LaSalle\" };\nwhile (count \u003c stops.length)\n   if (stops[++count].length() \u003c 8)\n      break;\n   else continue;\nSystem.out.println(count);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "On the first iteration of the loop, stops[++count] evaluates to stops[1], while also\nsetting count to 1 .  Since stops[1] is Monroe and it has six characters, the break is \nreached, and the loop stops. For this reason, 1 is printed, making option B correct."
  },
  {
    "number": 21,
    "chapter": 2,
    "question": "What is the output of the following code snippet?\nint hops \u003d 0;\nint jumps \u003d 0;\njumps \u003d hops++;\nif(jumps)\n   System.out.print(\"Jump!\");\nelse\n   System.out.print(\"Hop!\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Jump!",
      "Hop!",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The statement if(jumps) evaluates to if(0), and since 0 is not a boolean value, the\ncode does not compile. Java requires boolean expressions in if statements."
  },
  {
    "number": 22,
    "chapter": 2,
    "question": "Which of the following best describes the flow of execution in this for loop if beta always \nreturns false?\nfor (alpha; beta; gamma) {\n  delta;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "alpha",
      "alpha, beta",
      "alpha, beta, gamma",
      "alpha, gamma",
      "alpha, gamma, beta",
      "None of the above"
    ],
    "explanation": "The initializer, which is alpha, runs first. Then Java checks the condition, which is beta,\nto see whether loop execution should start. Since beta returns false, the loop is never \nentered, and option B is correct."
  },
  {
    "number": 23,
    "chapter": 2,
    "question": "What is the output of the following code snippet?\nboolean balloonInflated \u003d false;\ndo {\n   if (!balloonInflated) {\n      balloonInflated \u003d true;\n      System.out.print(\"inflate-\");\n   }\n} while (! balloonInflated);\nSystem.out.println(\"done\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "done",
      "inflate-done",
      "The code does not compile.",
      "This is an infinite loop.",
      "None of the above."
    ],
    "explanation": "On the first iteration of the loop, the if statement executes and prints inflate-.\nThen the loop condition is checked. The variable balloonInflated is true, so the loop \ncondition is false, and the loop completes and done is printed."
  },
  {
    "number": 24,
    "chapter": 2,
    "question": "Which of these code snippets behaves differently from the others?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "if (numChipmunks \u003d\u003d 1)\n    System.out.println(\"One chipmunk\");\nif (numChipmunks \u003d\u003d 2)\n    System.out.println(\"Two chipmunks\");\nif (numChipmunks \u003d\u003d 3)\n    System.out.println(\"Three chipmunks\");",
      "switch (numChipmunks) {/n  case 1: System.out.println(\"One chipmunk\");/n   case 2: System.out.println(\"Two chipmunks\");/n   case 3: System.out.println(\"Three chipmunks\");}",
      "if (numChipmunks \u003d\u003d 1)\n    System.out.println(\"One chipmunk\");\nelse if (numChipmunks \u003d\u003d 2)\n    System.out.println(\"Two chipmunks\");\nelse if (numChipmunks \u003d\u003d 3)\n    System.out.println(\"Three chipmunks\");",
      "All three code snippets do the same thing."
    ],
    "explanation": "Options A and C print one line if numChipmunks is 1, 2, or 3. Option B does not behave\nthe same way if numChipmunks is 1 or 2 .  There is no break statement, so the case state-\nments fall through, and more than one statement will be printed."
  },
  {
    "number": 25,
    "chapter": 2,
    "question": "Which statements about loops are correct? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      3
    ],
    "userAnswers": [
      0,
      2,
      3
    ],
    "options": [
      "A do/while loop requires a body.",
      "A while loop cannot be exited early with a return statement.",
      "A while loop requires a conditional expression.",
      "A do/while loop executes the body (if present) at least once.",
      "A do/while loop cannot be exited early with a return statement.",
      "A while loop executes the body (if present) at least once."
    ],
    "explanation": "A do/while loop requires a body, making option A correct. Options B and E are\nincorrect, as both types of while loops can be exited early with a return statement. \nBoth also require a conditional expression, making option C correct. What distinguishes a \ndo/while loop from a while loop is that it executes its body at least once, making option D \ncorrect and option F incorrect."
  },
  {
    "number": 26,
    "chapter": 2,
    "question": "Given the following enum and class, which option fills in the blank and allows the code \nto compile?\nenum Season { SPRING, SUMMER, WINTER }\npublic class Weather {\n   public int getAverageTemperate(Season s) {\n      switch (s) {\n         default:\n          return 30;\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "case Season.WINTER:",
      "case WINTER, SPRING:",
      "case SUMMER | WINTER:",
      "case SUMMER -\u003e",
      "case FALL:",
      "None of the above"
    ],
    "explanation": "Option A is incorrect because the enum type Season is not used within a case statement.\nIf it were just case WINTER:, then it would compile. Options B and C do not compile \nbecause switch statements do not support multiple values within a case statement. Option \nD is incorrect because -\u003e is used instead of :. Option E is incorrect because FALL is not \ndefined in the list of values for the enum Season. Since none of the lines of code is correct, \noption F is correct."
  },
  {
    "number": 27,
    "chapter": 2,
    "question": "Fill in the blank with the line of code that causes the application to compile and print exactly \none line at runtime.\npackage nyc;\npublic class TourBus {\n   public static void main(String... args) {\n      var nycTour \u003d new String[] { \"Downtown\", \"Uptown\",\n         \"Brooklyn\" };\n      var times \u003d new String[] { \"Day\", \"Night\" };\n      for (  i\u003cnycTour.length \u0026\u0026 j\u003ctimes.length;\n            i++, j++)\n         System.out.println(nycTour[i] + \"-\" + times[j]);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "int i\u003d1; j\u003d1;",
      "int i\u003d0, j\u003d1;",
      "int i\u003d1; int j\u003d0;",
      "int i\u003d1, int j\u003d0;",
      "int i\u003d1, j\u003d0;",
      "None of the above"
    ],
    "explanation": "In a traditional for loop, only one initialization type is allowed to be specified. If more\nthan one variable is supplied, then they are separated by a comma. Therefore, options A, C,\nand D do not compile. Options B and E both compile, although only option B prints a single \nline at runtime. Option E instead prints two lines since nycTour is of size 3 and times is \nof size 2 ."
  },
  {
    "number": 28,
    "chapter": 2,
    "question": "The code contains six pairs of curly braces. How many pairs can be removed without chang-\ning the behavior?\n12: public static void main(String[] args) {\n13:    int secret \u003d 0;\n14:    for (int i \u003d 0; i \u003c 10; i++) {\n15:       while (i \u003c 10) {\n16:          if (i \u003d\u003d 5) {\n17:             System.out.println(\"if\");\n18:          } else {\n19:             System.out.println(\"in\");\n20:             System.out.println(\"else\");\n21:          }\n22:       }\n23:    }\n24:    switch (secret) {\n25:       case 0:  System.out.println(\"zero\");\n26:    }\n27: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One",
      "Two",
      "Three",
      "Four",
      "Five",
      "Six"
    ],
    "explanation": "The braces on lines 12/27 are required because they comprise the method body. The\nbraces on lines 24/26 are required because a switch statement needs braces regardless of \nhow many case statements are inside. Finally, the braces on lines 18/21 are required because \nthe else has two statements inside.\nThe braces on lines 14/23, 15/22, and 16/18 are all optional because there is only one state-\nment inside. Since there are three pairs, option C is correct."
  },
  {
    "number": 29,
    "chapter": 2,
    "question": "Which of the following can replace the body of the travel() method to produce the same \noutput on any nonempty input?\npublic void travel(List\u003cInteger\u003e roads) {\n   for (int w \u003d 1; w \u003c\u003d roads.size(); w++)\n      System.out.print(roads.get(w-1));\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "for (int r \u003d 0; r \u003c roads.size(); r +\u003d 1)\n    System.out.print(roads.get(0));",
      "for(var z : roads)\n    System.out.print(z);",
      "for (int t \u003d roads.size(); t \u003e 0; t--)\n    System.out.print(roads.get(t));",
      "for (var var : roads)\n    System.out.print(roads);",
      "for (int q \u003d roads.size(); q \u003e\u003d 0; q++)\n    System.out.print(roads.get(q));",
      "None of the above"
    ],
    "explanation": "The method prints the elements of the list in the order in which they are defined. Option A\nis incorrect and prints the first element repeatedly. Option B is correct and prints the elements \nusing a for-each loop. Options C and E are incorrect because the first element read results in \nan ArrayIndexOutOfBoundsException. Finally, option D is incorrect because the entire \nlist is printed each time."
  },
  {
    "number": 30,
    "chapter": 2,
    "question": "Which statement about the following code snippet is correct?\n3: final var javaVersions \u003d List.of(9,10,11);\n4: var exams \u003d List.of(\"1Z0-811\", \"1Z0-819\");\n5: V: for (var e1 : javaVersions) {\n6:    E: for (String e2 : exams)\n7:       System.out.println(e1 + \"_\" + e2);\n8:       break;\n9: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "One line does not compile.",
      "Two lines do not compile.",
      "Three lines do not compile.",
      "It compiles and prints two lines at runtime.",
      "It compiles and prints three lines at runtime.",
      "None of the above."
    ],
    "explanation": "The code snippet compiles, making options A, B, and C incorrect. Notice that the inner\nfor-each loop does not use braces, {}, so the break statement applies to the outer loop only. \nOn the first iteration of the outer loop, the inner loop prints 9_1Z0-811 and 9_1Z0-819 . \nThen, the break statement is encountered, and the outer loop is terminated, making option \nD correct. If braces were added around lines 7 and 8, then the code would instead print \n9_1Z0-811, 10_1Z0-811, and 11_1Z0-811, and option E would be correct."
  },
  {
    "number": 1,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage dnd;\nfinal class Story {\n   void recite(int chapter) throws Exception {}\n}\npublic class Adventure extends Story {\n   final void recite(final int chapter) {  // g1\n      switch(chapter) {                    // g2\n         case 2: System.out.print(9);\n         default: System.out.print(3);\n      }\n   }\n   public static void main(String... u) {\n      var bedtime \u003d new Adventure();\n      bedtime.recite(2);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "3",
      "9",
      "93",
      "The code does not compile because of line g1.",
      "The code does not compile because of line g2.",
      "None of the above."
    ],
    "explanation": "The program does not compile because Story is marked final, which means it cannot\nbe extended by Adventure. If the final modifier were removed, the rest of the code would \ncompile and print 93 at runtime."
  },
  {
    "number": 2,
    "chapter": 3,
    "question": "Which of the following lines of code are not permitted as the first line of a Java class file? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      2,
      5,
      2,
      5
    ],
    "options": [
      "import widget.*;",
      "// Widget Manager",
      "int facilityNumber;",
      "package sprockets;",
      "/** Author: Cid **/",
      "void produce() {}"
    ],
    "explanation": "A class can start with a comment, an optional package statement, or an import\nstatement if there is no package statement. It cannot start with a variable definition or \nmethod declaration, since those cannot be declared outside a type. Therefore, options C and \nF are correct."
  },
  {
    "number": 3,
    "chapter": 3,
    "question": "Which of the following modifiers can be applied to an abstract method? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "final",
      "private",
      "public",
      "default",
      "protected",
      "concrete"
    ],
    "explanation": "An abstract method cannot include the final or private modifier. If a method\ncontained either of these modifiers, then no concrete subclass would ever be able to override \nit with an implementation. For these reasons, options A and B are incorrect. Option D is also \nincorrect because the default keyword applies to concrete interface methods, not abstract \nmethods. Option F is incorrect because there is no concrete modifier. That leaves options C \nand E as the correct answer. The protected, package-private, and public access modifiers \ncan each be applied to abstract methods."
  },
  {
    "number": 4,
    "chapter": 3,
    "question": "What is the result of compiling and executing the following class?\n1: public class ParkRanger {\n2:    int birds \u003d 10;\n3:    public static void main(String[] data) {\n4:       var trees \u003d 5;\n5:       System.out.print(trees+birds);\n6:    }\n7: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "It compiles and outputs 5.",
      "It compiles and outputs 15.",
      "It does not compile.",
      "It compiles but throws an exception at runtime."
    ],
    "explanation": "The code does not compile because of line 5, making option C the correct answer. For this\nquestion, it helps to understand variable scope. The main() method is static and does not \nhave access to any class instance variables. The birds variable is not static and requires \na class instance variable to access. Therefore, the code does not compile when the static \nmethod attempts to access a non-static variable without an instance of the class."
  },
  {
    "number": 5,
    "chapter": 3,
    "question": "Fill in the blanks: The ___________________ access modifier allows access to everything the \n___________________ access modifier does and more.",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "package-private, protected",
      "private, package-private",
      "private, protected",
      "private, public",
      "public, private",
      "None of the above"
    ],
    "explanation": "The public access modifier allows access to members in the same class, package, sub\nclass, or even classes in other packages, while the private modifier allows access only to \nmembers in the same class. Therefore, the public access modifier allows access to every-\nthing the private access modifier does, and more, making option E the correct answer. \nOptions A, B, C, and D are incorrect because the first term is a more restrictive access \nmodifier than the second term."
  },
  {
    "number": 6,
    "chapter": 3,
    "question": "Which set of modifiers, when added to a default method within an interface, prevents it from \nbeing overridden by a class implementing the interface?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "const",
      "final",
      "static",
      "private",
      "private static",
      "None of the above"
    ],
    "explanation": "There is no modifier that can prevent a default method from being overridden in a class\nimplementing an interface, making option F correct."
  },
  {
    "number": 7,
    "chapter": 3,
    "question": "Given the following application, fill in the missing values in the table starting from the top \nand going downward.\npackage competition;\npublic class Robot {\n   static String weight \u003d \"A lot\";\n   double ageMonths \u003d 5, ageDays \u003d 2;\n   private static boolean success \u003d true;\n \n   public void main(String[] args) {\n      final String retries \u003d \"1\";\n      // P1\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "2, 0, 1",
      "2, 2, 1",
      "1, 0, 1",
      "0, 2, 1"
    ],
    "explanation": "Notice in this question that main() is not a static method; therefore, it can access\nboth class and instance variables. Since there are two class variables and two instance  \nvariables defined, option B is the correct answer."
  },
  {
    "number": 8,
    "chapter": 3,
    "question": "Given the following code, what values inserted, in order, into the blank lines allow the code \nto compile? (Choose two.)\n_______ agent;\npublic _______ Banker {\n   private static _______ getMaxWithdrawal() {\n      return 10;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "package, new, int",
      "package, class, long",
      "import, class, null",
      "//, class, int",
      "import, interface, void",
      "package, class, void"
    ],
    "explanation": "Option A is incorrect because new cannot be used to declare a type. Option C is incor\nrect because null is a literal and cannot be used as the name of a class. Options E and F are \nincorrect because a void method cannot return a value. That leaves options B and D as the \ncorrect answers. Note that 10 can be returned as an int or implicitly promoted to a long, \nwithout issue."
  },
  {
    "number": 9,
    "chapter": 3,
    "question": "Which of the following are correct? (Choose two.)\npublic class Phone {\n   private int size;\n \n   // insert constructor here\n \n   public static void sendHome(Phone p, int newSize) {\n      p \u003d new Phone(newSize);\n      p.size \u003d 4;\n   }\n   public static final void main(String... params) {\n      final var phone \u003d new Phone(3);\n      sendHome(phone,7);\n      System.out.print(phone.size);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "The following is a valid constructor:\npublic static Phone create(int size) {\n    return new Phone(size);\n}",
      "The following is a valid constructor:\npublic static Phone newInstance(int size) {\n    return new Phone();\n}",
      "The following is a valid constructor:\npublic Phone(int size) {\n    this.size\u003dsize;\n}",
      "The following is a valid constructor:\npublic void Phone(int size) {\n    this.size\u003dsize;\n}",
      "With the correct constructor, the output is 3.",
      "With the correct constructor, the output is 7."
    ],
    "explanation": "Options A and B are static methods rather than constructors. Option D is a method\nthat happens to have the same name as the class. It is not a constructor because constructors \ndon’t have return types. Option C is a valid constructor.\nAs for the output, the key is that Java uses “pass by value” to send object references to \nmethods. Since the Phone reference p was reassigned in the first line of the sendHome() \nmethod, any changes to the p reference were made to a new object. In other words, no \nchanges in the sendHome() method affected the object that was passed in. Therefore, the \nvalue of size was the same before and after the method call, making the output 3 and \noption E the correct answer."
  },
  {
    "number": 10,
    "chapter": 3,
    "question": "Given the following class structures, which lines can be inserted into the blank independently \nthat would allow the class to compile? (Choose two.)\npublic class Dinosaur {\n   class Pterodactyl extends Dinosaur {}\n   public void roar() {\n      var dino \u003d new Dinosaur();\n      _______________________;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      2,
      5
    ],
    "options": [
      "dino.Pterodactyl()",
      "Dinosaur.new Pterodactyl()",
      "dino.new Pterodactyl()",
      "new Dino().new Pterodactyl()",
      "new Dinosaur().Pterodactyl()",
      "new Dinosaur.Pterodactyl()"
    ],
    "explanation": "Options A and E are incorrect because the new keyword before Pterodactyl is\nrequired to create an instance of the member inner class Pterodactyl using a member \nof the outer class Dinosaur. Option B is incorrect, as this is not a valid way to instantiate \na member inner class. Option C is correct and relies on the dino instance variable for the \nouter class instance. Option D would be correct if Dino was changed to the correct class \nname, Dinosaur. Finally, option F is correct and relies on the fact that roar() is an  \ninstance method, which means there’s an implicit instance of the outer class Dinosaur  \navailable. The Dinosaur. prefix is optional, though."
  },
  {
    "number": 11,
    "chapter": 3,
    "question": "What is the output of the Computer program?\nclass Laptop extends Computer {\n    public void startup() {\n        System.out.print(\"laptop-\");\n    }\n}\npublic class Computer {\n   public void startup() {\n      System.out.print(\"computer-\");\n   }\n   public static void main(String[] args) {\n      Computer computer \u003d new Laptop();\n      Laptop laptop \u003d new Laptop();\n      computer.startup();\n      laptop.startup();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "computer-laptop-",
      "laptop-computer-",
      "laptop-laptop-",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "Both objects are instances of the class Laptop. This means the overridden startup()\nmethod in the Laptop class gets called both times thanks to polymorphism, making option \nC correct."
  },
  {
    "number": 12,
    "chapter": 3,
    "question": "What access modifier is used to mark class members package-private?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "default",
      "friend",
      "protected",
      "private",
      "None of the above"
    ],
    "explanation": "In Java, the lack of an access modifier indicates that the member is package-private; there\nfore, option E is correct. Note that the default keyword is used for interfaces, annotations, \nand switch statements, and is not an access modifier."
  },
  {
    "number": 13,
    "chapter": 3,
    "question": "How many lines does the following code output?\npublic class Cars {\n   private static void drive() {\n       static {\n          System.out.println(\"static\");\n       }\n       System.out.println(\"fast\");\n       { System.out.println(\"faster\"); }\n   }\n   public static void main(String[] args) {\n      drive();\n      drive();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "None of the above. The code does not compile."
    ],
    "explanation": "A static initializer is not allowed inside a method. It should go on the class level rather\nthan the method level. Therefore, the code does not compile, and option E is correct."
  },
  {
    "number": 14,
    "chapter": 3,
    "question": "Which statements about static interface methods are correct? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      5
    ],
    "userAnswers": [
      1,
      3,
      5
    ],
    "options": [
      "A static interface method can be final.",
      "A static interface method can be declared private.",
      "A static interface method can be package-private.",
      "A static interface method can be declared public.",
      "A static interface method can be declared protected.",
      "A static interface method can be declared without an access modifier."
    ],
    "explanation": "Option A is incorrect as methods cannot be marked final within an interface. \nInterfaces support static methods that are marked public or private, making options \nB and D correct and option E incorrect. Option F is correct and lack of access modifier \nmakes the method implicitly public, not package-private, making option C incorrect."
  },
  {
    "number": 15,
    "chapter": 3,
    "question": "Fill in the blanks with the only option that makes this statement false: A(n) ______________ \ncan access ______________ of the enclosing class in which it is defined.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "static nested class, static members",
      "static nested class, instance members",
      "member inner class, static members",
      "member inner class, instance members",
      "local class, instance members from within an instance method",
      "anonymous class, instance members from within an instance method"
    ],
    "explanation": "A static nested class cannot access instance members of the enclosing class, making option\nB correct. The rest of the options form true statements."
  },
  {
    "number": 16,
    "chapter": 3,
    "question": "What is the result of executing the following program?\npublic class Canine {\n   public String woof(int bark) {\n      return \"1\"+bark.toString();\n   }\n \n   public String woof(Integer bark) {\n      return \"2\"+bark.toString();\n   }\n   public String woof(Object bark) {\n      return \"3\"+bark.toString();\n   }\n   \n   public static void main(String[] a) {\n      System.out.println(woof((short)5));\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "15",
      "25",
      "35",
      "One line does not compile.",
      "Two lines do not compile.",
      "The program compiles but throws an exception at runtime."
    ],
    "explanation": "The first woof() method does not compile because bark is a primitive, not an object,\nand does not have a toString() method. The main() method also does not com-\npile because it is static and all of the woof() methods require an instance of Canine. \nSince these two lines do not compile, option E is the correct answer. If the toString() \nwas removed from the first method and all of the methods were marked static, then the \nprogram would print 15 at runtime."
  },
  {
    "number": 17,
    "chapter": 3,
    "question": "What statement best describes the notion of effectively final in Java?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "A local variable that is marked final",
      "A static variable that is marked final",
      "A local variable whose primitive value or object reference does not change after it is initialized",
      "A local variable whose primitive value or object reference does not change after a certain point in the method",
      "None of the above"
    ],
    "explanation": "A local variable is effectively final when its primitive value or object reference does not\nchange after it is initialized, making option C the correct answer. Note that option D is incor-\nrect because any change to the variable after it is initialized disqualifies it for being consid-\nered effectively final."
  },
  {
    "number": 18,
    "chapter": 3,
    "question": "What is the output of the Turnip class?\npackage animal;\ninterface GameItem {\n   int sell();\n}\nabstract class Vegetable implements GameItem {\n   public final int sell() { return 5; }\n}\npublic class Turnip extends Vegetable {\n   public final int sell() { return 3; }\n   public static void main(String[] expensive) {\n      System.out.print(new Turnip().sell());\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "3",
      "5",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The sell() method is declared final in the Vegetable class. The Turnip class\nthen attempts to override this method, resulting in a compilation error, making option C the \ncorrect answer."
  },
  {
    "number": 19,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage holiday;\nenum DaysOff {\n   Thanksgiving, PresidentsDay, ValentinesDay\n}\npublic class Vacation {\n   public static void main(String... unused) {\n      final DaysOff input \u003d DaysOff.Thanksgiving;\n      switch(input) {\n         default:\n         case DaysOff.ValentinesDay:\n            System.out.print(\"1\");\n         case DaysOff.PresidentsDay:\n            System.out.print(\"2\");\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "1",
      "2",
      "12",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The case statements incorrectly use the enum name as well as the value, such as \nDaysOff.ValentinesDay. Since the type of the enum is determined by the value of the \nvariable in the switch statement, the enum name is not allowed and causes a compila-\ntion error when used. For this reason, option D is correct. If the enum name DaysOff was \nremoved, the application would output 12, since the lack of any break statements causes \nmultiple blocks to be reached, and option C would have been the correct answer."
  },
  {
    "number": 20,
    "chapter": 3,
    "question": "Which statements about instance keywords are correct? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "The that keyword can be used to read public members in the direct parent class.",
      "The this keyword can be used to read all members declared within the class.",
      "The super keyword can be used to read all members declared in a parent class.",
      "The that keyword can be used to read members of another class.",
      "The this keyword can be used to read public members in the direct parent class.",
      "The super keyword can be used in static methods."
    ],
    "explanation": "There is no that keyword, so options A and D are incorrect. Option B is correct,\nas this can access all members declared within the class. Option C is incorrect, as only \ninherited members can be accessed. For example, private members declared in a parent \nclass cannot be accessed using super. Option E is correct, as this allows access to mem-\nbers declared in the class and those inherited from a parent. Finally, option F is incorrect, as \nstatic methods do not have access to this or super references."
  },
  {
    "number": 21,
    "chapter": 3,
    "question": "Fill in the blanks: A class ____________ an interface and ______________ an abstract class. \nAn interface ______________ another interface.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "extends, extends, implements",
      "extends, implements, extends",
      "extends, implements, implements",
      "implements, extends, extends",
      "implements, extends, implements",
      "implements, implements, extends"
    ],
    "explanation": "A class can implement an interface, not extend it, ruling out options A, B, and C. Classes\ndo extend an abstract class, ruling out option F . Finally, an interface can only extend \nanother interface, making option D the correct answer."
  },
  {
    "number": 22,
    "chapter": 3,
    "question": "Suppose you have the following code. Which of the images best represents the state of the ref-\nerences c1, c2, and c3, right before the end of the main() method, assuming garbage collection \nhasn’t run? In the diagrams, each box represents a Chicken object with a number of eggs.\n1:  public class Chicken {\n2:     private Integer eggs \u003d 2;\n3:     { this.eggs \u003d 3; }\n4:     public Chicken(int eggs) {\n5:        this.eggs \u003d eggs;\n6:     }\n7:     public static void main(String[] r) {\n8:        var c1 \u003d new Chicken(1);\n9:        var c2 \u003d new Chicken(2);\n10:       var c3 \u003d new Chicken(3);\n11:       c1.eggs \u003d c2.eggs;\n12:       c2 \u003d c1;\n13:       c3.eggs \u003d null;\n14:    } }",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Option A.",
      "Option B.",
      "Option C.",
      "Option D.",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "Three instances of Chicken are created on lines 8–10. On line 11, the value of eggs \nin the first two instances is set to 2, while the third instance has a value of 3 . On line 12,  \nthe original instance that was pointed to by c1 (with an eggs value of 2) is dereferenced  \nand eligible for garbage collection. The c1 and c2 variables now both point to the same  \ninstance with an egg value of 2 . Finally, on line 13, the eggs value for c3 is changed from \n3 to null."
  },
  {
    "number": 23,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage musical;\ninterface Speak { default int talk() { return 7; } }\ninterface Sing { default int talk() { return 5; } }\npublic class Performance implements Speak, Sing {\n   public int talk(String... x) {  \n      return x.length;\n   }\n   public static void main(String[] notes) {\n      System.out.print(new Performance().talk());\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "7",
      "5",
      "The code does not compile.",
      "The code compiles without issue, but the output cannot be determined until runtime.",
      "None of the above."
    ],
    "explanation": "Java does not allow multiple inheritance, so having one class implement two interfaces\nthat both define the same default method signature leads to a compiler error, unless  \nthe class overrides the method. In this case, the talk(String...) method defined in the \nPerformance class is an overloaded method, not an overridden one, because the  signatures \ndo not match. Therefore, the Performance class does not compile, making option \nC correct."
  },
  {
    "number": 24,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage ai;\n \ninterface Pump {\n   void pump(double psi);\n}\ninterface Bend extends Pump {\n   void bend(double tensileStrength);\n}\npublic class Robot {\n   public static final void apply(\n      Bend instruction, double input) {\n      instruction.bend(input);\n   }\n   public static void main(String... future) {\n      final Robot r \u003d new Robot();\n      r.apply(x -\u003e System.out.print(x+\" bent!\"), 5);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "5 bent!",
      "5.0 bent!",
      "The code does not compile because Bend is not a functional interface.",
      "The code does not compile because of the apply() method declaration.",
      "None of the above."
    ],
    "explanation": "A functional interface must contain exactly one abstract method. The Bend interface\ncontains two abstract methods, pump() and bend(), since it extends Pump and inherits \npump(). For this reason, the Bend interface is not a valid functional interface and therefore \ncannot be used as a lambda expression, making option C the correct answer. The rest of the \ncode compiles without issue. Note that the usage of an instance variable to call a static \nmethod, r.apply() in the main() method, is permitted but discouraged."
  },
  {
    "number": 25,
    "chapter": 3,
    "question": "Which statement is true about encapsulation while providing the broadest access allowed?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Variables are private, and methods are private.",
      "Variables are private, and methods are public.",
      "Variables are public, and methods are private.",
      "Variables are public, and methods are public.",
      "None of the above."
    ],
    "explanation": "If the variables are public, the class is not encapsulated because callers have direct access\nto them. This rules out options C and D . Having private methods doesn’t allow the callers \nto use the data, making option A an undesirable answer. Option B is correct and the classic \ndefinition of encapsulation where the data is not exposed directly."
  },
  {
    "number": 26,
    "chapter": 3,
    "question": "Fill in the blanks: The ___________________ access modifier allows access to everything the \n___________________ access modifier does and more.",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "package-private, private",
      "private, protected",
      "protected, public",
      "private, package-private",
      "None of the above"
    ],
    "explanation": "Package-private allows access by code within the same package, while the private\nmodifier allows access only to members in the same class. This makes option A the correct \nanswer. Options B, C, and D are incorrect because the first term is a more restrictive access \nmodifier than the second term."
  },
  {
    "number": 27,
    "chapter": 3,
    "question": "Which statement about the following interface is correct?\npublic interface Swimming {\n   String DEFAULT \u003d \"Diving!\";      // k1\n   abstract int breath();\n   private static void stroke() {\n      if(breath()\u003d\u003d1) {             // k2\n         System.out.print(\"Go!\");\n      } else {\n         System.out.print(dive());  // k3\n      }\n   }\n   static String dive() {\n      return DEFAULT;               // k4\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "The code compiles without issue.",
      "The code does not compile because of line k1.",
      "The code does not compile because of line k2.",
      "The code does not compile because of line k3.",
      "The code does not compile because of line k4.",
      "None of the above."
    ],
    "explanation": "The stroke() method is static, which means it cannot access the instance method\nbreath() on line k2, making option C correct."
  },
  {
    "number": 28,
    "chapter": 3,
    "question": "Which is the first line to fail to compile?\nclass Tool {\n   private void repair() {}            // r1\n   void use() {}                       // r2\n}\n \nclass Hammer extends Tool {\n   private int repair() { return 0; } // r3\n   private void use() {}              // r4\n   public void bang() {}              // r5\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "r1",
      "r2",
      "r3",
      "r4",
      "r5",
      "None of the above"
    ],
    "explanation": "The Hammer class is a subclass of the Tool class. The repair() method can be declared\nin the Hammer subclass with a different return type because the parent method is not inher-\nited. For these reasons, options A and C are incorrect. On the other hand, the use() method \nis package-private in Tool, with the overridden version in Hammer reducing the visibility to \nprivate. This is an invalid override, making option D correct. The rest of the lines compile \nwithout issue."
  },
  {
    "number": 29,
    "chapter": 3,
    "question": "Which modifier can be applied to an abstract interface method?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "final",
      "interface",
      "protected",
      "void",
      "None of the above"
    ],
    "explanation": "Methods cannot be both abstract and final, making option A incorrect. Abstract\ninterface methods are always public, making option C incorrect. Finally, interface and \nvoid are not modifiers on a method, making options B and D incorrect. Therefore, option E \nis the answer."
  },
  {
    "number": 30,
    "chapter": 3,
    "question": "What is the output of the Plant program?\nclass Bush extends Plant {\n   String type \u003d \"bush\";\n}\npublic class Plant {\n   String type \u003d \"plant\";\n   public static void main(String[] args) {\n      Plant w1 \u003d new Bush();\n      Bush w2 \u003d new Bush();\n      Plant w3 \u003d w2;\n      System.out.print(w1.type+\",\"+w2.type+\",\"+w3.type);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "plant,bush,plant",
      "plant,bush,bush",
      "bush,plant,bush",
      "bush,bush,bush",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "While both objects are instances of Bush, we are not calling methods in this example.\nVirtual method invocation works only for methods, not instance variables. For instance var-\niables, Java looks at the type of the reference and calls the appropriate variable based on the \nreference. Based on the reference types of the three variables (Plant, Bush, Plant), option \nA is correct."
  },
  {
    "number": 31,
    "chapter": 3,
    "question": "Which statements can accurately fill in the blanks in this table? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      5
    ],
    "userAnswers": [
      0,
      5
    ],
    "options": [
      "Blank 1: an instance method only",
      "Blank 1: a static method only",
      "Blank 1: an instance or static method",
      "Blank 2: an instance method only",
      "Blank 2: a static method only",
      "Blank 2: an instance or static method"
    ],
    "explanation": "An instance variable can be referenced only from instance methods in the class, making\noption A correct. A static variable can be referenced from any method. Therefore, option \nF is correct."
  },
  {
    "number": 32,
    "chapter": 3,
    "question": "What is the correct order of statements for a Java class file?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "import statements, package statement, class declaration",
      "package statement, class declaration, import statements",
      "class declaration, import statements, package statement",
      "package statement, import statements, class declaration",
      "import statements, class declaration, package statement",
      "class declaration, package statement, import statements"
    ],
    "explanation": "Java classes are defined in this order: package statement, import statements, class dec\nlaration. That makes option D the only correct answer. Note that not all of these statements \nare required. For example, a class may not have a package statement, but if it does, it must \ncome first in the file."
  },
  {
    "number": 33,
    "chapter": 3,
    "question": "What is true of the following code? (Choose three.)\n1:  class Penguin {\n2:     enum Baby { EGG }\n3:     static class Chick { \n4:        enum Baby { EGG }\n5:     }\n6:     public static void main(String[] args) {\n7:        boolean match \u003d false;\n8:        Baby egg \u003d Baby.EGG;\n9:        switch (egg) {\n10:          case EGG:\n11:             match \u003d true;\n12:       }\n13:    }\n14: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      4
    ],
    "userAnswers": [
      0,
      2,
      4
    ],
    "options": [
      "It compiles as is.",
      "It does not compile as is.",
      "Removing line 2 would create an additional compiler error.",
      "Removing line 2 would not create an additional compiler error.",
      "Removing the static modifier on line 3 would create an additional compiler error.",
      "Removing the static modifier on line 3 would not create an additional compiler error."
    ],
    "explanation": "C, E. The code does compile as is, making option A correct. Removing line 2 would cause\na compiler error in the main() method since the enum inside Chick is not referenced. \nThis makes option C the next answer. Finally, option E is the final answer because an enum \ncannot be defined in a non-static inner class. Only top-level types and static nested \nclasses can define static members other than static constants, and enums are implic-\nitly static."
  },
  {
    "number": 34,
    "chapter": 3,
    "question": "Which are true of the following? (Choose two.)\npackage beach;\npublic class Sand {\n   private static int numShovels;\n   private int numRakes;\n \n   public static int getNumShovels() {\n      return numShovels;\n   }\n   public static int getNumRakes() {\n      return numRakes;\n   }\n   public Sand() {\n      System.out.print(\"a\");\n   }\n   public void Sand() {\n      System.out.print(\"b\");\n   }\n   public void run() {\n      new Sand();\n      Sand();\n   }\n   public static void main(String... args) {\n      new Sand().run();\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      0,
      5
    ],
    "options": [
      "The code compiles.",
      "One line doesn’t compile.",
      "Two lines don’t compile.",
      "If any constructors and/or methods that do not compile are removed, the remaining code prints a.",
      "If the code compiles or if any constructors/methods that do not compile are removed,\nthe remaining code prints ab.",
      "If the code compiles or if any constructors/methods that do not compile are removed,\nthe remaining code prints aab."
    ],
    "explanation": "A static method can access static variables, but not instance variables. The \ngetNumRakes() method does not compile, so option B is correct.\nThe main() method calls the constructor, which outputs a. Then the main method calls the \nrun() method. The run() method calls the constructor again, which outputs a again. Then \nthe run() method calls the Sand() method, which happens to have the same name as the \nconstructor. This outputs b. Therefore, option F is correct."
  },
  {
    "number": 35,
    "chapter": 3,
    "question": "Which of the following class types cannot be marked final or abstract?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "static nested class.",
      "Local class.",
      "Anonymous class.",
      "Member inner class.",
      "All of the above can be marked final or abstract."
    ],
    "explanation": "While an anonymous class can extend another class or implement an interface, it cannot\nbe declared final or abstract since it has no class definition. For this reason, option C \nis correct. The other classes may be declared final or abstract since they have a class \ndefinition."
  },
  {
    "number": 36,
    "chapter": 3,
    "question": "Fill in the blanks: The ___________________ access modifier allows access to everything the \n___________________ access modifier does and more. (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4,
      5
    ],
    "userAnswers": [
      2,
      4,
      5
    ],
    "options": [
      "package-private, protected",
      "package-private, public",
      "protected, package-private",
      "protected, public",
      "public, package-private",
      "public, protected"
    ],
    "explanation": "The public access modifier is the broadest, making options E and F correct. Pack\nage-private access limits references to those in the same package. The protected access \nmodifier adds on subclass access, making option C correct."
  },
  {
    "number": 37,
    "chapter": 3,
    "question": "Which is the first line containing a compiler error?\nvar title \u003d \"Weather\";         // line x1\nvar hot \u003d 100, var cold \u003d 20;  // line x2\nvar f \u003d 32, int c \u003d 0;         // line x3",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "x1",
      "x2",
      "x3",
      "None of the above"
    ],
    "explanation": "Java does not allow multiple variables to be declared in the same statement using local\nvariable type inference. Lines x2 and x3 both have compiler errors. Since the question asks \nabout the first line with a compiler error, option B is the answer."
  },
  {
    "number": 38,
    "chapter": 3,
    "question": "How many of the following members of Telephone interface are public?\npublic interface Telephone {\n   static int call() { return 1; }\n   default void dial() {}\n   long answer();\n   String home \u003d \"555-555-5555\";\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Zero.",
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "The code does not compile."
    ],
    "explanation": "All four members of the Telephone interface are implicitly public, making option E\ncorrect. Only private and private static interface methods are not public, and they \nmust be explicitly marked private."
  },
  {
    "number": 39,
    "chapter": 3,
    "question": "Which best describes what the new keyword does?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Creates a copy of an existing object and treats it as a new one.",
      "Creates a new primitive.",
      "Instantiates a new object.",
      "Switches an object reference to a new one.",
      "The behavior depends on the class implementation."
    ],
    "explanation": "The new keyword is used to call the constructor for a class and instantiate an instance\nof the class, making option C correct. A primitive cannot be created using the new keyword, \nso option B is incorrect. Dealing with references happens after the object created by new is \nreturned. The other options are invalid."
  },
  {
    "number": 40,
    "chapter": 3,
    "question": "How many lines will not compile?\n12: public void printVarargs(String... names) {\n13:    System.out.println(Arrays.toString(names));\n14: }\n15: public void printArray(String[] names) {\n16:    System.out.println(Arrays.toString(names));\n17: }\n18: public void stormy() {\n19:    printVarargs(\"Arlene\");\n20:    printVarargs(new String[]{\"Bret\"});\n21:    printVarargs(null);\n22:    printArray (\"Cindy\");\n23:    printArray (new String[]{\"Don\"});\n24:    printArray (null);\n25: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "From within a method, an array or varargs parameter is treated the same. However, there\nis a difference from the caller’s point of view. A varargs parameter can receive either an array \nor individual values, making line 19 and 20 compile. However, an array parameter can take \nonly an array, which permits line 23 but prevents line 22 from compiling. Both lines 21 and\n24 compile because null can be passed to a method taking an array or a varargs. Since there \nis only one line that doesn’t compile, option B is the answer."
  },
  {
    "number": 41,
    "chapter": 3,
    "question": "Which of the following can include a static method in its definition? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      5
    ],
    "userAnswers": [
      0,
      2,
      5
    ],
    "options": [
      "Interface",
      "Anonymous class",
      "Abstract class",
      "Member inner class",
      "Local class",
      "static nested class"
    ],
    "explanation": "Both abstract classes and interfaces can include static methods, so options A and\nC are correct. Of all the nested class types, only static nested classes can include static \nmethods, making option F correct, and options B, D, and E incorrect."
  },
  {
    "number": 42,
    "chapter": 3,
    "question": "What is the minimum number of lines that need to be removed to make this code compile?\n@FunctionalInterface\npublic interface Play {\n   public static void baseball() {}\n   private static void soccer() {}\n   default void play() {}\n   void fun();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "1.",
      "2.",
      "3.",
      "4.",
      "The code compiles as is."
    ],
    "explanation": "This code is already a functional interface and compiles without any changes. The Play\ninterface has a single abstract method: fun(). The other methods have a method body, \nwhich shows they are not abstract."
  },
  {
    "number": 43,
    "chapter": 3,
    "question": "Fill in the blanks: A class that defines an instance variable with the same name as a variable \nin the parent class is referred to as ___________________ a variable, while a class that defines \na static method with the same signature as a static method in a parent class is referred to as \n___________________ a method.",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "hiding, overriding",
      "overriding, hiding",
      "masking, masking",
      "hiding, masking",
      "replacing, overriding",
      "hiding, hiding"
    ],
    "explanation": "Both of these descriptions refer to variable and static method hiding, respectively, mak\ning option F correct. Only instance methods can be overridden, making options A and B \nincorrect. Options C, D, and E are also incorrect because replacing and masking are not real \nterms in this context."
  },
  {
    "number": 44,
    "chapter": 3,
    "question": "What change is needed to make Secret well encapsulated?\nimport java.util.*;\n \npublic class Secret {\n \n   private int number \u003d new Random().nextInt(10);\n   public boolean guess(int candidate) {\n      return number \u003d\u003d candidate;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Change number to use a protected access modifier.",
      "Change number to use a public access modifier.",
      "Declare a private constructor.",
      "Declare a public constructor.",
      "Remove the guess method.",
      "None. It is already well encapsulated."
    ],
    "explanation": "This class is a good example of encapsulation. It has a private instance variable and\nis accessed by a public method. No changes are needed to encapsulate it, and option F \nis correct."
  },
  {
    "number": 45,
    "chapter": 3,
    "question": "Which of the following are the best reasons for creating a public static interface \nmethod? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "Allow static methods to access instance methods.",
      "Allow an interface to define a method at the class level.",
      "Provide an implementation that a class implementing the interface can override.",
      "Improve code reuse within the interface.",
      "Add backward compatibility to existing interfaces.",
      "Improve encapsulation of the interface."
    ],
    "explanation": "Option A is incorrect because static methods cannot call instance methods directly.\nOptions B and D are correct and are the primary reasons to create a static interface \nmethod. Options C and E are incorrect and describe attributes of a default method. \nOption F applies only to private static interface methods, not public ones."
  },
  {
    "number": 46,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage space;\npublic class Bottle {\n   public static class Ship {\n      private enum Sail {          // w1\n         TALL {protected int getHeight() {return 100;}},\n         SHORT {protected int getHeight() {return 2;}};\n         protected abstract int getHeight();\n      }\n      public Sail getSail() {\n         return Sail.TALL;\n      }\n   }\n   public static void main(String[] stars) {\n      var bottle \u003d new Bottle();\n      Ship q \u003d bottle.new Ship();  // w2\n      System.out.print(q.getSail());\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "TALL",
      "The code does not compile because of line w1.",
      "The code does not compile because of line w2.",
      "The code does not compile for another reason.",
      "The code compiles, but the application does not produce any output at runtime.",
      "None of the above."
    ],
    "explanation": "The Bottle class includes a static nested class Ship that must be instantiated in a\nstatic manner. Line w2 uses an instance of Bottle to instantiate the Ship. Therefore, line \nw2 does not compile, and option C is the correct answer. Note that if Ship were changed to \nbe a member inner class, the code would still not compile since a member inner class cannot \ninclude static members and enums are inherently static."
  },
  {
    "number": 47,
    "chapter": 3,
    "question": "Which of the following is not a valid order for elements within a class?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Constructor, instance variables, method declarations",
      "Instance variables, static initializer constructor, method declarations",
      "Method declarations, instance variables, constructor",
      "Instance initializer, constructor, instance variables, constructor",
      "None of the above"
    ],
    "explanation": "The instance variables, constructor, instance and static initializers, and method declara\ntions can appear in any order within a class declaration."
  },
  {
    "number": 48,
    "chapter": 3,
    "question": "Which line of code, inserted at line p1, causes the application to print 5?\npackage games;\npublic class Jump {\n   private int rope \u003d 1;\n   protected boolean outside;\n   \n   public Jump() {\n      // line p1\n      outside \u003d true;\n   }\n   \n   public Jump(int rope) {\n      this.rope \u003d outside ? rope : rope+1;\n   }\n   \n   public static void main(String[] bounce) {\n      System.out.print(new Jump().rope);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "this(4);",
      "new Jump(4);",
      "this(5);",
      "rope \u003d 4;",
      "super(4);",
      "super(5);"
    ],
    "explanation": "First, all of the lines compile, but they produce various different results. Remember that\nthe default initialization of a boolean instance variable is false, so outside is false at \nline p1 .  Therefore, this(4) will cause rope to be set to 5, while this(5) will cause rope \nto be set to 6 .  Since 5 is the number we are looking for, option A is correct, and option C \nis incorrect. Option B is incorrect. While the statement does create a new instance of Jump, \nwith rope having a value of 5, that instance is nested, and the value of rope does not affect \nthe surrounding instance of Jump that the constructor was called in. Option D is also \nincorrect. The value assigned to rope is 4, not the target 5 .  Options E and F do not compile \nbecause the superclass is Object, which does not have a constructor taking an int."
  },
  {
    "number": 49,
    "chapter": 3,
    "question": "Which of the following is not a reason to use encapsulation when designing a class? \n(Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "Improve security.",
      "Increase concurrency and improve performance.",
      "Maintain class data integrity of data elements.",
      "Prevent users from modifying the internal attributes of a class.",
      "Prevent variable state from changing.",
      "Promote usability by other developers."
    ],
    "explanation": "Option A is true because encapsulation improves security because instance variables\ncannot be accessed directly. Implementing encapsulation prevents internal attributes of a class \nfrom being modified directly, so option D is a true statement. By preventing access to internal \nattributes, we can also maintain class data integrity between elements, making option C a \ntrue statement. Option F is also a true statement about encapsulation, since well-encapsulated \nclasses are often easier to use. Option B is an incorrect statement. Encapsulation makes\nno guarantees about performance and concurrency. Option E is also an incorrect statement \nbecause it describes immutability."
  },
  {
    "number": 50,
    "chapter": 3,
    "question": "Which statement about the following program is correct? (Choose two.)\npackage ballroom;\n \nclass Leader {}\nclass Follower {}\nabstract class Dancer {\n   public Leader getPartner() { return new Leader(); }\n   abstract public Leader getPartner(int count);  // u1\n}\n \npublic abstract class SwingDancer extends Dancer {\n   public Leader getPartner(int x) { return null; }\n   public Follower getPartner() {                 // u2\n      return new Follower();                      // u3\n   }\n   public static void main(String[] args) {\n      new SwingDancer().getPartner();             // u4\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      3,
      4
    ],
    "options": [
      "The code does not compile because of line u1.",
      "The code does not compile because of line u2.",
      "The code does not compile because of line u3.",
      "The code does not compile because of line u4.",
      "At least three of the classes compile without issue.",
      "All of the classes compile without issue."
    ],
    "explanation": "Line u2 does not compile because getPartner() is overridden with a return type\nthat is not covariant, as Follower is not the same type nor a subtype of the Leader class. \nLine u4 also does not compile because SwingDancer is marked abstract and cannot be \ninstantiated directly. For these reasons, options B and D are the correct answers. The rest of \nthe code compiles without issue."
  },
  {
    "number": 51,
    "chapter": 3,
    "question": "Which is not a true statement given this diagram? Assume all classes are public.",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Instance methods in the Blanket class can call the Flashlight class’s turnOn().",
      "Instance methods in the Flashlight class can call the Flashlight class’s replaceBulb().",
      "Instance methods in the Phone class can call the Blanket class’s wash().",
      "Instance methods in the Tent class can call the Tent class’s pitch().",
      "None of the above."
    ],
    "explanation": "Option A is allowed because the turnOn() method is public and can be called from\nanywhere. Options B and D are allowed since the method is in the same class, which is \nalways allowed! Option C is not allowed because wash() is a package-private method in \nanother package. Option C is the correct answer."
  },
  {
    "number": 52,
    "chapter": 3,
    "question": "Given the diagram in the previous question, how many of the classes shown in the diagram \ncan call the display() method?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "The display() method has protected access. This means it can be accessed by in\nstance methods in the same package and any subclasses. There are no subclasses in this \nexample, so we only need to count the classes in the same package. Option C is correct \nbecause Flashlight and Phone are in the package."
  },
  {
    "number": 53,
    "chapter": 3,
    "question": "Which of the following statements are correct? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "Java allows multiple inheritance using two abstract classes.",
      "Java allows multiple inheritance using two interfaces.",
      "Java does not allow multiple inheritance.",
      "An interface can extend another interface.",
      "An interface can implement another interface."
    ],
    "explanation": "While Java does not allow a class to extend more than one class, it does allow a class\nto implement any number of interfaces. Multiple inheritance is, therefore, only allowed via \ninterfaces, making option B correct. Interfaces can extend other interfaces, making option D \nthe other answer."
  },
  {
    "number": 54,
    "chapter": 3,
    "question": "Which statement about the following code is correct?\npublic class Dress {\n   int size \u003d 10;\n   default int getSize() {\n      display();\n      return size;\n   }\n   static void display() {\n      System.out.print(\"What a pretty outfit!\");\n   }\n   private int getLength() {\n      display();\n      return 15;\n   }\n   private static void tryOn() {\n      display();\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The code contains an invalid constant.",
      "The method getSize() does not compile.",
      "The method getLength() does not compile.",
      "The method tryOn() does not compile.",
      "The code compiles.",
      "None of the above."
    ],
    "explanation": "The Dress type is declared as a class, not an interface. For this reason, it cannot\ncontain the default method getSize(), making option B correct. The rest of the methods \ncompile within the class declaration without issue."
  },
  {
    "number": 55,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage ocean;\nabstract interface CanSwim {\n   public void swim(final int distance);\n}\npublic class Turtle {\n   final int distance \u003d 2;\n   public static void main(String[] seaweed) {\n      final int distance \u003d 3;\n      CanSwim seaTurtle \u003d {\n         final int distance \u003d 5;\n         @Override\n         public void swim(final int distance) {\n            System.out.print(distance);\n         }\n      };\n      seaTurtle.swim(7);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "2",
      "3",
      "5",
      "7",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The main() method attempts to define an anonymous class instance but fails to provide\nthe class or interface name, or use the new keyword. The right-hand side of the assignment \nto the seaTurtle variable should start with new CanSwim(). For this reason, option E is \nthe correct answer. If the code was corrected with the proper declaration, then the program \nwould output 7 at runtime."
  },
  {
    "number": 56,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage pet;\npublic class Puppy {\n   public static int wag \u003d 5;   // q1\n   public void Puppy(int wag) { // q2\n      this.wag \u003d wag;\n   }\n   public static void main(String[] tail) {\n      System.out.print(new Puppy(2).wag); // q3\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "2",
      "5",
      "The first line with a compiler error is line q1.",
      "The first line with a compiler error is line q2.",
      "The first line with a compiler error is line q3."
    ],
    "explanation": "The Puppy class does not declare a constructor, so the default no-argument constructor is\nautomatically inserted by the compiler. What looks like a constructor in the class is actually \na method that has a return type of void. Therefore, the line in the main() method to create \nthe new Puppy(2) object does not compile, since there is no constructor capable of taking \nan int value, making option E the correct answer."
  },
  {
    "number": 57,
    "chapter": 3,
    "question": "Given the following method signature, which classes can call it?\nvoid run(String government)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Classes in other packages",
      "Classes in the same package",
      "Subclasses in a different package",
      "All classes",
      "None of the above"
    ],
    "explanation": "The method signature has package-private, or default, access; therefore, it is accessible to\nclasses in the same package, making option B the correct answer."
  },
  {
    "number": 58,
    "chapter": 3,
    "question": "Which is the first declaration to not compile?\npackage desert;\n \ninterface CanBurrow {\n   public abstract void burrow();\n}\n \n@FunctionalInterface interface HasHardShell\n   extends CanBurrow {} \n \nabstract class Tortoise implements HasHardShell {\n   public abstract int toughness();\n}\npublic class DesertTortoise extends Tortoise {\n   public int toughness() { return 11; }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The CanBurrow interface does not compile.",
      "The HasHardShell interface does not compile.",
      "The Tortoise interface does not compile.",
      "The DesertTortoise interface does not compile.",
      "All of the interfaces compile."
    ],
    "explanation": "First, both CanBurrow and HasHardShell compile as functional interfaces since \nthey contain exactly one abstract method, although only the latter uses the optional  \n@FunctionalInterface annotation. The declarations of these two interfaces, along with \nthe abstract class Tortoise, compile without issue, making options A, B, and C incor-\nrect. The class DesertTortoise inherits two abstract methods, one from the interface \nCanBurrow and the other from the abstract parent class Tortoise. Since the class \nimplements only one of them and the class is concrete, the class declaration of  \nDesert Tortoise fails to compile, making option D the correct answer."
  },
  {
    "number": 59,
    "chapter": 3,
    "question": "Which is the first line to not compile?\ninterface Building {\n   default Double getHeight() { return 1.0; }         // m1\n}\ninterface Office {\n   public default String getHeight() { return null; } // m2\n}\nabstract class Tower implements Building, Office {}   // m3\npublic class Restaurant extends Tower {}              // m4",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Line m1",
      "Line m2",
      "Line m3",
      "Line m4",
      "None of the above"
    ],
    "explanation": "The interface declarations compile without issue. When inheriting two default methods\nwith the same signature, the Tower class is required to override both methods even if the \nclass is marked abstract. For this reason, line m3 is the first line that does not compile, and \noption C is correct. Note that there is no possible overridden method that can fulfill both \ninherited default methods since the return types are not covariant."
  },
  {
    "number": 60,
    "chapter": 3,
    "question": "What is the output of the following code snippet?\nString tree \u003d \"pine\";\nint count \u003d 0;\nif (tree.equals(\"pine\")) {\n   int height \u003d 55;\n   count \u003d count + 1;\n}\nSystem.out.print(height + count);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "1",
      "55",
      "56",
      "It does not compile."
    ],
    "explanation": "The height variable is declared within the if-then statement block. Therefore, it\ncannot be referenced outside the if statement, and the code does not compile."
  },
  {
    "number": 61,
    "chapter": 3,
    "question": "Which of the following are valid comments in Java? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4,
      5
    ],
    "userAnswers": [
      0,
      4,
      5
    ],
    "options": [
      "/****** TODO */",
      "# Fix this bug later",
      "\u0027 Error closing pod bay doors",
      "/ Invalid record /",
      "/* Page not found */",
      "// IGNORE ME"
    ],
    "explanation": "Java supports three types of comments: single-line (//), multiline (/* */), and \nJavadoc (/** **/), making options A, E, and F correct. The other options may be com-\nments in other languages, but not in Java."
  },
  {
    "number": 62,
    "chapter": 3,
    "question": "Which of the following modifiers can both be applied to a method? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      5
    ],
    "userAnswers": [
      0,
      2,
      5
    ],
    "options": [
      "private and final",
      "abstract and final",
      "static and private",
      "private and abstract",
      "abstract and static",
      "static and protected"
    ],
    "explanation": "An abstract method is one that will be implemented by a subclass. For this reason,\nit cannot be combined with final or private, as both prevent a method from being over-\nridden, making options B and D incorrect. An abstract method can also not be marked \nstatic, since static members belong to the class level, not an instance, making option \nE incorrect. Options A, C, and F are the correct answers. Note that marking a private \nmethod final has no practical implication, although it is allowed."
  },
  {
    "number": 63,
    "chapter": 3,
    "question": "Given the following class, what should be inserted into the two blanks to ensure the class \ndata is properly encapsulated?\npackage storage;\npublic class Box {\n   public String stuff;\n   __________ String  __________() {\n      return stuff;\n   }\n \n   public void setStuff(String stuff) {\n      this.stuff \u003d stuff;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "private and getStuff",
      "private and isStuff",
      "public and getStuff",
      "public and isStuff",
      "None of the above"
    ],
    "explanation": "The class data, stuff, is declared public, allowing any class to modify the stuff vari\nable and making the implementation inherently unsafe for encapsulation. Therefore, there are \nno values that can be placed in the two blanks to ensure the class properly encapsulates its \ndata, making option E correct. Note that if stuff were declared private, options A, B, C, \nand D would all be correct. Encapsulation does not require any specific method names, just \nthat the internal attributes are protected from outside access, which all of these sets of values \ndo achieve."
  },
  {
    "number": 64,
    "chapter": 3,
    "question": "How many rows of the following table contain an error?\n",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "The second row is incorrect, as private methods belong to an instance, not the class.\nThe fourth row is also incorrect, as default methods require a method body. The rest of the \nrows are correct, making option C correct."
  },
  {
    "number": 65,
    "chapter": 3,
    "question": "Fill in the blanks: ___________________ is used to call a constructor in the parent class, while \n___________________ is used to reference a member of the parent class.",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "super and this()",
      "super and super()",
      "super() and this",
      "super() and super",
      "None of the above"
    ],
    "explanation": "The super() statement is used to call a constructor in the parent class, while super is\nused to reference a member of the parent class. The this() statement is used to call a con-\nstructor in the current class, while this is used to reference a member of the current class. \nFor these reasons, option D is the correct answer."
  },
  {
    "number": 66,
    "chapter": 3,
    "question": "What is the output of the Watch program?\n1:  class SmartWatch extends Watch {\n2:     private String getType() { return \"smart watch\"; }\n3:     public String getName(String suffix) {\n4:        return getType() + suffix;\n5:     }\n6:  }\n7:  public class Watch {\n8:     private String getType() { return \"watch\"; }\n9:     public String getName(String suffix) {\n10:       return getType() + suffix;\n11:    }\n12:    public static void main(String[] args) {\n13:       var watch \u003d new Watch();\n14:       var smartWatch \u003d new SmartWatch();\n15:       System.out.print(watch.getName(\",\"));\n16:       System.out.print(smartWatch.getName(\"\"));\n17:    }\n18: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "smart watch,watch",
      "watch,smart watch",
      "watch,watch",
      "The code does not compile.",
      "An exception is printed at runtime.",
      "None of the above."
    ],
    "explanation": "Line 15 calls the method on line 9 since it is a Watch object. That returns watch, making\noption A incorrect. Line 16 calls the method on line 3 since it is a SmartWatch object and \nthe method is properly overridden. That returns smart watch, so option B is the answer, \nand option C is incorrect."
  },
  {
    "number": 67,
    "chapter": 3,
    "question": "What is the output of the Movie program?\npackage theater;\nclass Cinema {\n   private String name \u003d \"Sequel\";\n   public Cinema(String name) {\n      this.name \u003d name;\n   }\n}\npublic class Movie extends Cinema {\n   private String name \u003d \"adaptation\";\n   public Movie(String movie) {\n      this.name \u003d \"Remake\";\n   }\n   public static void main(String[] showing) {\n      System.out.print(new Movie(\"Trilogy\").name);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Sequel",
      "Trilogy",
      "Remake",
      "Adaptation",
      "null",
      "None of the above"
    ],
    "explanation": "The Cinema class defines a constructor that takes a String value, which means the com\npiler does not insert the default no-argument constructor. Therefore, it is not available in the \nMovie constructor, and an explicit constructor must be called with super(). Since this is \nnot done, the Movie constructor does not compile, making option F the correct answer. The \nrest of the code compiles without issue."
  },
  {
    "number": 68,
    "chapter": 3,
    "question": "Where can a final instance variable be assigned a value? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      4
    ],
    "userAnswers": [
      1,
      3,
      4
    ],
    "options": [
      "Instance initializer",
      "static initializer",
      "Instance method",
      "On the line it is declared",
      "Class constructor",
      "static method"
    ],
    "explanation": "A final instance must be assigned a value (exactly once) on the line it is declared, in\nan instance initializer, or in a constructor. This makes options A, D, and E correct."
  },
  {
    "number": 69,
    "chapter": 3,
    "question": "What is the output of the following code?\npublic class Bunny {\n   static interface Rabbit { }\n   static class FlemishRabbit implements Rabbit { }\n \n   private static void hop(Rabbit r) {\n      System.out.print(\"hop\");\n   }\n   private static void hop(FlemishRabbit r) {\n      System.out.print(\"HOP\");\n   }\n   public static void main(String[] args) {\n      Rabbit r1 \u003d new FlemishRabbit();\n      FlemishRabbit r2 \u003d new FlemishRabbit();\n      hop(r1);\n      hop(r2);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "hophop",
      "HOPhop",
      "hopHOP",
      "HOPHOP",
      "The code does not compile."
    ],
    "explanation": "This example deals with method signatures rather than polymorphism. Since the hop()\nmethods are static, the precise method called depends on the reference type rather than \nthe actual type of the object. Since the first reference is Rabbit, the first value printed is \nhop. The second reference actually is FlemishRabbit, so HOP is printed, and option C is \nthe answer."
  },
  {
    "number": 70,
    "chapter": 3,
    "question": "Which of the following results is not a possible output of this program?\npackage sea;\nenum Direction { north, south, east, west; };\npublic class Ship {\n   public static void main(String[] compass) {\n      System.out.print(Direction.valueOf(compass[0]));\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "WEST is printed.",
      "south is printed.",
      "An ArrayIndexOutOfBoundsException is thrown at runtime.",
      "An IllegalArgumentException is thrown at runtime.",
      "All of the above are possible."
    ],
    "explanation": "If the program is called with a single input south, then south would be printed at run\ntime. If the program is called with no input, then the compass array would be of size zero \nand an ArrayIndexOutOfBoundsException would be thrown at runtime. Finally, if the \nprogram is called with a string that does not match one of the values in Direction, then an \nIllegalArgumentException would be thrown at runtime. The only result not possible is \nWEST, since the enum value is in lowercase, making option A the correct answer."
  },
  {
    "number": 71,
    "chapter": 3,
    "question": "Which statement about encapsulation is not true?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Encapsulation allows putting extra logic in the getter and setter methods.",
      "Encapsulation can use immutable instance variables in the implementation.",
      "Encapsulation causes two classes to be more tightly tied together.",
      "Encapsulation makes it easier to change the instance variables in the future.",
      "All of the above are true."
    ],
    "explanation": "Encapsulation doesn’t allow callers access to the instance variables, which makes it easier\nto change the code. The instance variables can be any type, which means they can be mutable \nor immutable. There are not constraints on the implementation of methods. The purpose of \nencapsulation is to lessen how tightly tied or coupled the classes are. Option C is the opposite \nof this, making it the answer."
  },
  {
    "number": 72,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage radio;\npublic class Song {\n   public void playMusic() {\n      System.out.print(\"Play!\");\n   }\n   private static void playMusic() {\n      System.out.print(\"Music!\");\n   }\n   private static void playMusic(String song) {\n      System.out.print(song);\n   }\n   public static void main(String[] tracks) {\n      new Song().playMusic();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Play!",
      "Music!",
      "The code does not compile.",
      "The code compiles, but the answer cannot be determined until runtime."
    ],
    "explanation": "A class cannot contain two methods with the same method signature, even if one is\nstatic and the other is not. Therefore, the code does not compile because the two declara-\ntions of playMusic() conflict with one another, making option C the correct answer."
  },
  {
    "number": 73,
    "chapter": 3,
    "question": "Which of the following statements about overriding a method are correct? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4,
      5
    ],
    "userAnswers": [
      0,
      4,
      5
    ],
    "options": [
      "The return types must be covariant.",
      "The access modifier of the method in the child class must be the same or narrower than\nthe method in the superclass.",
      "The return types must be the same.",
      "A checked exception thrown by the method in the parent class must be thrown by the\nmethod in the child class.",
      "A checked exception thrown by a method in the child class must be the same or narrower\n than the exception thrown by the method in the parent class.",
      "The access modifier of the method in the child class must be the same or broader than\nthe method in the superclass."
    ],
    "explanation": "First, the return types of an overridden method must be covariant, making option A\ncorrect. They can be the same, but it is not required, making option C incorrect. Next, the \naccess modifier must be the same or broader in the child method, making option B incorrect \nand option F correct. Option D is incorrect as an overridden method is not required to throw \na checked exception declared in the parent version of the method. If it does declare a checked \nexception, it cannot be new or broader than the ones declared in the superclass, making \noption E correct."
  },
  {
    "number": 74,
    "chapter": 3,
    "question": "How many lines of the following code do not compile?\n10: interface Flavor {\n11:    public default void happy() {\n12:       printFlavor(\"Rocky road\");\n13:    }\n14:    private static void excited() {\n15:       printFlavor(\"Peanut butter\");\n16:    }\n17:    private void printFlavor(String f) {\n18:       System.out.println(\"Favorite Flavor is: \"+f);\n19:    }\n20:    public static void sad() {\n21:       printFlavor(\"Butter pecan\");\n22:    }\n23: }\n24: public class IceCream implements Flavor {\n25:    @Override public void happy() {\n26:       printFlavor(\"Cherry chocolate chip\");\n27:    } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "None, they all compile",
      "One",
      "Two",
      "Three",
      "Four",
      "Five or more"
    ],
    "explanation": "A private non-static interface method may only be accessed from other private\nor default methods declared within the interface. Lines 15 and 21 do not compile because \nthe private method is called within static methods. Line 26 does not compile because \na private interface method cannot be called in a method outside the interface declaration. \nSince these three lines do not compile, option D is correct."
  },
  {
    "number": 75,
    "chapter": 3,
    "question": "Of the following four modifiers, choose the one that is not implicitly applied to all interface \nvariables.",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "final",
      "abstract",
      "static",
      "public"
    ],
    "explanation": "Interface variables are implicitly public, static, and final. Variables cannot be\ndeclared as abstract in interfaces, nor in classes. Therefore, option B is the answer."
  },
  {
    "number": 76,
    "chapter": 3,
    "question": "Given the following method, what is the first line that does not compile?\npublic static void main(String[] args) {\n   int Integer \u003d 0;        // k1\n   Integer int \u003d 0;        // k2\n   Integer ++;             // k3\n   int++;                  // k4\n   int var \u003d null;         // k5\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "k1",
      "k2",
      "k3",
      "k4",
      "k5"
    ],
    "explanation": "Integer is the name of a class in Java. While it is bad practice to use the name of a class\nas your local variable name, this is legal. Therefore, k1 does compile. It is not legal to use a \nreserved word as a variable name. All of the primitives including int are reserved words. \nTherefore, k2 does not compile, and option B is the answer. Lines k4 and k5 don’t compile \neither, but the question asks about the first line to not compile."
  },
  {
    "number": 77,
    "chapter": 3,
    "question": "What is the result of compiling and executing the following class?\npublic class Tolls {\n   private static int yesterday \u003d 1;\n   int tomorrow \u003d 10;\n \n   public static void main(String[] args) {\n      var tolls \u003d new Tolls();\n      int today \u003d 20, tomorrow \u003d 40;  // line x\n      System.out.print(\n         today + tolls.tomorrow + tolls.yesterday); // line y\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "The code does not compile due to line x.",
      "The code does not compile due to line y.",
      "31",
      "61"
    ],
    "explanation": "The code compiles and runs without issue, so options A and B are incorrect. The question\nrelies on your ability to understand variable scope. The variable today has local scope to \nthe method in which it is executed. The variable tomorrow is re-declared in the method, but \nthe reference used on line y is to the instance variable with a value of 10 .  Finally, the variable\nyesterday is static. While using an instance reference to access a static variable is not \nrecommended, it does not prevent the variable from being read. The result is line y evaluates \nand prints 31 (20 + 10 + 1), making option C the correct answer."
  },
  {
    "number": 78,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage weather;\npublic class Forecast {\n   public enum Snow {\n      BLIZZARD, SQUALL, FLURRY\n      @Override public String toString() { return \"Sunny\"; }\n   }\n \n   public static void main(String[] modelData) {\n      System.out.print(Snow.BLIZZARD.ordinal() + \" \");\n      System.out.print(Snow.valueOf(\"flurry\".toUpperCase()));\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "0 FLURRY",
      "1 FLURRY",
      "0 Sunny",
      "1 Sunny",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "If an enum contains anything other than a list of values, then a semicolon (;) must follow\nthe list of values. The Snow enum includes a method, so there must be a semicolon after the \nlast value, FLURRY. For this reason, the code does not compile, and option E is correct.  \nIf the semicolon was added, then the code would compile and print 0 Sunny at runtime, \nwith the overridden toString() replacing the default value of FLURRY."
  },
  {
    "number": 79,
    "chapter": 3,
    "question": "Which of the following is not a true statement?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "The first line of every constructor is a call to the parent constructor via the super() command.",
      "A class is not required to have a constructor explicitly defined.",
      "A constructor may pass arguments to the parent constructor.",
      "A final instance variable whose value is not set when it is declared or in an initialization\nblock should be set by the constructor.",
      "None of the above."
    ],
    "explanation": "Option A is the correct answer because the first line of a constructor could be this() or\nsuper(), making it an untrue statement. Option B is a true statement because the compiler \nwill insert the default no-argument constructor if one is not defined. Option C is also a true \nstatement, since zero or more arguments may be passed to the parent constructor, if the  \nparent class defines such constructors. Option D is also true. The value of a final instance \nvariable must be set when it is declared, in an initialization block, or in a constructor."
  },
  {
    "number": 80,
    "chapter": 3,
    "question": "What can fill in the blank so the play() method can be called from all classes in the com.\nmammal and com.mammal.eland package, but not the com.mammal.gopher package?\npackage com.mammal;\n \npublic class Enrichment {\n    void play() {}\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Leave it blank.",
      "private",
      "protected",
      "public",
      "None of the above."
    ],
    "explanation": "If only the com.mammal class needed access, option A would be correct. Access modifiers\ncannot be used to grant access to a list of packages. The Java Platform Module Framework \ncan do this, but it is not an option in this question. Therefore, option E is correct."
  },
  {
    "number": 81,
    "chapter": 3,
    "question": "What is the output of the Rocket program?\npackage transport;\n \nclass Ship {\n   protected int weight \u003d 3;\n   private int height \u003d 5;\n   public int getWeight() { return weight; }\n   public int getHeight() { return height; }\n}\n \npublic class Rocket extends Ship {\n   public int weight \u003d 2;\n   public int height \u003d 4;\n   public void printDetails() {\n      System.out.print(super.getWeight()+\",\"+super.height);\n   }\n   public static final void main(String[] fuel) {\n      new Rocket().printDetails();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "2,5",
      "3,4",
      "5,2",
      "3,5",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The code does not compile because super.height is not visible in the Rocket class,\nmaking option E the correct answer. Even though the Rocket class defines a height value, \nthe super keyword looks for an inherited version. Since there are none, the code does not \ncompile. Note that super.getWeight() returns 3 from the variable in the parent class, as \npolymorphism and overriding do not apply to instance variables."
  },
  {
    "number": 82,
    "chapter": 3,
    "question": "Imagine you are working with another team to build an application. You are developing \ncode that uses a class that the other team has not finished writing yet. You want to allow \neasy integration once the other team’s code is complete. Which statements would meet this \nrequirement? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "An abstract class is best.",
      "An interface is best.",
      "Either of an abstract class or interface would meet the requirement.",
      "The methods should be protected.",
      "The methods should be public.",
      "The methods should be static."
    ],
    "explanation": "The key here is understanding which of these features of Java allow one developer to\nbuild their application around another developer’s code, even if that code is not ready yet. \nFor this problem, an interface is the best choice. If the two teams agree on a common inter-\nface, one developer can write code that uses the interface, while another developer writes \ncode that implements the interface. Assuming neither team changes the interface, the code \ncan be easily integrated once both teams are done. For these reasons, option B is correct. \nInterfaces expose methods using the public keyword, making option E the other answer."
  },
  {
    "number": 83,
    "chapter": 3,
    "question": "Fill in the blank with the line of code that allows the program to compile and print 10 \nat runtime.\ninterface Speak {\n   public default int getVolume() { return 20; }\n}\ninterface Whisper {\n   public default int getVolume() { return 10; } \n}\npublic class Debate implements Speak, Whisper {\n   public int getVolume() { return 30; }\n   public static void main(String[] a) {\n      var d \u003d new Debate();\n      System.out.println(______________);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Whisper.d.getVolume()",
      "d.Whisper.getVolume()",
      "Whisper.super.getVolume()",
      "d.Whisper.super.getVolume()",
      "The code does not compile regardless of what is inserted into the blank.",
      "None of the above."
    ],
    "explanation": "The code compiles, even if the blank is replaced with a constant value, making option E\nincorrect. Note that the class correctly overrides both inherited default methods. While it \nis possible to call a specific inherited default method, even when it has been overridden, it \nrequires calling super, which is not accessible from a static method. For these reasons, \noptions A, B, C, and D do not work, making option F correct."
  },
  {
    "number": 84,
    "chapter": 3,
    "question": "Which of the following properties of an enum can be marked abstract?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "The enum type definition",
      "An enum method",
      "An enum value",
      "An enum constructor",
      "None of the above"
    ],
    "explanation": "An enum declaration itself cannot be marked abstract, nor can any of its values, but\nits methods can be marked abstract, making option B the correct answer. Note that if an \nenum contains an abstract method, then every enum value must include an override of this \nabstract method."
  },
  {
    "number": 85,
    "chapter": 3,
    "question": "How many lines does the following code output?\npublic class Cars {\n  static {\n     System.out.println(\"static\");\n  }\n  private static void drive() {\n     System.out.println(\"fast\");\n  }\n  { System.out.println(\"faster\"); }\n  public static void main(String[] args) {\n     drive();\n     drive();\n  }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "Five.",
      "None of the above. The code does not compile."
    ],
    "explanation": "The static initializer is run only once. The static method is run twice since it is called\ntwice. Therefore, three lines are printed, and option C is correct. The instance initializer block \nis never run because the Cars class is never constructed."
  },
  {
    "number": 86,
    "chapter": 3,
    "question": "Suppose foo is a reference to an instance of a class Foo. Which of the following is not pos-\nsible about the variable reference foo.bar?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "bar is an instance variable.",
      "bar is a static variable.",
      "bar is a local variable.",
      "It can be used to read from bar.",
      "It can be used to write to bar.",
      "All of the above are possible."
    ],
    "explanation": "Dot notation is used for both reading and writing instance variables, assuming they are in\nscope. It cannot be used for referencing local variables, making option C the correct answer. \nIt is possible that bar is a static variable, although accessing it in this manner is not \nrecommended."
  },
  {
    "number": 87,
    "chapter": 3,
    "question": "The following diagram shows two reference variables pointing to the same Bunny object in \nmemory. The reference variable myBunny is of type Bunny, while unknownBunny is a valid \nbut unknown data type. Which statements about the reference variables are true? Assume the \ninstance methods and variables shown in the diagram are marked public. (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      4
    ],
    "userAnswers": [],
    "options": [
      "The reference type of unknownBunny must be Bunny or a supertype of Bunny.",
      "The reference type of unknownBunny cannot be cast to a reference type of Bunny.",
      "The reference type of unknownBunny must be Bunny or a subclass of Bunny.",
      "If the reference type of unknownBunny is Bunny, it has access to all of the same\nmethods and variables as myBunny.",
      "The reference type of unknownBunny could be an interface, class, or abstract class.",
      "If the reference type of unknownBunny is Object, it has access to all of the same methods\nand variables as myBunny without a cast."
    ],
    "explanation": "The reference type of unknownBunny must be Bunny or a supertype of Bunny,\nincluding any abstract classes, concrete classes, or interfaces that Bunny inherits. For this \nreason, options A and E are correct, and option C is incorrect. Option B is incorrect. Since it \nalready points to an instance of Bunny, casting it to a Bunny reference is allowed. Option \nD is trivially true. If the reference types of both are the same, then they can call the same in-\nstance members. Option F is incorrect, as casting is required to access members declared in \nBunny that are not defined in Object."
  },
  {
    "number": 88,
    "chapter": 3,
    "question": "Which of the following interface methods are inherited by classes that implement the  \ninterface? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "private methods",
      "private static methods",
      "default methods",
      "static methods",
      "abstract methods",
      "final methods"
    ],
    "explanation": "Methods marked private or static are never inherited, so options A, B, and D are\nincorrect. Interface methods cannot be final, so option F is incorrect. That leaves default \nand abstract methods, which are both inherited by classes implementing the interface."
  },
  {
    "number": 89,
    "chapter": 3,
    "question": "Which of these are functional interfaces?\ninterface Lion {\n   public void roar();\n   default void drink() {}\n   String toString();\n}\n \ninterface Tiger {\n   public void roar();\n   default void drink() {}\n   int hashCode();\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Lion",
      "Tiger",
      "Both Lion and Tiger",
      "Neither is a functional interface.",
      "The code does not compile."
    ],
    "explanation": "The code does compile, so option E is incorrect. A functional interface is required to have\nexactly one abstract method. In both interfaces, that is roar(). The toString() and \nhashCode() method signatures match those from Object. Since they are provided to all \nsubclasses, they are not considered abstract. Since roar() is the only abstract method, \nboth are functional interfaces, making option C the answer."
  },
  {
    "number": 90,
    "chapter": 3,
    "question": "Given the following code, which lines when placed independently in the blank allow the code \nto compile and print bounce? (Choose two.)\npublic class TennisBall {\n   public TennisBall() {\n      System.out.println(\"bounce\");\n   }\n   public static void main(String[] slam) {\n       _________________________\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "var new \u003d TennisBall;",
      "TennisBall();",
      "var var \u003d new TennisBall();",
      "new TennisBall;",
      "new TennisBall();"
    ],
    "explanation": "To call a constructor, you must use the new keyword, making option E correct. It\ncannot be called as if it was a normal method. This rules out options A and B .  Further, option \nD is incorrect because the parentheses are required. Option C is also correct, as var may be \nused as a variable name."
  },
  {
    "number": 91,
    "chapter": 3,
    "question": "How many of these methods compile?\npublic class Singing {\n   private void sing(String key) { }\n   public void sing_do(String key, String... harmonies) {\n     this.sing(key);\n   }\n   public void sing_re(int note, String... sound, String key) {\n      this.sing(key);\n   } \n   public void sing_me(String... keys, String... pitches) {\n      this.sing(key);\n   }\n   public void sing_far(String key, String... harmonies) {\n      this.Singing.sing(key);\n   }\n   public void sing_so(int note, String... sound, String key) {\n     this.Singing.sing(key);\n   }\n   public void sing_la(String... keys, String... pitches) {\n      this.Singing.sing(key);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "To a call an instance method, you can use the this prefix. The class name is not included,\nruling out the last three methods. A method may contain at most one varargs parameter, and \nit must appear as the last argument in the list. For this reason, the sing_do() method is the \nonly method using varargs that compiles. The sing() method also compiles without using \nvarargs. Therefore, option C is the answer."
  },
  {
    "number": 92,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage world;\npublic class Matrix {\n   private int level \u003d 1;\n   class Deep {\n      private int level \u003d 2;\n      class Deeper {\n         private int level \u003d 5;\n         public void printReality(int level) {\n            System.out.print(this.level+\" \");\n            System.out.print(Matrix.Deep.this.level+\" \");\n            System.out.print(Deep.this.level);\n         }\n      }\n   }\n   public static void main(String[] bots) {\n      Matrix.Deep.Deeper simulation \u003d new Matrix()\n         .new Deep().new Deeper();\n      simulation.printReality(6);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "1 1 2",
      "5 2 2",
      "5 2 1",
      "6 2 2",
      "6 2 1",
      "The code does not compile."
    ],
    "explanation": "The code compiles without issue. The first print() statement refers to level declared\nin the Deeper class, so 5 is printed. The second and third print() statements actually refer \nto the same value in the Deep class, so 2 is printed twice. The prefix Matrix. is unnecessary \nin the first of the two print() statements and does not change the result. For these reasons, \noption B is the correct answer."
  },
  {
    "number": 93,
    "chapter": 3,
    "question": "Given that Integer and Long are direct subclasses of Number, what type can be used to fill \nin the blank in the following class to allow it to compile?\npackage orchestra;\ninterface MusicCreator { public Number play(); }\nabstract class StringInstrument {\n   public Long play() {return 3L;}\n}\npublic class Violin extends StringInstrument \n      implements MusicCreator {\n   public _________ play() {\n      return null;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "Long",
      "Integer",
      "Long or Integer",
      "Long or Number",
      "Long, Integer, or Number",
      "None of the above"
    ],
    "explanation": "The play() method is overridden in Violin for both MusicCreator and \nStringInstrument, so the return type must be covariant with both. Long is a subclass of \nNumber, and therefore, it is covariant with the version in MusicCreator. Since it matches the \ntype in StringInstrument, it can be inserted into the blank, and the code would compile.\nWhile Integer is a subclass of Number, meaning the override for MusicCreator is valid, \nit is not a subclass of Long used in StringInstrument. Therefore, using Integer would \ncause the code to not compile.\nFinally, Number is compatible with the version of the method in MusicCreator but not \nwith the version in StringInstrument, because Number is a superclass of Long, not a \nsubclass. For these reasons, Long is the only class that allows the code to compile, making \noption A the correct answer."
  },
  {
    "number": 94,
    "chapter": 3,
    "question": "What is the output of the RightTriangle program?\npackage shapes;\n \nabstract class Triangle {\n   abstract String getDescription();\n}\nabstract class IsoRightTriangle extends RightTriangle { // g1\n   public String getDescription() { return \"irt\"; }\n}\npublic class RightTriangle extends Triangle {\n   protected String getDescription() { return \"rt\"; }  // g2\n   public static void main(String[] edges) {\n      final var shape \u003d new IsoRightTriangle();        // g3\n      System.out.print(shape.getDescription());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "rt",
      "irt",
      "The code does not compile due to line g1.",
      "The code does not compile due to line g2.",
      "The code does not compile due to line g3.",
      "None of the above."
    ],
    "explanation": "The IsoRightTriangle class is abstract; therefore, it cannot be instantiated on line\ng3 .  If the abstract modifier was removed from the IsoRightTraingle declaration, \nthen the rest of the code would compile and print irt at runtime."
  },
  {
    "number": 95,
    "chapter": 3,
    "question": "What is the output of the following program?\ninterface Dog {\n   private void buryBone() { chaseTail(); }\n   private static void wagTail() { chaseTail(); }\n   public default String chaseTail() { return \"So cute!\"; }\n}\npublic class Puppy implements Dog {\n   public String chaseTail() throws IllegalArgumentException {\n      throw new IllegalArgumentException(\"Too little!\");\n   }\n   public static void main(String[] t) {\n      var p \u003d new Puppy();\n      System.out.print(p.chaseTail());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "So cute!",
      "An exception is thrown with a Too little! message.",
      "A different exception is thrown.",
      "The code does not compile because buryBone() is not used.",
      "The code does not compile because chaseTail() cannot declare any exceptions in the Puppy class.",
      "None of the above."
    ],
    "explanation": "The private static method wagTail()attempts to access an instance-based\ndefault method chaseTail(), which results in a compiler error, making option F \ncorrect. While buryBone() is not used, it does not result in a compiler error, making \noption D incorrect. Overridden methods are permitted to declare new unchecked excep-\ntions, and since IllegalArgumentException is unchecked, the override is allowed, \nmaking option E incorrect."
  },
  {
    "number": 96,
    "chapter": 3,
    "question": "Which of the following are advantages of using enumerated types in Java, rather than static \nconstant values? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      3
    ],
    "userAnswers": [],
    "options": [
      "Improve performance.",
      "Provide access to fixed set of constants whose values do not change during the course of the application.",
      "Provide a caller with a list of available values for a parameter within a method.",
      "Ensure consistency of data across an application.",
      "Add support for concurrency.",
      "Offer ability to create new enumerated values at runtime."
    ],
    "explanation": "Enumerated types support creating a set of reusable values whose values are fixed\nand consistent across the entire application. For these reasons, options B and D are correct, \nand option F is incorrect. Option C is also correct, as it provides callers of a method with a \nlist of acceptable values. Finally, options A and E are incorrect. Using an enum does not, by \nitself, improve performance or support concurrency."
  },
  {
    "number": 97,
    "chapter": 3,
    "question": "How do you force garbage collection to occur at a certain point?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "Calling System.forceGc()",
      "Calling System.gc()",
      "Calling System.requireGc()",
      "Calling GarbageCollection.clean()",
      "None of the above"
    ],
    "explanation": "While you can suggest to the JVM that it might want to run a garbage collection cycle,\nthe JVM is free to ignore your suggestion. Option B is how to make this suggestion. Since \ngarbage collection is not guaranteed to run, option E is correct."
  },
  {
    "number": 98,
    "chapter": 3,
    "question": "Which changes made to the following class would help to properly encapsulate the data in \nthe class?\npackage shield;\npublic class Protect {\n   private String material;\n   protected int strength;\n \n   public int getStrength() {\n      return strength;\n   }\n   public void setStrength(int strength) {\n      this.strength \u003d strength;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Add a getter method for material.",
      "Add a setter method for material.",
      "Change the access modifier of material to protected.",
      "Change the access modifier of strength to private.",
      "None of the above."
    ],
    "explanation": "The access modifier of strength is protected, meaning subclasses and classes within\nthe same package can modify it. Changing the value to private would improve encapsu-\nlation by making the Protect class the only one capable of directly modifying it. For these \nreasons, option D is correct."
  },
  {
    "number": 99,
    "chapter": 3,
    "question": "Which are true statements about referencing variables from a lambda? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [],
    "options": [
      "Instance and static variables can be used regardless of whether effectively final.",
      "Instance and local variables can be used regardless of whether effectively final.",
      "Instance variables and method parameters must be effectively final to be used.",
      "Local variables and method parameters must be effectively final to be used.",
      "Local and static variables can be used regardless of whether effectively final.",
      "Method parameters and static variables can be used regardless of whether effectively "
    ],
    "explanation": "A lambda can reference any instance variable, static variable, or lambda param\neter that is in scope, making option A correct. Lambdas require local variables and method \nparameters to be effectively final in order to use them, making option D the other correct \nanswer."
  },
  {
    "number": 100,
    "chapter": 3,
    "question": "Given the following two classes, each in a different package, which line inserted into the \ncode allows the second class to compile?\npackage commerce;\npublic class Bank {\n   public void withdrawal(int amountInCents) {}\n   public void deposit(int amountInCents) {}\n}\n \npackage employee;\n// INSERT CODE HERE\npublic class Teller {\n   public void processAccount(int deposit, int withdrawal) {\n      withdrawal(withdrawal);\n      deposit(deposit);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "import static commerce.Bank.*;",
      "import static commerce.Bank;",
      "static import commerce.Bank.*;",
      "static import commerce.Bank;",
      "None of the above"
    ],
    "explanation": "A static import is used to import static members of another class. In this case, the\nwithdrawal() and deposit() methods in the Bank class are not marked static. \nThey require an instance of Bank to be used and cannot be imported as static methods. \nTherefore, option E is correct. If the two methods in the Bank class were marked static, \nthen option A would be the correct answer since wildcards can be used with static \nimports to import more than one method. Options C and D reverse the keywords static \nand import, while option B incorrectly imports a class, which cannot be imported via a \nstatic import."
  },
  {
    "number": 101,
    "chapter": 3,
    "question": "Given the following structure, which snippets of code return true? (Choose three.)\ninterface Friendly {}\nabstract class Dolphin implements Friendly {}\nclass Animal implements Friendly {}\nclass Whale extends Object {}\npublic class Fish {}\nclass Coral extends Animal {}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "new Coral() instanceof Friendly",
      "null instanceof Object",
      "new Coral() instanceof Object",
      "new Fish() instanceof Friendly",
      "new Whale() instanceof Object",
      "new Dolphin() instanceof Friendly"
    ],
    "explanation": "Option A returns true since Coral inherits Friendly from its superclass\nAnimal. Option B is false, as using null with the instanceof operator always returns \nfalse. Options C and E both return true because all classes inherit Object, even those \nthat don’t explicitly extend it. Option D is false because Fish does not inherit the \nFriendly interface. Finally, option F does not compile as Dolphin is abstract and cannot \nbe instantiated directly. If it was not marked abstract, then it would return true. "
  },
  {
    "number": 102,
    "chapter": 3,
    "question": "What is true of the following code?\npublic class Eggs {\n   enum Animal {\n      CHICKEN(21), PENGUIN(75);\n \n      private int numDays;\n      private Animal(int numDays) {\n         this.numDays \u003d numDays;\n      }\n      public int getNumDays() {\n         return numDays;\n      }\n      public void setNumDays(int numDays) {\n         this.numDays \u003d numDays;\n      }\n   }\n   public static void main(String[] args) {\n       Animal chicken \u003d Animal.CHICKEN;\n       chicken.setNumDays(20);\n \n       System.out.print(chicken.getNumDays());\n       System.out.print(\" \");\n       System.out.print(Animal.CHICKEN.getNumDays());\n       System.out.print(\" \");\n       System.out.print(Animal.PENGUIN.getNumDays());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "It prints 20 20 20",
      "It prints 20 20 75",
      "It prints 20 21 75",
      "It prints 21 21 75",
      "It does not compile due to setNumDays().",
      "It does not compile for another reason."
    ],
    "explanation": "While it is not recommended to change the value of an enum after it is created, it is\nlegal. Each enum value has its own copy of numDays. This means the setter changes it for \nCHICKEN, but not for PENGUIN. Therefore, option B is correct. Both calls on CHICKEN \nprint the updated value of 20, while PENGUIN retains the original 75 ."
  },
  {
    "number": 103,
    "chapter": 3,
    "question": "What statement about the following interface is correct?\n1: public interface Thunderstorm {\n2:    float rain \u003d 1;\n3:    char getSeason() { return \u0027W\u0027; }\n4:    boolean isWet();\n5:    private static void hail() {}\n6:    default String location() { return \"Home\"; }\n7:    private static int getTemp() { return 35; }\n8: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "Line 2 does not compile.",
      "Line 3 does not compile.",
      "Line 4 does not compile.",
      "Line 5 does not compile.",
      "Line 6 does not compile.",
      "Line 7 does not compile."
    ],
    "explanation": "Line 3 does not compile, as a method with a body within an interface must be explicitl\nmarked static, default, or private, making option B correct. The rest of the lines\ncompile without issue. For this question, it helps to remember which implicit modifiers\nthe compiler will insert, and which it will not. On line 2, the compiler will insert public\nstatic final automatically, and on lines 4 and 6, the compiler will insert public automatically.\nThe compiler will also insert abstract on line 4 since the method does not\ndeclare a body."
  },
  {
    "number": 104,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage finance;\n \nenum Currency {\n   DOLLAR, YEN, EURO\n}\nabstract class Provider {\n   protected Currency c \u003d Currency.EURO;\n}\npublic class Bank extends Provider {\n   protected Currency c \u003d Currency.DOLLAR;\n   public static void main(String[] pennies) {\n      int value \u003d 0;\n      switch(new Bank().c) {\n         case 0:\n            value--; break;\n         case 1:\n            value++; break;\n      }\n      System.out.print(value);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "-1",
      "0",
      "1",
      "The Provider class does not compile.",
      "The Bank class does not compile.",
      "None of the above."
    ],
    "explanation": "The type of the variable in the switch statement is the enum Currency, but the case\nstatements use int values. While the enum class hierarchy does support an ordinal() \nmethod, which returns an int value, the enum values cannot be compared directly with \nint values. For this reason, the Bank class does not compile, making option E the correct \nanswer."
  },
  {
    "number": 105,
    "chapter": 3,
    "question": "How many lines need to be removed for this code to compile?\n1:  package figures;\n2:  public class Dolls {\n3:     public int num() { return 3.0; }\n4:     public int size() { return 5L; }\n5:\n6:     public void nested() { nested(2,true); }\n7:     public int nested(int w, boolean h) { return 0; }\n8:     public int nested(int level) { return level+1; }\n9:\n10:    public static void main(String[] outOfTheBox) {\n11:       System.out.print(new Dolls().nested());\n12:    }\n13: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Lines 3 and 4 do not compile because the returned values of double and long are not\ncompatible with int. Lines 6 through 8 compile without issue, since each method takes \na different set of input arguments. The first line of the main() method does not compile \neither, making option D correct. The no-argument version of the nested() method does \nnot return a value, and trying to output a void return type in the print() method doesn’t \ncompile."
  },
  {
    "number": 106,
    "chapter": 3,
    "question": "Fill in the blanks: A class may be assigned to a(n) ___________________ reference variable \nautomatically but requires an explicit cast when assigned to a(n) ___________________  \nreference variable.",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "subclass, outer class",
      "superclass, subclass",
      "concrete class, subclass",
      "subclass, superclass",
      "abstract class, concrete class"
    ],
    "explanation": "A class can trivially be assigned to a superclass reference variable but requires an explici\n cast to be assigned to a subclass reference variable. For these reasons, option B is correct."
  },
  {
    "number": 107,
    "chapter": 3,
    "question": "Which statement about functional interfaces is incorrect?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "A functional interface can have any number of static methods.",
      "A functional interface can have any number of default methods.",
      "A functional interface can have any number of private static methods.",
      "A functional interface can have any number of abstract methods.",
      "A functional interface can have any number of private methods.",
      "All of the above are correct."
    ],
    "explanation": "A functional interface may have any number of static, default, private static,\nor private methods. It can have only one qualified abstract method, though, making \noption D correct."
  },
  {
    "number": 108,
    "chapter": 3,
    "question": "What are possible outputs of the following given that the comment on line X can be \nreplaced by code?\n// Mandrill.java\npublic class Mandrill {\n   public int age;\n   public Mandrill(int age) {\n      this.age \u003d age;\n   }\n   public String toString() {\n      return \"\" + age;\n   }\n}\n \n// PrintAge.java\npublic class PrintAge {\n   public static void main (String[] args) {\n      var mandrill \u003d new Mandrill(5);\n \n      // line X\n \n      System.out.println(mandrill);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "0",
      "5",
      "Either 0 or 5",
      "Any int value",
      "Does not compile"
    ],
    "explanation": "This class has poor encapsulation since the age variable is public. This means that a\ndeveloper could modify the body of main() to change the value of mandrill.age to any \ninteger value, and option D is correct."
  },
  {
    "number": 109,
    "chapter": 3,
    "question": "How many of the String objects are eligible for garbage collection right before the end of \nthe main() method?\npublic static void main(String[] ohMy) {\n   String animal1 \u003d new String(\"lion\");\n   String animal2 \u003d new String(\"tiger\");\n   String animal3 \u003d new String(\"bear\");\n \n   animal3 \u003d animal1;\n   animal2 \u003d animal3;\n   animal1 \u003d animal2;\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "None of the above"
    ],
    "explanation": "All three references point to the String object \"lion\". This makes the other two\nString objects eligible for garbage collection and makes option C correct."
  },
  {
    "number": 110,
    "chapter": 3,
    "question": "Suppose Panther and Cub are interfaces and neither contains any default methods. \nWhich statements are true? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [],
    "options": [
      "If Panther has a single abstract method, Cub is guaranteed to be a functional interface.",
      "If Panther has a single abstract method, Cub may be a functional interface.",
      "If Panther has a single abstract method, Cub cannot be a functional interface.",
      "If Panther has two abstract methods, Cub is guaranteed to be a functional interface.",
      "If Panther has two abstract methods, Cub may be a functional interface.",
      "If Panther has two abstract methods, Cub cannot be a functional interface."
    ],
    "explanation": "A functional interface has exactly one abstract method. This includes inherited\nmethods. If Panther has a single abstract method, Cub is a functional interface if it \ndoes not add any more abstract methods. This matches option B . However, if Panther \nhas two abstract methods, there is no code in Cub that can make it a functional inter-\nface, and option F is the other answer."
  },
  {
    "number": 111,
    "chapter": 3,
    "question": "A local class can access which type of local variables? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [],
    "options": [
      "final",
      "private",
      "effectively final",
      "static",
      "default",
      "const"
    ],
    "explanation": "A local class can access final or effectively final local variables, making options A\nand C the correct answer. Local variables cannot be marked private or static, making \noptions B and D incorrect. Options E and F are also incorrect, as those are not valid vari-\nable modifiers."
  },
  {
    "number": 112,
    "chapter": 3,
    "question": "What does the following output?\n1:  public class InitOrder {\n2:     public String first \u003d \"instance\";\n3:     public InitOrder() {\n4:        first \u003d \"constructor\";\n5:     }\n6:     { first \u003d \"block\";  }\n7:     public void print() {\n8:        System.out.println(first);\n9:     }\n10:    public static void main(String... args) {\n11:       new InitOrder().print();       \n12:    }\n13: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "block",
      "constructor",
      "instance",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "When the main() method instantiates the object, line 2 first runs and sets the variable\nusing the declaration. Then the instance initializer on line 6 runs. Finally, the constructor \nruns. Since the constructor is the last to run of the three, that is the value that is set when \nwe print the result, so option B is correct."
  },
  {
    "number": 113,
    "chapter": 3,
    "question": "Which statement about the following interface is correct?\npublic interface Tree {\n   public static void produceSap() {\n      growLeaves();\n   }\n   public abstract int getNumberOfRings() {\n      return getNumberOfRings();\n   }\n   private static void growLeaves() {\n      produceSap();\n   }\n   public default int getHeight() {\n      return getHeight ();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "The code compiles.",
      "The method produceSap() does not compile.",
      "The method getNumberOfRings() does not compile.",
      "The method growLeaves() does not compile.",
      "The method getHeight() does not compile.",
      "The code does not compile because it contains a cycle."
    ],
    "explanation": "An abstract method cannot define a body, meaning the declaration of \ngetNumberOfRings() is invalid and option C is correct. The rest of the code compiles \nwithout issue. While the compiler will prevent cycles within overloaded constructors, it does \nnot do so for methods, meaning option F is incorrect."
  },
  {
    "number": 114,
    "chapter": 3,
    "question": "Which statements about a variable with a type of var are true? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [],
    "options": [
      "The variable can be assigned null at any point in the program.",
      "The variable can be assigned null only after initial initialization.",
      "The variable can never be assigned null.",
      "Only primitives can be used with the variable.",
      "Only objects can be used with the variable.",
      "Either a primitive or an object can be used with the variable."
    ],
    "explanation": "The type is determined based on the value at initialization. It cannot be null at that\npoint, but the variable can be assigned as null later, making option B correct. Both primi-\ntives and objects can be used with var, making option F correct."
  },
  {
    "number": 115,
    "chapter": 3,
    "question": "Assume there is a class Bouncer with a protected variable. Methods in which class can \naccess this variable?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "Any subclass of Bouncer or any class in the same package as Bouncer",
      "Any superclass of Bouncer",
      "Only subclasses of Bouncer",
      "Only classes in the same package as Bouncer",
      "None of the above"
    ],
    "explanation": "The protected modifier allows access by any subclass or class that is in the same\npackage; therefore, option A is the correct answer."
  },
  {
    "number": 116,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage forest;\npublic class Woods {\n   static class Tree {}\n   public static void main(String[] leaves) {\n      int heat \u003d 2;\n      int water \u003d 10-heat;\n      final class Oak extends Tree {  // p1\n         public int getWater() {\n            return water;             // p2\n         }\n      }\n      System.out.print(new Oak().getWater());\n      water \u003d 0;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "8",
      "Line p1 contains a compiler error.",
      "Line p2 contains a compiler error.",
      "Another line of code contains a compiler error.",
      "None of the above."
    ],
    "explanation": "The main() method defines a local class Oak that correctly extends Tree, a static\nnested class. The method getWater() is not permitted to read the local variable water, \nthough, since it is not final or effectively final, making option C correct. If the last line of \nthe method was removed, though, then the program would compile and print 8 ."
  },
  {
    "number": 117,
    "chapter": 3,
    "question": "Which can fill in the blank to make the code compile? (Choose two.)\ninterface Australian {}\ninterface Mammal {}\n________________ Australian, Mammal {}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [],
    "options": [
      "class Quokka extends",
      "class Quokka implements",
      "Neither A nor B. Only one interface can be specified.",
      "interface Quokka extends",
      "interface Quokka implements",
      "Neither D nor E. Only one interface can be specified."
    ],
    "explanation": "A class can implement multiple interfaces, making option B correct. An interface can\nextend multiple interfaces, making option D correct as well."
  },
  {
    "number": 118,
    "chapter": 3,
    "question": "What is true of the following method?\npublic void setColor(String color) {\n   color \u003d color;\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "It is a correctly implemented accessor method.",
      "It is a correctly implemented mutator method.",
      "It is an incorrectly implemented accessor method.",
      "It is an incorrectly implemented mutator method.",
      "None of the above."
    ],
    "explanation": "The method looks like a setter or mutator method. However, it is incorrectly imple\nmented since the method is missing a this reference and doesn’t actually change the value. \nTherefore, option D is correct."
  },
  {
    "number": 119,
    "chapter": 3,
    "question": "Which of the following statements about calling this() in a constructor are true? (Choose \nthree.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      5
    ],
    "userAnswers": [],
    "options": [
      "If arguments are provided to this(), then there must be a constructor in the class able\nto take those arguments.",
      "If arguments are provided to this(), then there must be a constructor in the super-class\n able to take those arguments.",
      "If the no-argument this() is called, then the class must explicitly implement the\n no-argument constructor.",
      "If super() and this() are both used in the same constructor, super() must appear\non the line immediately after this().",
      "If super() and this() are both used in the same constructor, this() must appear\non the line immediately after super().",
      "If this() is used, it must be the first line of the constructor."
    ],
    "explanation": "Option A is correct and option B is incorrect because this() calls another con\nstructor in the same class. Option C is correct because this() without parameters is the \ndefault constructor and is not inserted automatically by the compiler if another constructor \nis present. Options D and E are both incorrect because only one of super() or this() \ncan be used from the same constructor. Finally, option F is correct as super() or this() \nmust come first."
  },
  {
    "number": 120,
    "chapter": 3,
    "question": "What is the result of compiling and executing the following class?\npublic class RollerSkates {\n   static int wheels \u003d 1;\n   int tracks \u003d 5;\n   public static void main(String[] arguments) {\n      RollerSkates s \u003d new RollerSkates();\n      int feet\u003d4, tracks \u003d 15;\n      System.out.print(feet + tracks + s.wheels);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "The code does not compile.",
      "4",
      "5",
      "10",
      "20"
    ],
    "explanation": "The code compiles and runs without issue, so option A is incorrect. The question\ninvolves understanding the value and scope of each variable at the print() statement. \nThe variables feet and tracks are locally scoped and set to 4 and 15, respectively, \nignoring the value of tracks of 5 in the instance of the class. Finally, the static variable \ns.wheels has a value of 1 .  The result is that the combined value is 20, making option E \nthe correct answer."
  },
  {
    "number": 121,
    "chapter": 3,
    "question": "Which statements about the following program are correct? (Choose two.)\npackage vessel;\n \nclass Problem extends Exception {}\nabstract class Danger {\n   protected abstract void isDanger() throws Problem; // m1\n}\npublic class SeriousDanger extends Danger { // m2\n   protected void isDanger() throws Exception { // m3\n      throw new RuntimeException(); // m4\n   }\n   public static void main(String[] w) throws Throwable { // m5\n      var sd \u003d new SeriousDanger().isDanger(); // m6\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [],
    "options": [
      "The code does not compile because of line m1.",
      "The code does not compile because of line m2.",
      "The code does not compile because of line m3.",
      "The code does not compile because of line m4.",
      "The code does not compile because of line m5.",
      "The code does not compile because of line m6."
    ],
    "explanation": "Line m3 does not compile because isDanger() is an invalid method override. An\noverridden method may not throw a broader checked exception than it inherits. Since \nException is a superclass of Problem, the code does not compile, and option C is \ncorrect. Line m6 does not compile because the return type of isDanger() is void, which \ncannot be assigned to a variable, making option F also correct."
  },
  {
    "number": 122,
    "chapter": 3,
    "question": "Which statements about top-level and member inner classes are correct? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4,
      5
    ],
    "userAnswers": [],
    "options": [
      "Both can be marked protected.",
      "Only top-level classes can be declared final.",
      "Both can declare constructors.",
      "Member inner classes cannot be marked private.",
      "Member inner classes can access private variables of the top-level class in which it is defined.",
      "Both can be marked abstract."
    ],
    "explanation": "Top-level classes can be set only with public and package-private access, making\noption A incorrect. On the other hand, member inner classes can be set with any of the four \naccess levels, making option D incorrect. Both types of classes can be declared with final \nor abstract modifier, making option B incorrect and option F correct. Both can also \ninclude constructors, making option C correct. Finally, option E is correct and one of the \nprimary features of inner classes."
  },
  {
    "number": 123,
    "chapter": 3,
    "question": "What is required to define a valid Java class file?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "A class declaration",
      "A package statement",
      "An import statement",
      "A class declaration and package statement",
      "A class declaration and at least one import statement",
      "The public modifier"
    ],
    "explanation": "Option A is the only correct answer as a class declaration is the only required com\nponent in a Java class file. Note that we said a Java class file here; Java also allows inter-\nfaces, annotations, modules, and enums to be defined in a file. A class file may have a single \npackage statement or any number of import statements. Neither is required."
  },
  {
    "number": 124,
    "chapter": 3,
    "question": "How many objects are eligible for garbage collection right before the end of the main() \nmethod?\n1:  public class Person {\n2:     public Person youngestChild;\n3: \n4:     public static void main(String... args) {\n5:        Person elena \u003d new Person();\n6:        Person janeice \u003d new Person();\n7:        elena.youngestChild \u003d janeice;\n8:        janeice \u003d null;\n9:        Person zoe \u003d new Person();\n10:       elena.youngestChild \u003d zoe;\n11:       zoe \u003d null;\n12:    } }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "None.",
      "One.",
      "Two.",
      "Three.",
      "The code does not compile."
    ],
    "explanation": "On line 9, all three objects have references. The elena and zoe objects have a direct\nreference. The janeice object is referenced through the elena object. On line 10, the ref-\nerence to the janeice object is replaced by a reference to the zoe object. Therefore, the \njaneice object is eligible to be garbage collected, and option B is correct."
  },
  {
    "number": 125,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage race; \ninterface Drive {\n   int SPEED \u003d 5;\n   default int getSpeed() { return SPEED; }\n}\ninterface Hover {\n   int MAX_SPEED \u003d 10;\n   default int getSpeed() { return MAX_SPEED; }\n}\npublic class Car implements Drive, Hover {\n   public static void main(String[] gears) {\n      class RaceCar extends Car {\n         @Override public int getSpeed() { return 15; }\n      };\n      System.out.print(new RaceCar().getSpeed());\n   } }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "5",
      "10",
      "15",
      "The code does not compile.",
      "The answer cannot be determined with the information given."
    ],
    "explanation": "Both the Drive and Hover interfaces define a default method getSpeed() with\nthe same signature. The class Car implements both interfaces, which means it inherits \nboth default methods. Since the compiler does not know which one to choose, the Car \nclass must override the default method. Since it does not, the code does not compile, \nand option D is correct. Note that the RaceCar class does properly override the default \nmethod, the problem is with the Car class."
  },
  {
    "number": 126,
    "chapter": 3,
    "question": "What is the output of the following application? (Choose two.)\n1:  public class ChooseWisely {\n2:     public ChooseWisely() { super(); }\n3:     public int choose(int choice) { return 5; }\n4:     public int choose(short choice) { return 2; }\n5:     public int choose(long choice) { return 11; }\n6:     public int choose(double choice) { return 6; }\n7:     public int choose(Float choice) { return 8; }\n8:     public static void main(String[] path) {\n9:        ChooseWisely c \u003d new ChooseWisely();\n10:       System.out.println(c.choose(2f));\n11:       System.out.println(c.choose((byte)2+1));\n12:    }\n13: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [],
    "options": [
      "2",
      "3",
      "5",
      "6",
      "8"
    ],
    "explanation": "On line 10, we are passing a float. Since there is no exact match, Java attempts\npromotion of the primitive type to double, before trying to wrap it as a Float, mak-\ning option D correct. On line 11, the value 2 is first cast to a byte. It is then increased \nby one using the addition + operator. The addition + operator automatically promotes all \nbyte and short values to int. Therefore, the value passed to choose() in the main() \nmethod is an int. The choose(int) method is called, returning 5 and making option \nC the correct answer. Note that without the addition operation in the main() method, \nbyte would have been used as the parameter to the choose() method, causing the \nchoose(short) to be selected as the next closest type and outputting 2, making option A \nthe correct answer."
  },
  {
    "number": 127,
    "chapter": 3,
    "question": "Fill in the blanks: It is possible to extend a(n) ______________ but not a(n) ______________. \n(Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [],
    "options": [
      "interface, abstract class",
      "anonymous class, static nested class",
      "abstract class, enum",
      "enum, interface",
      "abstract class, interface",
      "local class, anonymous class"
    ],
    "explanation": "An interface can be extended by another interface and a class can be extended by\nanother class. This makes the second part of options A, D, and E incorrect. Among nested \nclasses, all types can be extended except an anonymous class since it does not declare a class \nname, making option F correct and both parts of option B incorrect. Option C is correct \nbecause an enum cannot be extended."
  },
  {
    "number": 128,
    "chapter": 3,
    "question": "How many lines of the following program do not compile?\n1: public enum Color {\n2:    RED(1,2) { void toSpectrum() {} },\n3:    BLUE(2) { void toSpectrum() {} void printColor() {} },\n4:    ORANGE() { void toSpectrum() {} },\n5:    GREEN(4);\n6:    public Color(int... color) {}\n7:    abstract void toSpectrum();\n8:    final void printColor() {}\n9: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "More than three"
    ],
    "explanation": "Line 3 does not compile because printColor() is marked final and cannot be over\nridden. Line 5 does not compile because the method toSpectrum() is marked abstract \nand must be overridden by each enum value. Finally, line 6 does not compile because enum \nconstructors are implicitly private. For these three reasons, option D is correct."
  },
  {
    "number": 129,
    "chapter": 3,
    "question": "What is the output of the Square program?\npackage shapes;\n \nabstract class Trapezoid {\n   private int getEqualSides() {return 0;}\n}\nabstract class Rectangle extends Trapezoid {\n   public static int getEqualSides() {return 2;}  // x1\n}\npublic final class Square extends Rectangle {\n   public int getEqualSides() {return 4;}         // x2\n   public static void main(String[] corners) {\n      final Square myFigure \u003d new Square();       // x3\n      System.out.print(myFigure.getEqualSides());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "0",
      "2",
      "4",
      "The code does not compile due to line x1.",
      "The code does not compile due to line x2.",
      "The code does not compile due to line x3."
    ],
    "explanation": "The override of getEqualSides() in Square is invalid. A static method cannot\noverride a non-static method and vice versa. For this reason, option E is the correct \nanswer. The rest of the lines compile without issue. If the static modifier were added to \nthe method declaration on line x2, then the code would print 4 at runtime."
  },
  {
    "number": 130,
    "chapter": 3,
    "question": "What can fill in the blank so the play() method can be called from all classes in the com.\nmammal package, but not the com.mammal.gopher package?\npackage com.mammal;\n \npublic class Enrichment {\n    void play() {}\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "Leave it blank.",
      "private",
      "protected",
      "public",
      "None of the above."
    ],
    "explanation": "Since only one package needs access and it is the same package the class is in, option A\nis correct."
  },
  {
    "number": 131,
    "chapter": 3,
    "question": "How many cells in the following table are incorrect?",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "A concrete class is not allowed to have abstract methods, but the other two types are.\nThis makes the second row in the first column incorrect. All three types are allowed to have \nstatic final constants, making the whole second column correct. In the last column,\nthere are two errors. An abstract class can have a constructor, but an interface cannot. \nNote that an abstract class cannot be instantiated. Instead, it requires a subclass. This \ngives us a total of three incorrect cells, making option D the answer."
  },
  {
    "number": 132,
    "chapter": 3,
    "question": "Which statements are true about a functional interface? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "It may contain any number of abstract methods.",
      "It must contain a single abstract method.",
      "It may contain any number of private methods.",
      "It must contain a single private method.",
      "It may contain any number of static methods.",
      "It must contain a single static method."
    ],
    "explanation": "A functional interface must have exactly one abstract method, which is option B\nThere are no restrictions on the number of private or static methods, which make options C\nand E also correct."
  },
  {
    "number": 133,
    "chapter": 3,
    "question": "Which variables have a scope limited to a method?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Interface variables",
      "Class variables",
      "Instance variables",
      "Local variables"
    ],
    "explanation": "Only local variables have such a small scope, making option D the correct answer"
  },
  {
    "number": 134,
    "chapter": 3,
    "question": "What is a possible output of the following application?\npackage wrap;\npublic class Gift {\n   private final Object contents;\n   protected Object getContents() {\n      return contents;\n   }\n   protected void setContents(Object contents) {\n      this.contents \u003d contents;\n   }\n   public void showPresent() {\n      System.out.print(\"Your gift: \"+contents);\n   }\n   public static void main(String[] treats) {\n      Gift gift \u003d new Gift();\n      gift.setContents(gift);\n      gift.showPresent();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Your gift: wrap.Gift@29ca2745",
      "Your gift: Your gift:",
      "It does not compile.",
      "It compiles but throws an exception at runtime."
    ],
    "explanation": "The code contains a compilation error in regard to the contents instance variable. The\ncontents instance variable is marked final, but there is a setContents() instance \nmethod that can change the value of the variable. Since these two are incompatible, the code \ndoes not compile, and option C is correct. If the final modifier were removed from the \ncontents variable declaration, then the expected output would be of the form shown in \noption A ."
  },
  {
    "number": 135,
    "chapter": 3,
    "question": "Which of the following are the best reasons for creating a default interface method? \n(Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [],
    "options": [
      "Allow interface methods to be overloaded.",
      "Add backward compatibility to existing interfaces.",
      "Give an interface the ability to create final methods.",
      "Allow an interface to define a method at the class level.",
      "Improve code reuse among classes that implement the interface.",
      "Improve encapsulation of the interface."
    ],
    "explanation": "One of the motivations for adding default interface methods to Java was for\nbackward compatibility. These methods allow developers to update older classes with a \nnewer version of an interface without breaking functionality in the existing classes, making \noption B correct. Option E is also correct, as classes implementing the interface can share \ncommon methods. Option A is incorrect, as interface methods can already be overloaded. \nOption C is incorrect because methods in interfaces cannot be marked final. Option D \nsounds plausible, but could be accomplished with static interface methods alone. Option \nF is incorrect as that statement only applies to private interface methods."
  },
  {
    "number": 136,
    "chapter": 3,
    "question": "How many compiler errors does the following code contain?\npackage animal;\ninterface CanFly {\n   public void fly() {}\n}\nfinal class Bird {\n   public int fly(int speed) {}\n}\npublic class Eagle extends Bird implements CanFly {\n   public void fly() {}\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "The method fly() defined in CanFly defines an implementation, an empty {},\nmeaning it cannot be assumed to be abstract; therefore, the code does not compile.\nNext, the implementation of fly(int speed) in the Bird class also does not compile, \nbut not because of the signature. The method body fails to return an int value.\nFinally, the Eagle class does not compile because it extends the Bird class, which is marked \nfinal and, therefore, cannot be extended. For these three reasons, option D is the correct \nanswer."
  },
  {
    "number": 137,
    "chapter": 3,
    "question": "Which of the following statements is not true?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "An instance of one class may access an instance of another class’s attributes if it has a\nreference to the instance and the attributes are declared public.",
      "An instance of one class may access package-private attributes in a parent class,\nprovided the parent class is not in the same package.",
      "An instance of one class may access an instance of another class’s attributes if both\nclasses are located in the same package and marked protected.",
      "Two instances of the same class may access each other’s private attributes.",
      "All of the above are true."
    ],
    "explanation": "Options A, C, and D are true statements. Option A is correct because public allows any\nclass to access it. Option C is true because protected access also provides package-private \naccess. Option D allows us to write the equals() methods between two objects that com-\npare private attributes of the class. Option B is false. Package-private attributes are visible \nonly if the two classes are in the same package, regardless of whether one extends the other."
  },
  {
    "number": 138,
    "chapter": 3,
    "question": "What is the output of the following code?\npublic class Bunny {\n   static class Rabbit {\n      void hop() {\n         System.out.print(\"hop\");\n      }\n   }\n   static class FlemishRabbit extends Rabbit {\n      void hop() {\n         System.out.print(\"HOP\");\n      }\n    }\n    public static void main(String[] args) {\n       Rabbit r1 \u003d new FlemishRabbit();\n       FlemishRabbit r2 \u003d new FlemishRabbit();\n       r1.hop();\n       r2.hop();\n    }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "hophop",
      "HOPhop",
      "hopHOP",
      "HOPHOP",
      "The code does not compile."
    ],
    "explanation": "This example deals with polymorphism since the methods are being called on the object\ninstance. Since both objects are of type FlemishRabbit, HOP is printed twice, and option \nD is the correct answer."
  },
  {
    "number": 139,
    "chapter": 3,
    "question": "Which of the following are valid class declarations? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      4
    ],
    "userAnswers": [],
    "options": [
      "class _ {}",
      "class river {}",
      "class Str3@m {}",
      "class Pond2$ {}",
      "class _var_ {}",
      "class 5Ocean {}"
    ],
    "explanation": "Class names follow the same requirements as other identifiers. Underscores (_) and\ndollar signs ($) are allowed, but no other symbols are allowed, making option C incorrect. \nSince Java 9, a single underscore is not permitted as an identifier, making option A incorrect. \nNumbers are allowed, but not as the first character. Therefore, option F is incorrect. The rest \nof the options are valid class names, making the answer options B, D, and E correct. Note \nthat class names begin with an uppercase letter by convention, but this is not a requirement."
  },
  {
    "number": 140,
    "chapter": 3,
    "question": "What is the output of the InfiniteMath program?\nclass Math {\n   public final double secret \u003d 2;\n}\nclass ComplexMath extends Math {\n   public final double secret \u003d 4;\n}\npublic class InfiniteMath extends ComplexMath {\n   public final double secret \u003d 8;\n   public static void main(String[] numbers) {\n      Math math \u003d new InfiniteMath();\n      System.out.print(math.secret);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "2.0",
      "4.0",
      "8.0",
      "The code does not compile.",
      "The code compiles but prints an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The code compiles without issue. Java allows methods to be overridden, but not vari\nables. Therefore, marking them final does not prevent them from being reimplemented in \na subclass. Furthermore, polymorphism does not apply in the same way it would to methods \nas it does to variables. In particular, the reference type determines the version of the secret \nvariable that is selected, making the output  2 .0 and option A the correct answer. "
  },
  {
    "number": 141,
    "chapter": 3,
    "question": "Given the following application, which diagram best represents the state of the mySkier, \nmySpeed, and myName variables in the main() method after the call to the slalom() \nmethod?\npackage slopes;\npublic class Ski {\n   private int age \u003d 18;\n   private static void slalom(Ski racer,\n      int[] speed, String name) {\n \n      racer.age \u003d 18;\n      name \u003d \"Wendy\";\n      speed \u003d new int[1];\n      speed[0] \u003d 11;\n      racer \u003d null;\n   }\n   \n   public static void main(String... mountain) {\n      final var mySkier \u003d new Ski();\n      mySkier.age \u003d 16;\n      final int[] mySpeed \u003d new int[1];\n      final String myName \u003d \"Rosie\";\n      slalom(mySkier,mySpeed,myName);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": true,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "",
      "",
      "",
      ""
    ],
    "explanation": "To solve this problem, it helps to remember that Java is a pass-by-value language in which\ncopies of primitives and object references are sent to methods. This also means that an object’s \ndata can be modified within a method and shared with the caller, but not the reference to \nthe object. Any changes to the object’s reference within the method are not carried over to \nthe caller. In the slalom() method, the Ski object is updated with an age value of 18. \nAlthough the last line of the slalom() method changes the variable value to null, it does \nnot affect the mySkier object or reference in the main() method. Therefore, the mySkier \nobject is not null, and the age variable is set to 18, making options A and D incorrect.\nNext, the name variable is reassigned to the Wendy object, but this does not change the \nreference in the main() method, so myName remains Rosie. Finally, the speed array is \nassigned a new object and updated. Since the array is updated after the reference is reas-\nsigned, it does not affect the mySpeed array in the main() method. The result is that \nmySpeed continues to have a single element with the default int value of 0 .  For these  \nreasons, option B is incorrect, and option C is correct."
  },
  {
    "number": 142,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage zoo;\npublic class Penguin {\n   private int volume \u003d 1;\n   private class Chick {\n      private static int volume \u003d 3;\n      void chick() {\n         System.out.print(\"Honk(\"+Penguin.this.volume+\")!\");\n      }\n   }\n   public static void main(String... eggs) {\n      Penguin pen \u003d new Penguin();\n      final Penguin.Chick littleOne \u003d pen.new Chick();\n      littleOne.chick();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Honk(1)!",
      "Honk(3)!",
      "The code does not compile.",
      "The code compiles, but the output cannot be determined until runtime.",
      "None of the above."
    ],
    "explanation": "The Penguin class includes a member inner class Chick. Member inner classes can\nonly include static variables if they are marked final. Since the variable volume is not \nmarked final, the Chick does not compile, making option C correct. Note that the vari-\nable volume referenced in the chick() method is one defined in the Penguin outer class. \nIf the final modifier was added to the volume variable in the Chick class, then the rest \nof the code would compile, printing Honk(1)! at runtime."
  },
  {
    "number": 143,
    "chapter": 3,
    "question": "Which can implement a functional interface?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "An anonymous class",
      "A top-level class",
      "A lambda expression",
      "An anonymous class or a top-level class",
      "A top-level class or a lambda expression",
      "An anonymous class, a top-level class, or a lambda expression"
    ],
    "explanation": "An anonymous class can implement a single interface, and a top-level class can implement\nany number of interfaces. Since a functional interface is an interface with additional rules, \nboth anonymous class and top-level class are correct. Additionally, a lambda expression can \nalso implement a functional interface. Since all three are correct, the answer is option F ."
  },
  {
    "number": 144,
    "chapter": 3,
    "question": "Fill in the blank with the line of code that allows the program to compile and print E at \nruntime.\ninterface Fruit {\n   public default char getColor() { return \u0027F\u0027; }\n}\ninterface Edible  {\n   public default char getColor() { return \u0027E\u0027; } \n}\npublic class Banana implements Fruit, Edible {\n   public char getColor() { return _______________; }\n   public static void main(String[] a) {\n      var d \u003d new Banana();\n      System.out.println(d.getColor());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "Edible.getColor()",
      "Edible.super.getColor()",
      "super.Edible.getColor()",
      "super.getColor()",
      "The code does not compile regardless of what is inserted into the blank.",
      "None of the above."
    ],
    "explanation": "The code compiles, even if the blank is replaced with a constant char value, making\noption E incorrect. Note that the class correctly overrides both inherited default methods. \nIt is possible to access a default method, even if it is overridden in the class, but requires \nusing the super keyword properly. Option B demonstrates the correct syntax. Note that \noption D would not be correct even if there was only one inherited default method."
  },
  {
    "number": 145,
    "chapter": 3,
    "question": "Given the following two classes, each in a different package, which line inserted into the \ncode allows the second class to compile?\npackage clothes;\npublic class Store {\n   public static String getClothes() { return \"dress\"; }\n}\n \npackage wardrobe;\n// INSERT CODE HERE\npublic class Closet {\n   public void borrow() {\n      System.out.print(\"Borrowing clothes: \"+getClothes());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "static import clothes.Store.getClothes;",
      "import clothes.Store.*;",
      "import static clothes.Store.getClothes;",
      "import static clothes.Store;"
    ],
    "explanation": "Option A is incorrect because the keywords static and import are reversed. The\nCloset class uses the method getClothes() without a reference to the class name \nStore; therefore, a static import is required. For this reason, option B is incorrect since \nit is missing the static keyword. Option D is also incorrect since static imports are \nused with members of the class, not a class name. Finally, option C is the correct answer \nsince it properly imports the method into the class using a static import."
  },
  {
    "number": 146,
    "chapter": 3,
    "question": "What is the output of the ElectricCar program?\npackage vehicles;\nclass Automobile {\n   private final String drive() { return \"Driving vehicle\"; }\n}\nclass Car extends Automobile {\n   protected String drive() { return \"Driving car\"; }\n}\npublic class ElectricCar extends Car {\n   public final String drive() { return \"Driving electric car\"; }\n   public static void main(String[] wheels) {\n      final Automobile car \u003d new ElectricCar();\n      var v \u003d (Car)car;\n      System.out.print(v.drive());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "Driving vehicle",
      "Driving electric car",
      "Driving car",
      "The code does not compile.",
      "The code compiles but produces a ClassCastException at runtime.",
      "None of the above."
    ],
    "explanation": "The drive() method in the Car class does not override the private version in the\nAutomobile class since the method is not visible to the Car class. Therefore, the final \nattribute in the Automobile class does not prevent the Car class from implementing a \nmethod with the same signature. The drive() method in the ElectricCar class is a valid \noverride of the method in the Car class, with the public access modifier expanding access\nin the subclass. In the main() method, the object created is an ElectricCar, even if it is \nassigned to a Car or Automobile reference. Due to polymorphism, the method from the \nElectricCar will be invoked, making option B the correct answer."
  },
  {
    "number": 147,
    "chapter": 3,
    "question": "What is the output of the following program?\npublic class Music {\n   { System.out.print(\"do-\"); }\n   static { System.out.print(\"re-\"); }\n   { System.out.print(\"mi-\"); }\n   static { System.out.print(\"fa-\"); }\n   \n   public Music() {\n      System.out.print(\"so-\");\n   }\n   \n   public Music(int note) {\n      System.out.print(\"la-\");\n   }\n   public static void main(String[] sound) {\n      System.out.print(\"ti-\");\n      var play \u003d new Music();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "re-fa-ti-do-mi-so-",
      "do-re-mi-fa-ti-so-",
      "ti-re-fa-do-mi-so-",
      "re-fa-la-mi-ti-do-",
      "do-re-mi-fa-so-ti",
      "The code does not compile."
    ],
    "explanation": "The code compiles, so option F is incorrect. The Music class is loaded, and the static\ninitializers are executed in order, with re-fa- being printed first. Next, the first line of the \nmain() method is executed, printing ti-. The second line of the main() method creates a \nMusic object, with the instance initializers being called first, printing do-mi-. Finally, the \nno-argument constructor is executed, and so- is printed last."
  },
  {
    "number": 148,
    "chapter": 3,
    "question": "Given the following class declaration, which options correctly declare a local variable con-\ntaining an instance of the class?\npublic class Earth {\n   private abstract class Sky {\n      void fall() {\n         var e \u003d _______________\n      }\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "new Sunset() extends Sky {};",
      "new Sky();",
      "new Sky() {}",
      "new Sky() { final static int blue \u003d 1; };",
      "The code does not compile regardless of what is placed in the blank.",
      "None of the above."
    ],
    "explanation": "All of the options attempt to create an instance using an anonymous class that extends\nSky. Option A is incorrect because when you create an anonymous class, you do not specify \na name. Even if there was a Sunset class, the declaration of an anonymous class can only \nextend or implement one type directly. Since it would already extend Sunset, it cannot \nspecify Sky at the same time. Option B is incorrect because Sky is abstract and cannot \nbe instantiated directly. Option C is incorrect because it is missing a semicolon (;) at the \nend. Option D is the correct answer. Remember that all nested classes can have static \nvariables if they are marked final."
  },
  {
    "number": 149,
    "chapter": 3,
    "question": "What is the output of the Encyclopedia program?\npackage paper;\nabstract class Book {\n   protected static String material \u003d \"papyrus\";\n   public Book() {}\n   abstract String read() {}\n   public Book(String material) {this.material \u003d material;}\n} \npublic class Encyclopedia extends Book {\n   public static String material \u003d \"cellulose\";\n   public Encyclopedia() {super();}\n   public String read() { return \"Reading is fun!\"; }\n   public String getMaterial() {return super.material;}\n \n   public static void main(String[] pages) {\n      System.out.print(new Encyclopedia().read());\n      System.out.print(\"-\" + new Encyclopedia().getMaterial());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "Reading is fun!-papyrus",
      "Reading is fun!-cellulose",
      "null-papyrus",
      "null-cellulose",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The code may look complicated, but it does not compile for a simple reason. The\nabstract read() method defined in Book cannot have a method body. Since it does, the \ncode does not compile, and option E is correct."
  },
  {
    "number": 150,
    "chapter": 3,
    "question": "What does the following print?\ninterface Vehicle {}\nclass Bus implements Vehicle {}\n \npublic class Transport { \n   public static void main(String[] args) {\n      Bus bus \u003d new Bus();\n      boolean n \u003d null instanceof Bus;\n      boolean v \u003d bus instanceof Vehicle;\n      boolean b \u003d bus instanceof Bus;\n      System.out.println(n + \" \" + v + \" \" + b);\n  }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "false false false",
      "false false true",
      "false true true",
      "true false true",
      "true true false",
      "true true true"
    ],
    "explanation": "While using null with instanceof compiles, it always returns false. The other two\ninstanceof calls show that instanceof can be used with both classes and interfaces. \nThey both return true since Bus implements Vehicle, making option C correct."
  },
  {
    "number": 151,
    "chapter": 3,
    "question": "How many rows of the following table contain an error?\n",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "The first row is incorrect as the private modifier is required for private interface\nmethods. The second row is correct. The third row is also incorrect because the static \nmodifier is required, not optional, for static interface methods. The public modifier is \noptional, though, as the static method is implicitly public without it. The last row is \nincorrect as the abstract modifier can be implied if the method does not declare a body. \nSince three rows contain an error, option D is correct."
  },
  {
    "number": 152,
    "chapter": 3,
    "question": "What is the output of the following program?\npublic class Dwarf {\n   private final String name;\n   \n   public Dwarf() {\n      this(\"Bashful\");\n   }\n   \n   public Dwarf(String name) {\n      name \u003d \"Sleepy\";\n   }\n   \n   public static void main(String[] sound) {\n      var d \u003d new Dwarf(\"Doc\");\n      System.out.println(d.name);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Sleepy",
      "Bashful",
      "Doc",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "A final instance variable must be assigned a value when it is declared, in an instance\ninitializer, or by a constructor. The Dwarf(String) constructor does not assign a value \nsince it contains a local variable called name already. For this reason, this constructor does \nnot compile, and option D is correct. If the assignment in the constructor was changed to \nthis.name, then the program would compile and print Sleepy."
  },
  {
    "number": 153,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage pocketmath;\ninterface AddNumbers {\n   int add(int x, int y);\n   static int subtract(int x, int y) { return x-y; }\n   default int multiply(int x, int y) { return x*y; }\n}\npublic class Calculator {\n   protected void calculate(AddNumbers n, int a, int b) {\n      System.out.print(n.add(a, b));\n   }\n   public static void main(String[] moreNumbers) {\n      final var ti \u003d new Calculator() {};\n      ti.calculate((k,p) -\u003e p+k+1, 2, 5);  // j1\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "8",
      "The code does not compile because AddNumbers is not a functional interface.",
      "The code does not compile because of line j1.",
      "The code does not compile for a different reason.",
      "None of the above."
    ],
    "explanation": "The AddNumbers interface is a valid functional interface. While it includes both\nstatic and default methods, it includes only one abstract method, the precise \nrequirement for it to be considered a functional interface, making option B incorrect. The \nclass compiles and prints 8 at runtime, making option A correct."
  },
  {
    "number": 154,
    "chapter": 3,
    "question": "Which of the following variables are always in scope for the entire program once defined?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "Package variables",
      "Class variables",
      "Instance variables",
      "Local variables"
    ],
    "explanation": "There is no such thing as package variables, so option A is incorrect. Option C is incor\nrect as the variable is only in scope within a specific instance of the class. Option D is also \nincorrect as the variable is only in scope for a single method that it is defined in. Option B is \nthe only correct answer as class variables are in scope within the program."
  },
  {
    "number": 155,
    "chapter": 3,
    "question": "What is the command to call one constructor from another constructor in the same class?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "construct()",
      "parent()",
      "super()",
      "this()",
      "that()"
    ],
    "explanation": "The super() statement is used to call a constructor in a parent class, while the this()\nstatement is used to call a constructor in the same class, making option D correct and \noption C incorrect. Options A, B, and E are incorrect because they are not built-in function-\nality in Java."
  },
  {
    "number": 156,
    "chapter": 3,
    "question": "Which of the following statements about no-argument constructors and inheritance are \ncorrect? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [],
    "options": [
      "The compiler cannot insert a no-argument constructor into an abstract class.",
      "If a parent class does not include a no-argument constructor, a child class cannot declare one.",
      "If a parent class declares constructors but each of them take at least one parameter,\nthen a child class must declare at least one constructor.",
      "The no-argument constructor is sometimes inserted by the compiler.",
      "If a parent class declares a no-argument constructor, a child class must declare a no-argument constructor",
      "If a parent class declares a no-argument constructor, a child class must declare at least one constructor."
    ],
    "explanation": "The default no-argument instructor is inserted by the compiler whenever a class,\nabstract or concrete, does not declare any constructors. For this reason, option A is incor-\nrect, and option D is correct. Even if a parent class does not declare a no-argument con-\nstructor, the child class can still declare one, making option B incorrect. If the parent class \ndoes not declare a no-argument constructor (and none is inserted by the compiler), then the \nchild class must declare at least one constructor, making option C correct. Without a con-\nstructor call, inserting the default no-argument constructor into the child class would lead \nto a compiler error on the implicit super() call. Finally, options E and F are incorrect, as a \nchild class of a parent with a no-argument constructor is free to declare or not declare any \nconstructors."
  },
  {
    "number": 157,
    "chapter": 3,
    "question": "Fill in the blanks: ______________ allow Java to support multiple inheritance, and  \nanonymous classes can ______________ of them.",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Abstract classes, extend at most one",
      "Abstract classes, extend any number",
      "Interfaces, implement at most one",
      "Interfaces, implement any number",
      "Concrete classes, extend at most one",
      "None of the above"
    ],
    "explanation": "Interfaces allow Java to support multiple inheritance because a class may implement any\nnumber of interfaces. On the other hand, an anonymous class may implement or extend at \nmost one interface or class, respectively, since it does not have a class definition. For these \nreasons, option C is the correct answer."
  },
  {
    "number": 158,
    "chapter": 3,
    "question": "What is the result of executing the Grasshopper program?\n// Hopper.java\npackage com.animals;\n \npublic class Hopper {\n   protected void hop() {\n      System.out.println(\"hop\");\n   }\n}\n \n// Grasshopper.java\npackage com.insect;\nimport com.animals.Hopper;\n \npublic class Grasshopper extends Hopper {\n   public void move() {\n      hop();  // p1\n   }\n   public static void main(String[] args) {\n      var hopper \u003d new Grasshopper();\n      hopper.move();  // p2\n      hopper.hop();   // p3\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "The code prints hop once.",
      "The code prints hop twice.",
      "The first compiler error is on line p1.",
      "The first compiler error is on line p2.",
      "The first compiler error is on line p3."
    ],
    "explanation": "The hop() method has protected access, which allows subclasses to call it. Both the\nmove() method and main() method are allowed to call hop() since Grasshopper is a \nsubclass. The code runs without error and prints hop twice, making option B the answer."
  },
  {
    "number": 159,
    "chapter": 3,
    "question": "What is the minimum number of lines that need to be removed to make this code compile?\n@FunctionalInterface\npublic interface Play {\n   public static void baseball() {}\n   private static void soccer() {}\n   default void play() {}\n   void fun();\n   void game();\n   void toy();\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "1",
      "2",
      "3",
      "4",
      "The code compiles as is."
    ],
    "explanation": "This code is not a functional interface because it has three abstract methods: fun(),\ngame(), and toy(). Removing two of these three methods would cause the code to com-\npile. However, there is no requirement that the code be a functional interface. Since it only \nneeds to compile, removing the @FunctionalInterface annotation would also cause \nthe code to compile. Option A is correct since only the annotation needs to be removed."
  },
  {
    "number": 160,
    "chapter": 3,
    "question": "Which of the following are the best reasons for creating a private interface method? \n(Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "Add backward compatibility to existing interfaces.",
      "Provide an implementation that a class implementing the interface can override.",
      "Increase code reuse within the interface.",
      "Allow interface methods to be inherited.",
      "Improve encapsulation of the interface.",
      "Allow static methods to access instance methods."
    ],
    "explanation": "Options A and B are incorrect and describe properties of default interface methods.\nOption C is correct and one of the primary reasons to add a private interface method. \nOption D is not a property of private interface methods. Option E is also correct, as \nprivate interface methods are not exposed to classes implementing the interface. Option F \nis a nonsensical statement."
  },
  {
    "number": 161,
    "chapter": 3,
    "question": "What is the result of executing the Sounds program?\n// Sheep.java\npackage com.mammal;\n \npublic class Sheep {\n   private void baa() {\n      System.out.println(\"baa!\");\n   }\n   private void speak() {\n      baa();\n   }\n}\n \n// Sounds.java\npackage com.animals;\nimport com.mammal.Sheep;\n \npublic class Sounds {\n   public static void main(String[] args) {\n      var sheep \u003d new Sheep();\n      sheep.speak();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "The code runs and prints baa!.",
      "The Sheep class does not compile.",
      "The Sounds class does not compile.",
      "Neither class compiles."
    ],
    "explanation": "The speak() method has private access, which does not allow code outside the class\nto call it. Therefore, option C is the answer."
  },
  {
    "number": 162,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage stocks;\npublic class Bond {\n   private static int price \u003d 5;\n   public boolean sell() {\n      if(price\u003c10) {\n         price++;\n         return true;\n      } else if(price\u003e\u003d10) {\n         return false;\n      }\n   }\n   public static void main(String[] cash) {\n      new Bond().sell();\n      new Bond().sell();\n      new Bond().sell();\n      System.out.print(price);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "5",
      "6",
      "8",
      "The code does not compile."
    ],
    "explanation": "The sell() method does not compile because it does not return a value if both of the\nif-then statements’ conditional expressions evaluate to false. While logically it is true that \nprice is either less than 10 or greater than or equal to 10, the compiler does not know \nthat. It just knows that if both if-then statements evaluate to false, then it does not have a \nreturn value; therefore, it does not compile."
  },
  {
    "number": 163,
    "chapter": 3,
    "question": "Given the following class declaration, what expression can be used to fill in the blank so \nthat 88 is printed at runtime?\nfinal public class Racecar {\n   final private int speed \u003d 88;\n   final protected class Engine {\n      private final int speed \u003d 100;\n      public final int getSpeed() {\n         return _____________________;\n      }\n   }\n   final Engine engine \u003d new Engine();\n   final public static void main(String[] feed) {\n      System.out.print(new Racecar().engine.getSpeed());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "Racecar.speed",
      "this.speed",
      "this.Racecar.speed",
      "Racecar.Engine.this.speed",
      "Racecar.this.speed",
      "The code does not compile regardless of what is placed in the blank."
    ],
    "explanation": "Options A and C do not compile, as they are invalid ways of accessing a member vari\nable. Options B and D both compile but print 100 at runtime, since they reference the speed \nvariable defined in the Engine class. Option E is the correct answer, accessing the speed \nvariable in the Racecar class and printing 88 at runtime."
  },
  {
    "number": 164,
    "chapter": 3,
    "question": "Which statements about static initializers are correct? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      5
    ],
    "userAnswers": [],
    "options": [
      "They cannot be used to create instances of the class they are contained in.",
      "They can assign a value to a static final variable.",
      "They are executed at most once per program.",
      "They are executed each time an instance of the class is created from a local cache of objects.",
      "They are executed each time an instance of the class is created using the new keyword.",
      "They may never be executed."
    ],
    "explanation": "A static initializer can create instances of any class it has access to, so option A is\nincorrect. It can assign values to static final variables, specifically ones that have not \nbeen assigned a value already, so option B is correct. A static initializer is executed when \nthe class is first loaded, not when an object is created or loaded, making option C correct, \nand options D and E incorrect. If the class is never loaded, then they will not be executed, \nmaking option F correct."
  },
  {
    "number": 165,
    "chapter": 3,
    "question": "What is the output of the BlueCar program?\npackage race;\nabstract class Car {\n   static { System.out.print(\"1\"); }\n   public Car(String name) {\n      super();\n      System.out.print(\"2\");\n   }\n   { System.out.print(\"3\"); }\n}\npublic class BlueCar extends Car {\n   { System.out.print(\"4\"); }\n   public BlueCar() {\n      super(\"blue\");\n      System.out.print(\"5\");\n   }\n   public static void main(String[] gears) {\n      new BlueCar();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "23451",
      "12345",
      "14523",
      "13245",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The class is loaded first, with the static initialization block called and 1 is printed.\nWhen the BlueCar is created in the main() method, the superclass initialization happens \nfirst. The instance initialization blocks are executed before the constructor, so 32 is out-\nputted next. Finally, the object is created with the instance initialization blocks again being \ncalled before the constructor, outputting 45 .  The result is that 13245 is printed, making \noption D the correct answer."
  },
  {
    "number": 166,
    "chapter": 3,
    "question": "Given the following class declaration, which value cannot be inserted into the blank line \nthat would allow the code to compile?\npackage mammal;\ninterface Pet {}\npublic class Canine implements Pet {\n   public ______ getDoggy() {\n      return this;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "Canine",
      "List",
      "Object",
      "Pet",
      "All of the above can be inserted."
    ],
    "explanation": "Recall that this refers to an instance of the current class. Therefore, any superclass of\nCanine can be used as a return type of the method, including Canine itself, making option \nA an incorrect answer. Option D is also incorrect because Canine implements the Pet \ninterface. An instance of a class can be assigned to any interface reference that it inherits. \nOption C is incorrect because Object is the superclass of all instances in Java. Finally, \noption B is the correct answer. Canine cannot be returned as an instance of List because \nCanine does not inherit List."
  },
  {
    "number": 167,
    "chapter": 3,
    "question": "Which statement about the following interface is correct?\npublic interface Movie {\n   String pass \u003d \"TICKET\";\n   private void buyPopcorn() {\n      purchaseTicket();\n   }\n   public static int getDrink() {\n      buyPopcorn();\n      return 32;\n   }\n   private static String purchaseTicket() {\n      getDrink();\n      return pass;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "The code compiles.",
      "The code contains an invalid constant.",
      "The method buyPopcorn() does not compile.",
      "The method getDrink() does not compile.",
      "The method purchaseTicket() does not compile.",
      "The code does not compile for a different reason."
    ],
    "explanation": "The static method getDrink() attempts to access an instance-based private\nmethod buyPopcorn() that results in a compiler error, making option D correct. The rest \nof the code compiles without issue."
  },
  {
    "number": 168,
    "chapter": 3,
    "question": "Which methods compile?\nprivate static int numShovels;\nprivate int numRakes;\n \npublic int getNumShovels() {\n   return numShovels;\n}\n \npublic int getNumRakes() {\n   return numRakes;\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Just getNumRakes()",
      "Just getNumShovels()",
      "Both methods",
      "Neither method"
    ],
    "explanation": "An instance method can access both instance variables and static variables. Both\nmethods compile, and option C is correct."
  },
  {
    "number": 169,
    "chapter": 3,
    "question": "How many lines of the following class contain compilation errors?\n1: class Fly {\n2:    public Fly Fly() { return Fly(); }\n3:    public void Fly(int kite) {}\n4:    public int Fly(long kite) { return 1; }\n5:    public static void main(String[] a) {\n6:       var f \u003d new Fly();\n7:       f.Fly();\n8:    }\n9: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "None.",
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "The answer cannot be determined with the information given."
    ],
    "explanation": "As ugly as the class looks, it does compile, making option A correct. Lines 2–4 each\ndefine an instance method since they each have a name and return type. There is no rule \nsaying you cannot define a method with the same name as the class, although it is consid-\nered bad style. The main() method calls the default no-argument constructor on line 6, \ninserted by the compiler. Finally, line 7 calls the method declared on line 2 ."
  },
  {
    "number": 170,
    "chapter": 3,
    "question": "How many of the classes in the figure can write code that references the sky() method?",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "This method has package-private access, which means only classes in the same package\ncan access it. In our case, this is the Red and Blue classes, making option C correct."
  },
  {
    "number": 171,
    "chapter": 3,
    "question": "Based on the diagram, how many classes can write code that references \nthe light variable?",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "This variable has protected access, which means code in the same package can access\nit in addition to subclasses. There are two classes in the com.color package and one class \nthat subclasses it, making option D the answer."
  },
  {
    "number": 172,
    "chapter": 3,
    "question": "Given the following method signature, which classes cannot call it?\nprotected void run(String government)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "All classes in other packages",
      "All classes in the same package",
      "Subclasses in a different package",
      "Subclasses in the same package"
    ],
    "explanation": "The protected modifier allows access to the same package and subclasses, which are\noptions B, C, and D .  Therefore, the correct answer is option A ."
  },
  {
    "number": 173,
    "chapter": 3,
    "question": "What is the output of the following application?\ninterface Toy { String play(); }\npublic class Gift {\n   public static void main(String[] matrix) {\n      abstract class Robot {}\n      class Transformer extends Robot implements Toy {\n         public String name \u003d \"GiantRobot\";\n         public String play() {return \"DinosaurRobot\";}  // y1\n      }\n      Transformer prime \u003d new Transformer () {\n         public String play() {return name;}             // y2\n      };\n      System.out.print(prime.play()+\" \"+name);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "GiantRobot GiantRobot",
      "GiantRobot DinosaurRobot",
      "DinosaurRobot DinosaurRobot",
      "The code does not compile because of line y1.",
      "The code does not compile because of line y2.",
      "None of the above."
    ],
    "explanation": "The declarations of the local classes Robot and Transformer compile without issue.\nThe only compilation problem in this program is the last line of the main() method. The \nvariable name is defined inside the local class and not accessible outside class declaration \nwithout a reference to the local class. Due to scope, this last line of the main() method does \nnot compile, making option F the correct answer. Note that the first part of the print() \nstatement in the main() method, if the code compiled, would print GiantRobot."
  },
  {
    "number": 174,
    "chapter": 3,
    "question": "What is the output of the HighSchool application?\npackage edu;\nimport java.io.FileNotFoundException;\nabstract class School {\n   abstract Float getNumTeachers();\n   public int getNumStudents() {\n      return 10;\n   }\n}\npublic class HighSchool extends School {\n   final Float getNumTeachers() { return 4f; }\n   public int getNumStudents() throws FileNotFoundException {\n      return 20;\n   }\n   public static void main(String[] s) throws Exception {\n      var school \u003d new HighSchool();\n      System.out.print(school.getNumStudents());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "10",
      "20",
      "4.0",
      "One line of the program does not compile.",
      "Two lines of the program do not compile.",
      "None of the above."
    ],
    "explanation": "When overriding a method, a new or broader checked exception cannot be declared.\nThe getNumStudents() method in HighSchool is an invalid override since it declares \nFileNotFoundException, which is not declared in the parent method. Since this is the \nonly line that does not compile, option D is correct. Note that an abstract method can be \noverridden with a final method, as shown with getNumTeachers()."
  },
  {
    "number": 175,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage track;\ninterface Run {\n   default CharSequence walk() {\n      return \"Walking and running!\";\n   }\n}\ninterface Jog {\n   default String walk() {\n      return \"Walking and jogging!\";\n   }\n}\npublic class Sprint implements Run, Jog {\n   public String walk() {\n      return \"Sprinting!\";\n   }\n   public static void main(String[] args) {\n      var s \u003d new Sprint();\n      System.out.println(s.walk());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Walking and running!",
      "Walking and jogging!",
      "Sprinting!",
      "The code does not compile.",
      "The code compiles but prints an exception at runtime.",
      "None of the above."
    ],
    "explanation": "Having one class implement two interfaces that both define the same default method\nsignature leads to a compiler error unless the class overrides the default method. In this \ncase, the Sprint class overrides both walk() methods correctly; therefore, the code compiles \nwithout issue, and option C is correct. Note that the return types of the two default methods \nare different, but the overridden method uses a return type that is covariant with both."
  },
  {
    "number": 176,
    "chapter": 3,
    "question": "What is true of these two interfaces?\ninterface Crawl {\n  void wriggle();\n}\ninterface Dance {\n   public void wriggle();\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "A concrete class can implement both, but must implement wriggle().",
      "A concrete class can implement both, but must not implement wriggle().",
      "A concrete class would only be able to implement both if the public modifier were\nremoved but must implement wriggle().",
      "If the public modifier were removed, a concrete class can implement both, but must\nnot implement wriggle().",
      "None of the above."
    ],
    "explanation": "Interface methods are implicitly public, giving both the same signature. This means\na class implementing them must implement a single wriggle() method, and option A is \ncorrect."
  },
  {
    "number": 177,
    "chapter": 3,
    "question": "Which of these are functional interfaces?\ninterface Lion {\n   public void roar();\n   default void drink() {}\n   boolean equals(Lion lion);\n}\n \ninterface Tiger {\n   public void roar();\n   default void drink() {}\n   String toString(String name);\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Lion",
      "Tiger",
      "Both Lion and Tiger",
      "Neither is a functional interface.",
      "The code does not compile."
    ],
    "explanation": "The code does compile, so option E is incorrect. A functional interface is required to\nhave exactly one abstract method. Both interfaces have two. In both interfaces, roar() \nis abstract. The equals(Lion) method is similar to the equals(Object) in Object \nbut is not an override of that method. Similarly, the toString() method in Tiger is also \nan abstract method. While there is a toString() method in Object, it does not take \nany parameters. Since each method has two abstract methods, neither is a functional \ninterface, making option D the answer."
  },
  {
    "number": 178,
    "chapter": 3,
    "question": "How many lines of the following class contain a compiler error?\n1:  public class Dragon {\n2:     boolean scaly;\n3:     static final int gold;   \n4:     Dragon protectTreasure(int value, boolean scaly) {\n5:        scaly \u003d true;\n6:        return this;\n7:     }   \n8:     static void fly(boolean scaly) {\n9:        scaly \u003d true;\n10:    }   \n11:    int saveTheTreasure(boolean scaly) {\n12:       return this.gold;\n13:    }   \n14:    static void saveTheDay(boolean scaly) {\n15:       this.gold \u003d 0;\n16:    }\n17:    static { gold \u003d 100; }\n18: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "More than three"
    ],
    "explanation": "The gold variable is marked final, which means it must be set either when it is\ndeclared or in a static initializer, as shown on line 17 .  It cannot be modified by a method, \nthough, so line 15 does not compile. Since this is the only line that does not compile, option \nB is correct. Line 8 compiles because the static method is modifying the local variable \nscaly, not the instance variable of the same name. Line 12 also compiles. While accessing \na static variable via an instance is not recommended, it is allowed."
  },
  {
    "number": 179,
    "chapter": 3,
    "question": "What is true of the following method?\npublic String getColor() {\n   return color;\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "It is a correctly implemented accessor method.",
      "It is a correctly implemented mutator method.",
      "It is an incorrectly implemented accessor method.",
      "It is an incorrectly implemented mutator method.",
      "None of the above."
    ],
    "explanation": "The method is a correct getter or accessor, making option A is correct"
  },
  {
    "number": 180,
    "chapter": 3,
    "question": "Which statement is true?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "You can always change a method signature from call(String[] arg) to\ncall(String... arg) without causing a compiler error in the calling code.",
      "You can always change a method signature from call(String... arg) to\ncall(String[] arg) without causing a compiler error in the existing code.",
      "Both of the above.",
      "Neither of the above."
    ],
    "explanation": "From within a method, an array parameter and a varargs parameter are treated the\nsame. From the caller, an array parameter is more restrictive. Both types can receive an \narray. However, only a varargs parameter is allowed to automatically turn individual \nparameters into an array. Therefore, the answer is option A ."
  },
  {
    "number": 181,
    "chapter": 3,
    "question": "What are two motivations for marking a class final? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [],
    "options": [
      "Guarantee behavior of a class",
      "Allow the class to be extended",
      "Improve security",
      "Support polymorphism",
      "Improve performance",
      "Ensure the contents of the class are immutable"
    ],
    "explanation": "Marking a class final tends to improve security by guaranteeing the behavior of a\nclass is not replaced by overridden methods at runtime. For this reason, options A and C \nare correct. Option B is incorrect and is the opposite of what marking a class final does. \nOptions D and E are incorrect and have nothing to do with marking a class final. Option \nF is incorrect as the contents of the class can still be changed, even if the class is marked \nfinal."
  },
  {
    "number": 182,
    "chapter": 3,
    "question": "Which statement about the following interface is correct?\npublic interface Planet {\n   int circumference;\n   public abstract void enterAtmosphere();\n   public default int getCircumference() {\n      enterAtmosphere();\n      return circumference;\n   }\n   private static void leaveOrbit() {\n      var earth \u003d new Planet() {\n         public void enterAtmosphere() {}\n      };\n      earth.getCircumference();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "The code compiles.",
      "The method enterAtmosphere() does not compile.",
      "The method getCircumference() does not compile.",
      "The method leaveOrbit() does not compile.",
      "The code does not compile for a different reason.",
      "None of the above."
    ],
    "explanation": "The code does not compile because the constant variable circumference does not\ndeclare a value, making option E correct. Remember that all variables within interfaces are \nimplicitly static and final. The rest of the lines of code compile without issue. Note \nthat while the static method leaveOrbit() cannot access the instance-based default \nmethod getCircumference() directly, it can through the reference variable earth."
  },
  {
    "number": 183,
    "chapter": 3,
    "question": "Fill in the blanks: ___________________ methods always have the same name but a differ-\nent list of parameters, while ___________________ methods always have the same name and \nthe same return type.",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "Overloaded, overridden",
      "Inherited, overridden",
      "Overridden, overloaded",
      "Hidden, overloaded",
      "Overridden, hidden",
      "None of the above"
    ],
    "explanation": "Trick question! Overloaded methods is correct in the first part of the sentence, but none\nof the answers is correct in the second part of the sentence. Remember, overridden methods \ncan have covariant return types. They do not need to be the same. For this reason, option F \nis the correct answer."
  },
  {
    "number": 184,
    "chapter": 3,
    "question": "What is the output of the following program?\npublic class Husky {\n   { this.food \u003d 10; }\n   { this.toy \u003d 2; }\n   private final int toy;\n   private static int food;\n   public Husky(int friend) {\n      this.food +\u003d friend++;\n      this.toy -\u003d friend--;\n   }\n   public static void main(String... unused) {\n      var h \u003d new Husky(2);\n      System.out.println(h.food+\",\"+h.toy);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "12,-1",
      "12,2",
      "13,-1",
      "Exactly one line of this class does not compile.",
      "Exactly two lines of this class do not compile.",
      "None of the above."
    ],
    "explanation": "This class creates a final instance toy variable, but it is assigned a value twice. First,\nit is assigned a value in an instance initializer and then in a constructor. For this reason, the \nsecond line of the constructor does not compile, and option D is correct. The first line of \nthe constructor, in which a static variable is referenced from an instance variable, is per-\nmitted but discouraged. Also, initializers may reference variables defined later in the class \ndeclaration."
  },
  {
    "number": 185,
    "chapter": 3,
    "question": "Suppose you have the following code. Which of the images best represents the state of the \nreferences right before the end of the main() method, assuming garbage collection hasn’t \nrun?\n1:  public class Link {\n2:     private String name;\n3:     private Link next;\n4:     public Link(String name, Link next) {\n5:        this.name \u003d name;\n6:        this.next \u003d next;\n7:     }\n8:     public void setNext(Link next) {\n9:        this.next \u003d next;\n10:    }\n11:    public Link getNext() {\n12:       return next;\n13:    }\n14:    public static void main(String... args) {\n15:       var apple \u003d new Link(\"x\", null);\n16:       var orange \u003d new Link(\"y\", apple);\n17:       var banana \u003d new Link(\"z\", orange);\n18:       orange.setNext(banana);\n19:       banana.setNext(orange);\n20:       apple \u003d null;\n21:       banana \u003d null;\n22:    }\n23: }",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Option A.",
      "Option B.",
      "Option C.",
      "Option D.",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "Lines 15–17 create the three objects. Lines 18–19 change the references, so orange\nand banana point to each other. Lines 20–21 wipe out two of the original references. This \nmeans the object with name as x is inaccessible. Option C matches this scenario."
  },
  {
    "number": 186,
    "chapter": 3,
    "question": "Which statement about a no-argument constructor is true?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "The Java compiler will always insert a default no-argument constructor if you do not \ndefine a no-argument constructor in your class.",
      "For a class to call super() in one of its constructors, its parent class must explicitly\nimplement a no-argument constructor.",
      "If a class extends another class that has only one constructor that takes a value, then\nthe child class must explicitly declare at least one constructor.",
      "A class may contain more than one no-argument constructor."
    ],
    "explanation": "Option A is incorrect because Java inserts a no-argument constructor only if there are no\nother constructors in the class. Option B is incorrect because the parent can have a default \nno-argument constructor, which is inserted by the compiler and accessible in the child class. \nOption D is incorrect. A class that contains two no-argument constructors will not compile \nbecause they would have the same signature. Finally, option C is correct. If a class extends a \nparent class that does not include a no-argument constructor, the default no-argument con-\nstructor cannot be automatically inserted into the child class by the compiler. Instead, the \ndeveloper must explicitly declare at least one constructor and explicitly define how the call \nto the parent constructor is made."
  },
  {
    "number": 187,
    "chapter": 3,
    "question": "Which variable declaration is the first line not to compile?\npublic class Complex {\n   class Building {}\n   class House extends Building{}\n \n   public void convert() {\n      Building b1 \u003d  new Building();\n      House h1 \u003d new House();\n      Building b2 \u003d new House();\n      Building b3 \u003d (House) b1;\n      House h2 \u003d (Building) h1;\n      Building b4 \u003d (Building) b2;\n      House h3 \u003d (House) b2;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "b3",
      "h2",
      "b4",
      "h3",
      "All of the lines compile."
    ],
    "explanation": "Building and House are both properly declared inner classes. Any House object\ncan be stored in a Building reference, making the declarations for b3 and b4 compile. \nThe declaration for h3 is also correct. It so happens that b2 is a House object, so the cast \nworks. The declaration of h2 is a problem, though. While the cast itself is fine, a Building \ncannot be stored in a House reference, which means the assignment fails to compile. \nOption B is correct and is the only line with a compiler error in this code. Note that  \nif the declaration of h2 was removed, the declaration of b3 would produce a  \nClassCastException at runtime."
  },
  {
    "number": 188,
    "chapter": 3,
    "question": "What is the output of the following application?\n1:  interface Tasty {\n2:     default void eat() {\n3:        System.out.print(\"Spoiled!\");\n4:     } }\n5:  public class ApplePicking {\n6:     public static void main(String[] food) {\n7:        var apple \u003d new Tasty() {\n8:           @Override\n9:           void eat() {\n10:             System.out.print(\"Yummy!\");\n11:          }\n12:       }\n13:    } }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "Spoiled!",
      "Yummy!",
      "The application completes without printing anything.",
      "One line of this application fails to compile.",
      "Two lines of this application fail to compile.",
      "None of the above."
    ],
    "explanation": "This main() method declares an anonymous class that implements the Tasty interface.\nInterface methods are public, whereas the override in the anonymous class uses package-\nprivate access. Since this reduces the visibility of the method, the declaration of eat() on \nline 9 does not compile. Next, the declaration of the apple object must end with a semi-\ncolon (;) on line 12, and it does not. For these two reasons, the code does not compile, \nand option E is the correct answer. Note that if these two issues were corrected, with the \npublic modifier and missing semicolon (;), then the correct answer would be option C \nbecause the code does not actually call the eat() method; it just declares it."
  },
  {
    "number": 189,
    "chapter": 3,
    "question": "Which of the following statements about functional interfaces is true?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "It is possible to define a functional interface that returns two data types.",
      "It is possible to define a primitive functional interface that uses float, char, or short",
      "All functional interfaces must take arguments or return a value.",
      "None of the primitive functional interfaces includes generic arguments.",
      "None of these statements is true."
    ],
    "explanation": "Java supports only a single return data type or void. Therefore, it is not possible\nto define a functional interface that returns two data types, making option A incorrect. \nAlthough Java does not include built-in support for primitive functional interfaces that \ninclude float, char, or short, there is nothing to prevent a developer from creating \nthem in their own project, making option B the true statement and the correct answer.\nOption C is incorrect because a functional interface that takes no values and returns \nvoid is possible. In fact, Runnable is one such example. Option D is also incorrect, since \nIntFunction\u003cR\u003e takes a primitive argument as input and a generic argument for the \nreturn type."
  },
  {
    "number": 190,
    "chapter": 3,
    "question": "What is the result of executing the Tortoise program?\n// Hare.java\npackage com.mammal;\n \npublic class Hare {\n   void init() {\n      System.out.print(\"init-\");\n   }\n   protected void race() {\n      System.out.print(\"hare-\");\n   }\n}\n \n// Tortoise.java\npackage com.reptile;\nimport com.mammal.Hare;\n \npublic class Tortoise {\n   protected void race(Hare hare) {\n      hare.init();    // x1\n      hare.race();    // x2\n      System.out.print(\"tortoise-\");\n    }\n    public static void main(String[] args) {\n       var tortoise \u003d new Tortoise();\n       var hare \u003d new Hare();\n       tortoise.race(hare);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "init-hare-tortoise",
      "init-hare",
      "The first line with a compiler error is line x1.",
      "The first line with a compiler error is line x2.",
      "The code does not compile due to a different line.",
      "The code throws an exception."
    ],
    "explanation": "The init() method is accessible only from the same package. Since Tortoise is in\na different package, the method is not available, and option C is correct. Line x2 does not \ncompile either since Tortoise is in a different package and not a subclass. However, the \nquestion asks about the first line."
  },
  {
    "number": 191,
    "chapter": 3,
    "question": "How many lines of the following program do not compile?\ninterface Tool {\n   void use(int fun);\n}\nabstract class Childcare {\n   abstract void use(int fun);\n}\nfinal public class Stroller extends Childcare implements Tool {\n   final public void use(int fun) {\n      int width \u003d 5;\n      class ParkVisit {\n         int getValue() { return width + fun; }\n      }\n      System.out.print(new ParkVisit().getValue());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "More than three"
    ],
    "explanation": "The code does not contain any compilation errors. While an abstract class cannot be\nmarked final, a concrete class extending it can be. Likewise, a concrete method overriding \nan abstract one can also be marked final. In the ParkVisit class, the getValue() \nmethod accesses the effectively final variables width and fun. Finally, a class can override \na method that it inherits from both an interface and an abstract class, provided the method \nsignatures are compatible."
  },
  {
    "number": 192,
    "chapter": 3,
    "question": "What is the result of executing the Sounds program?\n// Sheep.java\npackage com.mammal;\n \npublic class Sheep {\n   default void baa() {\n      System.out.println(\"baa!\");\n   }\n   default void speak() {\n      baa();\n   }\n}\n \n// Sounds.java\npackage com.animals;\nimport com.mammal.Sheep;\npublic class Sounds {\n   public static void main(String[] args) {\n      var sheep \u003d new Sheep();\n      sheep.speak();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "The code runs and prints baa!.",
      "The Sheep class does not compile.",
      "The Sounds class does not compile.",
      "Neither class compiles."
    ],
    "explanation": "The Sheep class does not compile because there is no default access modifier key\nword. If the default keyword were omitted, the code would use package-private access. \nSince Sounds is in a different package, option C would then be the answer. However, since \nboth classes have problems, Option D the correct answer."
  },
  {
    "number": 193,
    "chapter": 3,
    "question": "What is the best reason for marking an existing static method private within in an \ninterface?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "It allows the method to be overridden in a subclass.",
      "It hides the secret implementation details from another developer using the interface.",
      "It improves the visibility of the method.",
      "It ensures the method is not replaced with an overridden implementation at runtime.",
      "It allows the method to be marked abstract.",
      "Trick question! All static methods are implicitly private within an interface."
    ],
    "explanation": "Marking an interface method private improves the encapsulation of the class, making\noption B correct. Options A and D are incorrect as static methods cannot be overridden, \nregardless if they are marked private. Option C is incorrect, as adding private to a \nmethod reduces the visibility of the method. Options E and F are flat out wrong."
  },
  {
    "number": 194,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage jungle;\npublic class RainForest extends Forest {\n   public RainForest(long treeCount) {\n      this.treeCount \u003d treeCount+1;\n   }\n   public static void main(String[] birds) {\n      System.out.print(new RainForest(5).treeCount);\n   }\n}\nclass Forest {\n   public long treeCount;\n   public Forest(long treeCount) {\n      this.treeCount \u003d treeCount+2;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "5",
      "6",
      "8",
      "The code does not compile."
    ],
    "explanation": "Since a constructor call is not the first line of the RainForest() constructor, the com\npiler inserts the no-argument super() call. Since the parent class, Forest, does not define \na no-argument super() constructor, the RainForest() constructor does not compile, \nand option D is correct."
  },
  {
    "number": 195,
    "chapter": 3,
    "question": "What is the result of compiling and executing the following class?\npackage sports;\npublic class Bicycle {\n   String color \u003d \"red\";\n   private void printColor(String color) {\n      color \u003d \"purple\";\n      System.out.print(color);\n   }\n   public static void main(String[] rider) {\n      new Bicycle().printColor(\"blue\");\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "red",
      "purple",
      "blue",
      "It does not compile."
    ],
    "explanation": "First, the color variable defined in the instance and set to red is ignored in the method\nprintColor(). Since local scope overrides instance scope, option A is incorrect. The value \nof color passed to the printColor() method is blue, but that is lost by the assignment \nto purple, making option B the correct answer and option C incorrect. Option D is incor-\nrect as the code compiles and runs without issue."
  },
  {
    "number": 196,
    "chapter": 3,
    "question": "Given that Short and Integer extend Number directly, what type can be used to fill in \nthe blank in the following class to allow it to compile?\npackage band;\n \ninterface Horn {\n   public Integer play();\n}\nabstract class Woodwind {\n   public Short play() {\n      return 3;\n   }\n}\npublic final class Saxophone extends Woodwind implements Horn {\n   public _________ play() {\n      return null;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "Object",
      "Integer",
      "Short",
      "Number",
      "None of the above"
    ],
    "explanation": "The play() method is overridden in Saxophone for both Horn and Woodwind, so the\nreturn type must be covariant with both. Object and Number do not work, because nei-\nther is a subclass of Integer or Short. As stated in the question text, both Integer and \nShort extend Number directly, so neither can be a subclass of the other. Therefore, nothing \ncan fill in the blank that would allow this code to compile, and option E is correct."
  },
  {
    "number": 197,
    "chapter": 3,
    "question": "Which statements about abstract classes and methods are correct? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      2
    ],
    "userAnswers": [],
    "options": [
      "An abstract class can be extended by a final class.",
      "An abstract method can be overridden by a final method.",
      "An abstract class can be extended by multiple classes directly.",
      "An abstract class can extend multiple classes directly.",
      "An abstract class cannot implement an interface.",
      "An abstract class can extend an interface."
    ],
    "explanation": "Options A, B, and C are correct statements about abstract classes. Option D is\nincorrect as Java allows a class to extend only one class directly, abstract or otherwise. \nOption E is incorrect, as a class can implement or inherit an interface. Option F is also \nincorrect as classes can only extend classes, and interfaces can only extend interfaces."
  },
  {
    "number": 198,
    "chapter": 3,
    "question": "Given the following enum declaration, how many lines contain compilation errors?\npublic enum Proposition {\n   TRUE(1) { String getNickName() { return \"RIGHT\"; }},\n   FALSE(2) { public String getNickName() { return \"WRONG\"; }},\n   UNKNOWN(3) { public String getNickName() { return \"LOST\"; }}\n   public int value;\n   Proposition(int value) {\n      this.value \u003d value;\n   }\n   public int getValue() {\n      return this.value;\n   }\n   protected abstract String getNickName();\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "More than three"
    ],
    "explanation": "The code does not compile. First, the enum list is not terminated with a semicolon (;),\nwhich is required when an enum includes anything beyond just the list of values. Second, \nthe access modifier of TRUE’s implementation of getNickName() is package-private, but \nthe abstract method signature has a protected modifier. Since package-private is a \nmore restrictive access than protected, the override is invalid, and the code does not com-\npile. For these two reasons, option C is the correct answer. Note that the value variable is \nnot final nor properly encapsulated and can therefore be modified by callers outside the \nenum. This is permitted but considered a poor practice."
  },
  {
    "number": 199,
    "chapter": 3,
    "question": "Which statements about Java classes are true? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      3
    ],
    "userAnswers": [],
    "options": [
      "A Java class file may include more than one package statement.",
      "A Java class file may include more than one import statement.",
      "A Java class file may contain more than one comment.",
      "Any instance fields within a class must be defined after the class name.",
      "Any instance fields within a class must be defined before the class name.",
      "Java supports macros, in which fragments of code within a class may be defined inside "
    ],
    "explanation": "A Java class file may have at most one package statement and any number of\nimport statements and comments. For this reason, option A is incorrect, and options B and \nC are correct. When declaring a class, the name comes first, before instance declarations, \nmaking option D correct and option E incorrect. Finally, Java does not support fragments of \ncode outside of a top-level type, such as a class or interface, making option F incorrect. "
  },
  {
    "number": 200,
    "chapter": 3,
    "question": "What is the result of executing the HopCounter program?\n// Hopper.java\npackage com.animals;\n \npublic class Hopper {\n   protected void hop() {\n      System.out.println(\"hop\");\n   }\n}\n \n// Grasshopper.java\npackage com.insect;\nimport com.animals.Hopper;\n \npublic class Grasshopper extends Hopper {\n   public void move() {\n      hop();  // p1\n   }\n}\n \n// HopCounter.java\npackage com.insect;\n \npublic class HopCounter {\n   public static void main(String[] args) {\n      var hopper \u003d new Grasshopper();\n      hopper.move();  // p2\n      hopper.hop();   // p3\n   }\n}\n ",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "The code prints hop once.",
      "The code prints hop twice.",
      "The first compiler error is on line p1.",
      "The first compiler error is on line p2.",
      "The first compiler error is on line p3."
    ],
    "explanation": "The hop() method has protected access, which allows subclasses to call it, making\nline p1 correct. The HopCounter class is allowed to call the move() method because it is \npublic. However, it is not allowed to call the hop() method since it is referencing a sub-\nclass, but not in one. Therefore, option E is the answer."
  },
  {
    "number": 201,
    "chapter": 3,
    "question": "Which of the following is not an attribute common to both abstract classes and interfaces?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "They both can contain abstract methods.",
      "They both can contain public methods.",
      "They both can contain protected methods.",
      "They both can contain static variables."
    ],
    "explanation": "Interfaces cannot contain protected methods, making option C the answer"
  },
  {
    "number": 202,
    "chapter": 3,
    "question": "Given the following class, which method signature could be successfully added to the class \nas an overloaded version of the findAverage() method?\npublic class Calculations {\n   public Integer findAverage(int sum) { return sum; }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "public Long findAverage(int sum)",
      "public Long findAverage(int sum, int divisor)",
      "public Integer average(int sum)",
      "private void findAverage(int sum)"
    ],
    "explanation": "Options A and D would not allow the class to compile because two methods in the class\ncannot have the same name and arguments, but a different return value. Option C would \nallow the class to compile, but it is not a valid overloaded form of our findAverage() \nmethod since it uses a different method name. Option B is a valid overloaded version of the \nfindAverage() method, since the name is the same but the argument list differs."
  },
  {
    "number": 203,
    "chapter": 3,
    "question": "Which of the following is a valid method name in Java? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [],
    "options": [
      "Go_$Outside$2()",
      "have-Fun()",
      "new()",
      "9enjoyTheWeather()",
      "$sprint()",
      "walk#()"
    ],
    "explanation": "Options A and E are correct since method names may include the underscore (_)\ncharacter as well as the dollar ($) symbol. Note that there is no rule that requires a method \nstart with a lowercase character; it is just a practice adopted by the community. Options B \nand F are incorrect because the hyphen (-) and pound (#) characters may not be part of a \nmethod name. Option C is incorrect since new is a reserved word in Java. Finally, option D \nis incorrect. A method name must start with a letter, the dollar ($) symbol, or an underscore \n(_) character."
  },
  {
    "number": 204,
    "chapter": 3,
    "question": "Fill in the blanks: A functional interface must contain or inherit ______________ and may \noptionally include ______________.",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "at least one abstract method, the @Override annotation",
      "exactly one method, static methods",
      "exactly one abstract method, the @FunctionalInterface annotation",
      "at least one static method, at most one default method",
      "None of the above"
    ],
    "explanation": "A functional interface must include exactly one abstract method, either by inheritance\nor declared directly. It may also have any number, including zero, of default or static \nmethods. For this reason, both parts of option D are incorrect. The first part of option A \nis incorrect because more than one abstract method disqualifies it as a functional inter-\nface. The first part of option B is incorrect because the method must be abstract; that \nis to say, any method will not suffice. Finally, option C is the correct answer. The first part \nof the sentence defines what it means to be a functional interface. The second part refers \nto the optional @FunctionalInterface annotation. It is considered a good practice to \nadd this annotation to any functional interfaces you define because the compiler will report \na problem if you define an invalid interface that does not have exactly one abstract \nmethod."
  },
  {
    "number": 205,
    "chapter": 3,
    "question": "Fill in the blank with the line of code that allows the program to compile and print 15 at \nruntime.\npackage love;\ninterface Sport {\n   private int play() { return 15; }\n}\ninterface Tennis extends Sport {\n   private int play() { return 30; }\n}\npublic class Game implements Tennis {\n   public int play() { return ______________; }\n   public static void main(String... ace) {\n      System.out.println(new Game().play());\n   } }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "Sport.play()",
      "Sport.super.play()",
      "Sport.Tennis.play()",
      "Tennis.Sport.super.play()",
      "The code does not compile regardless of what is inserted into the blank.",
      "None of the above."
    ],
    "explanation": "The code compiles, even if the blank is replaced with a constant int value, making\noption E incorrect. The private method play() declared in the Sport interface is not \naccessible in the Game class. For this reason, option F is correct."
  },
  {
    "number": 206,
    "chapter": 3,
    "question": "What is the output of the following program?\npublic class MoreMusic {\n   {\n      System.out.print(\"do-\"); \n      System.out.print(\"re-\"); \n   }\n   \n   public MoreMusic() {\n      System.out.print(\"mi-\");\n   }\n   public MoreMusic(int note) {\n      this(null);\n      System.out.print(\"fa-\");\n   }\n   public MoreMusic(String song) {\n      this(9);\n      System.out.print(\"so-\");\n   }\n   \n   public static void main(String[] sound) {\n      System.out.print(\"la-\");\n      var play \u003d new MoreMusic(1);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "la-do-re-mi-so-fa-",
      "la-do-re-mi-fa-",
      "do-re-mi-fa-so-la-",
      "fa-re-do-mi-so-",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The code does not compile because two of the constructors contain a cyclic reference to\neach other. The MoreMusic(int) constructor calls this(null), which only matches \nthe MoreMusic(String) constructor. Then, the MoreMusic(String) constructor calls \nthis(9), which only matches the MoreMusic(int) constructor. The compiler notices \nthis circular dependency and does not allow the code to compile."
  },
  {
    "number": 207,
    "chapter": 3,
    "question": "Given the following two classes in the same package, what is the result of executing the Hug \nprogram?\npublic class Kitten {\n   /** private **/ float cuteness;\n   /* public */ String name;\n   // default double age;\n   void meow() { System.out.println(name + \" - \"+cuteness); }\n}\n \npublic class Hug {\n   public static void main(String... friends) {\n      var k \u003d new Kitten();\n      k.cuteness \u003d 5;\n      k.name \u003d \"kitty\";\n      k.meow();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "kitty - 5.0",
      "The Kitten class does not compile.",
      "The Hug class does not compile.",
      "The Kitten and Hug classes do not compile.",
      "None of the above."
    ],
    "explanation": "Both classes compile without issue, and the Hug program prints kitty - 5.0, making\noption A the answer. In the Kitten class, all of the variables have package-private access \nas the access modifiers are commented out. Also, there is no age variable since the entire \nline is commented out. If the comment syntax was removed around private, then the Hug \nclass would not compile on the line that accesses the cuteness variable."
  },
  {
    "number": 208,
    "chapter": 3,
    "question": "Which expressions about enums used in switch statements are correct? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [],
    "options": [
      "The name of the enum type must not be used in each case statement.",
      "A switch statement that takes a enum value may not use ordinal() numbers as\ncase statement matching values.",
      "The name of the enum type must be used in each case statement.",
      "Every value of the enum must be present in a case statement.",
      "A switch statement that takes a enum value can use ordinal() numbers as case\nstatement matching values.",
      "Every value of the enum must be present in a case statement unless a default\nbranch is provided."
    ],
    "explanation": "A switch statement that uses an enum must include case statements that refer\nence the value of the enum, without the enum type. For this reason, option A is correct and \noption C is incorrect. The ordinal() value or position cannot be used in case statements \nwhen the switch statement takes an enum value, making option B correct and option E \nincorrect. Finally, not every value in enum must be present in the case statement, regardless \nof whether a default branch is present, making options D and F incorrect."
  },
  {
    "number": 209,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage prepare;\ninterface Ready {\n   static int first \u003d 2;\n   final short DEFAULT_VALUE \u003d 10;\n   GetSet go \u003d new GetSet();            // n1\n}\npublic class GetSet implements Ready {\n   int first \u003d 5;\n   static int second \u003d DEFAULT_VALUE;   // n2\n   public static void main(String[] begin) {\n      var r \u003d new Ready() {};\n      System.out.print(r.first);        // n3\n      System.out.print(\" \" + second);   // n4\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "2 10",
      "5 10",
      "The code does not compile because of line n1.",
      "The code does not compile because of line n2.",
      "The code does not compile because of line n3.",
      "The code does not compile because of line n4."
    ],
    "explanation": "The code compiles without issue. The main() method creates an instance of an anon\nymous class of Ready. Calling r.first retrieves the static variable within Ready, \nprinting 2 on line n3 .  On line n2, there is no reference so the static variable of GetSet \nis called, printing 10 .  For these reasons, option A is correct."
  },
  {
    "number": 210,
    "chapter": 3,
    "question": "What is the result of executing the Tortoise program?\n// Hare.java\npackage com.mammal;\n \npublic class Hare {\n   public void init() {\n      System.out.print(\"init-\");\n   }\n   private void race() {\n      System.out.print(\"hare-\");\n   }\n}\n \n// Tortoise.java\npackage com.reptile;\nimport com.mammal.Hare;\n \npublic class Tortoise {\n   protected void race(Hare hare) {\n      hare.init();    // x1\n      hare.race();    // x2\n      System.out.print(\"tortoise-\");\n    }\n    public static void main(String[] args) {\n       var tortoise \u003d new Tortoise();\n       var hare \u003d new Hare();\n       tortoise.race(hare);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "init-hare-tortoise",
      "init-hare",
      "The first line with a compiler error is line x1.",
      "The first line with a compiler error is line x2.",
      "The code does not compile due to a different line.",
      "The code throws an exception."
    ],
    "explanation": "The init() method is accessible from any code. However, the race() method is avail\nable only within the Hare class. Since Tortoise is a different class, the method is not \navailable, and option D is correct."
  },
  {
    "number": 211,
    "chapter": 3,
    "question": "What is the result of executing the Sounds program?\n// Sheep.java\npackage com.mammal;\n \npublic class Sheep {\n   private void baa() {\n      System.out.println(\"baa!\");\n   }\n   private static void speak() {\n      baa();\n   }\n}\n \n// Sounds.java\npackage com.animals;\nimport com.mammal.Sheep;\n \npublic class Sounds {\n   public static void main(String[] args) {\n      var sheep \u003d new Sheep();\n      sheep.speak();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "The code runs and prints baa!.",
      "The Sheep class does not compile.",
      "The Sounds class does not compile.",
      "Neither class compiles."
    ],
    "explanation": "The Sheep class does not compile since a static method cannot call an instance\nmethod. The Sounds class does not compile because it does not have access to the \nspeak() method. Since neither class compiles, option D is correct."
  },
  {
    "number": 212,
    "chapter": 3,
    "question": "What is the output of the Helicopter program?\npackage flying;\n \nclass Rotorcraft {\n   protected final int height \u003d 5;\n   abstract int fly();\n}\ninterface CanFly {}\npublic class Helicopter extends Rotorcraft implements CanFly {\n   private int height \u003d 10;\n   protected int fly() {\n      return super.height;\n   }\n   public static void main(String[] unused) {\n      Helicopter h \u003d (Helicopter)new Rotorcraft();\n      System.out.print(h.fly());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "5",
      "10",
      "The code does not compile.",
      "The code compiles but produces a ClassCastException at runtime.",
      "None of the above."
    ],
    "explanation": "The Rotorcraft class includes an abstract method, but the class itself is not marked\nabstract. Only interfaces and abstract classes can include abstract methods. Since the \ncode does not compile, option C is the correct answer."
  },
  {
    "number": 213,
    "chapter": 3,
    "question": "Which statements about the following Twins class are true? (Choose three.)\npackage clone;\ninterface Alex {\n   default void write() { System.out.print(\"1\"); }\n   static void publish() {}\n   void think();\n   private int process() { return 80; }\n}\ninterface Michael {\n   default void write() { System.out.print(\"2\"); }\n   static void publish() {}\n   void think();\n   private int study() { return 100; }\n}\npublic class Twins implements Alex, Michael {\n   void write() { System.out.print(\"3\"); }\n   static void publish() {}\n   void think() {\n      System.out.print(\"Thinking...\");\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "The class fails to compile because of the write() method.",
      "The class fails to compile because of the publish() method.",
      "The class fails to compile because of the think() method.",
      "All of the methods defined in the Alex interface are accessible in the Twins class.",
      "All of the methods defined in the Michael interface are accessible in the Twins class.",
      "The Twins class cannot be marked abstract."
    ],
    "explanation": "All of the interface methods without a private modifier are implicitly public. In\na class, though, a method without a modifier is package-private by default. For this reason, \nthe write() and think() methods do not compile because they are missing the public \nmodifier, making options A and C correct. These are the only compiler errors, making \noption B incorrect. Option D is incorrect because the process() method is not accessible \nwith Twins because it is private. Option E is correct, as all methods are accessible.  \nEven the overridden default method can be accessed in the Twins class by calling \nMichael.super.write(). Finally, option F is incorrect as the class still compiles if  \nit is marked abstract."
  },
  {
    "number": 214,
    "chapter": 3,
    "question": "Given the following program, what is the first line to fail to compile?\n1: public class Electricity {\n2:    interface Power {}\n3:    public static void main(String[] light) {\n4:       class Source implements Power {};\n5:       final class Super extends Source {};\n6:       var start \u003d new Super() {};\n7:       var end \u003d new Source() { static boolean t \u003d true; };\n8:    }\n9: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Line 2",
      "Line 4",
      "Line 5",
      "Line 6",
      "Line 7",
      "All of the lines compile"
    ],
    "explanation": "The Super class is marked final, which mean its cannot be used as the supertype of\nan anonymous class. For this reason, line 6 does not compile, and option D is correct. Line \n7 also does not compile as a local class can only contain static variables that are marked \nfinal."
  },
  {
    "number": 215,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage prepare;\npublic class Ready {\n   protected static int first \u003d 2;\n   private final short DEFAULT_VALUE \u003d 10;\n   private static class GetSet {\n      int first \u003d 5;\n      static int second \u003d DEFAULT_VALUE;\n   }\n   private GetSet go \u003d new GetSet();\n   public static void main(String[] begin) {\n      Ready r \u003d new Ready();\n      System.out.print(r.go.first);\n      System.out.print(\", \"+r.go.second);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "2, 5",
      "5, 10",
      "2, 10",
      "The code does not compile because of the GetSet class declaration.",
      "The code does not compile for another reason."
    ],
    "explanation": "The final variable DEFAULT_VALUE is not a static variable; therefore, the static\nnested class GetSet cannot access it without a reference to the class. For this reason, the \ndeclaration of the static nested class GetSet does not compile, and option D is the \ncorrect answer. The rest of the code compiles without issue. If the DEFAULT_VALUE vari-\nable was modified to be static, then the code would compile and print 5, 10 at runtime."
  },
  {
    "number": 216,
    "chapter": 3,
    "question": "Which of the following are true about the following code? (Choose two.)\npublic class Values {\n   static ____  defaultValue \u003d 8;\n   static ____ DEFAULT_VALUE;\n \n   public static void main(String[] args) {\n      System.out.println(defaultValue + DEFAULT_VALUE);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2
    ],
    "userAnswers": [],
    "options": [
      "When you fill in both blanks with double, it prints 8.00.0",
      "When you fill in both blanks with double, it prints 8.0",
      "When you fill in both blanks with int, it prints 8",
      "When you fill in both blanks with int, it prints 80",
      "When you fill in both blanks with var, it prints 8",
      "When you fill in both blanks with var, it prints 80"
    ],
    "explanation": "The static class variables cannot be used with var since they are not local variables.\nTherefore, options E and F are incorrect. Options B and C are correct because numeric \naddition is used here instead of concatenation."
  },
  {
    "number": 217,
    "chapter": 3,
    "question": "How many Gems objects are eligible for garbage collection right before the end of the \nmain() method?\npublic class Gems {\n   public String name;\n   public Gems(String name) {\n      this.name \u003d name;\n   }\n   public static void main(String... args) {\n      var g1 \u003d Gems(\"Garnet\");\n      var g2 \u003d Gems(\"Amethyst\");\n      var g3 \u003d Gems(\"Pearl\");\n      var g4 \u003d Gems(\"Steven\");\n      g2 \u003d g3;\n      g3 \u003d g2;\n      g1 \u003d g2;\n      g4 \u003d null;\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "The code does not compile"
    ],
    "explanation": "The code does not compile, as the constructor calls on the first four lines of the main()\nmethod are missing the new keyword. If the missing new keywords were added to each line, \nthen the code would compile, and three Gems objects would be available for garbage collec-\ntion."
  },
  {
    "number": 218,
    "chapter": 3,
    "question": "How many lines of the following program contain compilation errors?\npackage sky;\npublic class Stars {\n   private int inThe \u003d 4;\n   public void Stars() {\n      super();\n   }\n   public Stars(int inThe) {\n      this.inThe \u003d this.inThe;\n   }\n   public static void main(String[] endless) {\n      System.out.print(new sky.Stars(2).inThe);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three"
    ],
    "explanation": "The code does not compile, so option A is incorrect. The class contains two methods and\none constructor. The first method, Stars(), looks a lot like a no-argument constructor, \nbut since it has a return value of void, it is a method, not a constructor. Since only construc-\ntors can call super(), the code does not compile due to this line. The only constructor in \nthis class, which takes an int value as input, performs a pointless assignment, assigning \na variable to itself. While this assignment has no effect, it does not prevent the code from \ncompiling. Finally, the main() method compiles without issue since we just inserted the \nfull package name into the class constructor call. This is how a class that does not use an \nimport statement could call the constructor. Since the method is in the same class, and \ntherefore the same package, it is redundant to include the package name but not disallowed. \nBecause only one line causes the class to fail to compile, option B is correct."
  },
  {
    "number": 219,
    "chapter": 3,
    "question": "What is the output of the following application?\npackage sports;\nabstract class Ball {\n   protected final int size;\n   public Ball(int size) {\n      this.size \u003d size;\n   }\n}\ninterface Equipment {}\npublic class SoccerBall extends Ball implements Equipment {\n   public SoccerBall() {\n      super(5);\n   }\n   public Ball get() { return this; }\n   public static void main(String[] passes) {\n      var equipment \u003d (Equipment)(Ball)new SoccerBall().get();\n      System.out.print(((SoccerBall)equipment).size);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "5",
      "The code does not compile due to an invalid cast.",
      "The code does not compile for a different reason.",
      "The code compiles but throws a ClassCastException at runtime."
    ],
    "explanation": "Although the casting is a bit much, the object in question is a SoccerBall. Since \nSoccerBall extends Ball and implements Equipment, it can be explicitly cast to any \nof those types, so no compilation error occurs. At runtime, the object is passed around \nand, due to polymorphism, can be read using any of those references since the underlying \nobject is a SoccerBall. In other words, casting it to a different reference variable does not \nmodify the object or cause it to lose its underlying SoccerBall information. Therefore, \nthe code compiles without issue, and option A is correct."
  },
  {
    "number": 220,
    "chapter": 3,
    "question": "Which statement about the Elephant program is correct?\npackage stampede;\ninterface Long {\n   Number length();\n}\npublic class Elephant {\n   public class Trunk implements Long {\n      public Number length() { return 6; }   // k1\n   }\n   public class MyTrunk extends Trunk {      // k2\n      public Integer length() { return 9; }  // k3\n   }\n   public static void charge() {\n      System.out.print(new MyTrunk().length());\n   }\n   public static void main(String[] cute) {\n      new Elephant().charge();               // k4\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "It compiles and prints 6.",
      "The code does not compile because of line k1.",
      "The code does not compile because of line k2.",
      "The code does not compile because of line k3.",
      "The code does not compile because of line k4.",
      "None of the above."
    ],
    "explanation": "The question may appear to be about method overriding, but it is in fact about member\ninner classes. In fact, all of the method overrides are valid in this class. The code does not \ncompile because the charge() method is static (even though it is called on an instance), \nwhich means it requires an instance to instantiate a member of the member inner class \nMyTrunk. For this reason, the call to new MyTrunk() does not compile, and option F is \ncorrect."
  },
  {
    "number": 1,
    "chapter": 4,
    "question": "Fill in the blanks: The ___________________ keyword is used in method declarations, while \nthe ___________________ keyword is used to send an exception to the surrounding process.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "throwing, catch",
      "throws, throw",
      "catch, throw",
      "throws, catch",
      "throw, throws",
      "catch, throwing"
    ],
    "explanation": "The throws keyword is used in method declarations, while the throw keyword is used\nto send an exception to the surrounding process, making option B the correct answer. The \ncatch keyword is used to handle exceptions. There is no throwing keyword in Java."
  },
  {
    "number": 2,
    "chapter": 4,
    "question": "What is the result of compiling and executing the following application?\npackage mind;\nimport java.io.*;\npublic class Remember {\n   public static void think() throws IOException {  // k1\n      try {\n         throw Exception();\n      } catch (RuntimeException r) {}               // k2\n   }\n   public static void main(String... ideas) throws Exception {\n      think();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The code compiles and runs without printing anything.",
      "The code compiles, but a stack trace is printed at runtime.",
      "The code does not compile because of line k1.",
      "The code does not compile because of line k2.",
      "None of the above."
    ],
    "explanation": "To throw an exception with the throw keyword, an existing or new exception must be\nprovided. In this case, the new keyword is missing in front of Exception() in the think() \nmethod. It is treated as a method call that does not exist, and this line does not compile, mak-\ning option E correct. If the new keyword were added, though, the line would still not compile \nas the checked exception is not handled or declared within the think() method."
  },
  {
    "number": 3,
    "chapter": 4,
    "question": "Given the following keywords, in which order could they be used? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [],
    "options": [
      "try, finally",
      "catch, try, finally",
      "try, catch, catch, finally",
      "finally, catch, try",
      "try, finally, catch",
      "try, catch, finally, finally"
    ],
    "explanation": "The correct order of blocks is try, catch, and finally. For a traditional try/catch\nblock at least one catch or finally must be used. In addition, multiple catch blocks are \nallowed, although at most one finally block is allowed. For these reasons, options A and \nC are correct, and the rest are incorrect."
  },
  {
    "number": 4,
    "chapter": 4,
    "question": "Fill in the blanks: A try statement ______________ a catch or a finally block, while a try-with-\nresources statement ______________.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "is not required to contain, is not required to contain either",
      "is not required to contain, must contain one of them",
      "must contain, is not required to contain either",
      "must contain, must contain a catch block",
      "None of the above."
    ],
    "explanation": "Unlike a try-with-resources statement, in which the catch and finally blocks are\noptional, a traditional try statement requires a catch or finally block to be used, or \nboth. For this reason, option C is correct."
  },
  {
    "number": 5,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage park;\nclass LostBallException extends Exception {}\npublic class Ball {\n   public void toss() throw LostBallException {\n      var windUp \u003d new int[0];\n      System.out.println(windUp[0]);\n   }\n   public static void main(String[] bouncy) {\n      try {\n         new Ball().toss();\n      } catch (Throwable e) {\n         System.out.print(\"Caught!\");\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "0",
      "Caught!",
      "The code does not compile because LostBallException is not handled or declared in the main() method.",
      "The code does not compile because ArrayIndexOutOfBoundsException is not handled or\ndeclared in the toss() method.",
      "The code does not compile for a different reason.",
      "None of the above."
    ],
    "explanation": "The code does not compile because the throw keyword is incorrectly used in the toss()\nmethod declaration. The keyword throws should have been used instead. For this reason, \noption E is the correct answer. If the correct keyword was used, then the code would compile \nand Caught! at runtime."
  },
  {
    "number": 6,
    "chapter": 4,
    "question": "Assuming Scanner is a valid class that implements AutoCloseable, what is the expected output \nof the following code?\ntry (Scanner s \u003d new Scanner(System.in)) {\n   System.out.print(1);\n   s.nextLine();\n   System.out.print(2);\n   s \u003d null;\n} catch (IllegalArgumentException | NullPointerException x) {\n   s.nextLine();\n   System.out.print(3);\n} finally {\n   s.nextLine();\n   System.out.print(4);\n}\nSystem.out.print(5);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "1245",
      "125",
      "1234 followed by a stack trace",
      "124 followed by a stack trace",
      "Does not compile",
      "None of the above"
    ],
    "explanation": "The code does not compile because s is defined within the try-with-resources block. It is\nout of scope by the time it reaches the catch and finally blocks, making option E correct."
  },
  {
    "number": 7,
    "chapter": 4,
    "question": "How many constructors in WhaleSharkException compile in the following class?\npackage friendly;\npublic class WhaleSharkException extends Exception {\n   public WhaleSharkException() {\n      super(\"Friendly shark!\");\n   }\n \n   public WhaleSharkException(String message) {\n      super(new Exception(new WhaleSharkException()));\n   }\n \n   public WhaleSharkException(Exception cause) {}\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three"
    ],
    "explanation": "The Exception class contains multiple constructors, including one that takes \nThrowable, one that takes String, and a no-argument constructor. The first  \nWhaleSharkException constructor compiles, using the Exception constructor that \ntakes a String. The second WhaleSharkException constructor also compiles. The two \nstatements, super() and new Exception(), actually call the same constructor in the \nException class, one after another. The last WhaleSharkException compiles with the \ncompiler inserting the default no-argument constructor super(), because it exists in the \nException class. For these reasons, all of the constructors compile, and option D is the \ncorrect answer."
  },
  {
    "number": 8,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage game;\npublic class Football {\n   public static void main(String officials[]) {\n      try {\n         System.out.print(\u0027A\u0027);\n         throw new ArrayIndexOutOfBoundsException();\n      } catch (RuntimeException r) {\n         System.out.print(\u0027B\u0027);\n         throw r;\n      } catch (Exception e) {\n         System.out.print(\u0027C\u0027);\n      } finally {\n         System.out.print(\u0027D\u0027);\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "ABC",
      "ABD",
      "ABC followed by a stack trace",
      "ABD followed by a stack trace",
      "AD followed by a stack trace",
      "None of the above"
    ],
    "explanation": "The application first enters the try block and prints A. It then throws an \nArrayIndexOutOfBoundsException, which is caught by the first catch block since \nArrayIndexOutOfBoundsException is a subclass of RuntimeException, printing B .\n The exception is then rethrown, but since there isn’t a separate try/catch block around \nit, it does not get caught by the second catch block. Before printing the stack trace, the \nfinally block is called, and D is printed. For these reasons, option D is correct."
  },
  {
    "number": 9,
    "chapter": 4,
    "question": "Which of the following types are not recommended to catch in your application? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      2,
      5,
      2,
      5
    ],
    "options": [
      "Exception",
      "CheckedException",
      "Throwable",
      "RuntimeException",
      "UncheckedException",
      "Error"
    ],
    "explanation": "While Exception and RuntimeException are commonly caught in Java appli\ncations, it is not recommended that Error and Throwable (which includes Error) be \ncaught. An Error often indicates a failure of the JVM, which cannot be recovered from. For \nthese reasons, options C and F are correct, and options A and D are incorrect. Options B and \nE are class names that are not part of the standard Java API."
  },
  {
    "number": 10,
    "chapter": 4,
    "question": "What is the output of the following program?\npackage buffet;\nclass Garden implements AutoCloseable {\n   private final int g;\n   Garden(int g) { this.g \u003d g; }\n   public void close() throws Exception {\n      System.out.print(g);\n   }\n}\npublic class Salad {\n   public static void main(String[] u) throws Exception {\n      var g \u003d new Garden(5);\n      try (g;\n            var h \u003d new Garden(4);\n            var i \u003d new Garden(2)) {\n      } finally {\n         System.out.println(9);\n      }\n      g \u003d null;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "2459",
      "9245",
      "5429",
      "9542",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "A variable declared before the start of a try-with-resources statement may be used if it\nis final or effectively final. Since g is modified after it is set, it is neither; therefore, the \nclass does not compile, and option E is correct. If the last line of the main() method were \nremoved, then the code would compile and print 2459 at runtime."
  },
  {
    "number": 11,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage paper;\nimport java.io.Closeable;\npublic class PrintCompany {\n   class Printer implements Closeable {     // r1\n      public void print() {\n         System.out.println(\"This just in!\");\n      }\n      public void close() {}\n   }\n   public void printHeadlines() {\n      try {Printer p \u003d new Printer()} {     // r2\n         p.print();\n      }\n   }\n   public static void main(String[] headlines) {\n      new PrintCompany().printHeadlines();  // r3\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "This just in!",
      "The code does not compile because of line r1.",
      "The code does not compile because of line r2.",
      "The code does not compile because of line r3.",
      "The code does not compile for a different reason.",
      "None of the above."
    ],
    "explanation": "The class does not compile because in line r2, curly braces, {}, are used instead of paren\ntheses, (), in the try-with-resources statement, making option C the correct answer. If this \nline was fixed to use parentheses, (), then the rest of the class would compile without issue \nand print This just in! at runtime."
  },
  {
    "number": 12,
    "chapter": 4,
    "question": "How many of these custom exceptions are unchecked exceptions?\nclass ColoringException extends IOException {}\nclass CursiveException extends WritingException {}\nclass DrawingException extends IllegalStateException {}\nclass SketchingException extends DrawingException {}\nclass WritingException extends Exception {}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Since IOException and Exception are checked exceptions, ColoringException\nand WritingException are checked exceptions. Further, CursiveException is also \nchecked since it extends a checked exception. By contrast, IllegalStateException is an \nunchecked exception. This means that DrawingException and SketchingException \nare also unchecked, and option C is the answer."
  },
  {
    "number": 13,
    "chapter": 4,
    "question": "How many lines of text does the following program print?\npackage lighting;\nimport java.io.IOException;\npublic class Light {\n   public static void main(String[] v) throws Exception {\n      try {\n         new Light().turnOn();\n      } catch (RuntimeException v) {  // y1\n         System.out.println(v);\n         throw new IOException();     // y2\n      } finally {\n         System.out.println(\"complete\");\n      }\n   }\n   public void turnOn() throws IOException {\n      new IOException(\"Not ready\");   // y3\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One.",
      "Two.",
      "The code does not compile because of line y1.",
      "The code does not compile because of line y2.",
      "The code does not compile because of line y3.",
      "None of the above."
    ],
    "explanation": "The code does not compile because the variable v is used twice in the main() method,\nboth in the method declaration and in the catch block, making option C the correct answer. \nIf a different variable name were used in one of the locations, the program would print one \nline, complete, making option A the correct answer. Note that while an exception is created \ninside the turnOn() method, it is not thrown."
  },
  {
    "number": 14,
    "chapter": 4,
    "question": "Which statements about try-with-resources are false? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "If more than one resource is used, the resources are closed in the order they were created.",
      "Parentheses are used for the resource declaration section, even if more than one resource is used.",
      "If the try block and close() method both throw an exception, then the one thrown by the\nclose() method is suppressed.",
      "A resource may be declared before it is used in a try-with-resources statement.",
      "Resources declarations are separated by commas.",
      "A catch block is not required."
    ],
    "explanation": "When more than one resource is used in a try-with-resources statement, they are closed\nin the reverse order in which they are declared, making option A the first false statement. \nIn addition, resources are separated by semicolons, not commas, making option E the other \nfalse statement. The rest of the statements are true. Note that ability to declare resources \nbefore they are used in a try-with-resources statement is new since Java 9 ."
  },
  {
    "number": 15,
    "chapter": 4,
    "question": "How many lines of text does the following program print?\npackage bee;\nclass SpellingException extends RuntimeException {}\npublic class SpellChecker {\n   public final static void main(String... participants) {\n      try {\n         if(!\"cat\".equals(\"kat\")) {\n            new SpellingException();\n         }\n      } catch (SpellingException | NullPointerException e) {\n         System.out.println(\"Spelling problem!\");\n      } catch (Exception e) {\n         System.out.println(\"Unknown Problem!\");\n      } finally {\n         System.out.println(\"Done!\");\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "One.",
      "Two.",
      "Three.",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The program compiles without issue, so option D is incorrect. The narrower \nSpellingException and NullPointerException, which inherit from Exception, \nare correctly presented in the first catch block, with the broader Exception being  \nin the second catch block. The if-then statement evaluates to true, and a new  \nSpelling Exception instance is created, but it is not thrown because it is missing the \nthrow keyword. For this reason, the try block ends without any of the catch blocks \nbeing executed. The finally block is then called, making it the only section of code in the \nprogram that prints a line of text. For this reason, option A is the correct answer."
  },
  {
    "number": 16,
    "chapter": 4,
    "question": "Which of the following exception types must be handled or declared by the method in which \nthey are thrown? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      5
    ],
    "userAnswers": [
      0,
      3,
      5
    ],
    "options": [
      "FileNotFoundException",
      "ClassCastException",
      "Error",
      "IOException",
      "NullPointerException",
      "Exception"
    ],
    "explanation": "Any class that inherits Exception but not RuntimeException is a checked\nexception and must be handled or declared. For this reason, option F is trivially correct. \nOptions A and D are also checked exceptions. Options B and E are incorrect since they \ninherit RuntimeException. Finally, option C is incorrect as Error inherits Throwable \nbut not Exception."
  },
  {
    "number": 17,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage bed;\npublic class Sleep {\n   public static void snore() {\n      try {\n         String sheep[] \u003d new String[3];\n         System.out.print(sheep[3]);\n      } catch (RuntimeException | Error e) {\n         System.out.print(\"Awake!\");\n      } finally {\n         throw new Exception();                // x1\n      }\n   }\n   public static void main(String... sheep) {  // x2\n      new Sleep().snore();                     // x3\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Awake!",
      "Awake! followed by a stack trace",
      "Does not compile because of line x1",
      "Does not compile because of line x2",
      "Does not compile because of line x3",
      "None of the above"
    ],
    "explanation": "The finally block of the snore() method throws a new checked exception on line x1,\nbut there is no try-catch block around it to handle it, nor does the snore() method declare \nany checked exceptions. For these reasons, line x1 does not compile, and option C is the \ncorrect answer. The rest of the lines of code compile without issue. Note that the code inside \nthe try block, if it ran, would produce an ArrayIndexOutOfBoundsException, which \nwould be caught by the RuntimeException catch block, printing Awake!."
  },
  {
    "number": 18,
    "chapter": 4,
    "question": "What is the output of the following code?\nclass ProblemException extends Exception {\n   ProblemException(Exception e) { super(e); }\n}\nclass MajorProblemException extends ProblemException {\n   MajorProblemException(String message) { super(message); }\n}\npublic class Unfortunate {\n   public static void main(String[] args) throws Exception {\n      try {\n         System.out.print(1);\n         throw new MajorProblemException(\"Uh oh\");\n      } catch (ProblemException | RuntimeException e) {\n         System.out.print(2);\n         try {\n            throw new MajorProblemException(\"yikes\");\n         } finally {\n            System.out.print(3);   \n         }\n      } finally {\n         System.out.print(4);\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "123",
      "123 followed by an exception stack trace.",
      "1234",
      "1234 followed by an exception stack trace.",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The ProblemException class compiles without error. However, the \nMajorProblemException class has, well, a major problem. The constructor attempts to \ncall a superclass constructor with a String parameter, but the ProblemException class \nonly has a constructor with an Exception parameter. This causes a compiler error, which \nis option  E ."
  },
  {
    "number": 19,
    "chapter": 4,
    "question": "Which statement best describes how a class that implements the AutoCloseable interface \nshould be written? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "The close() method is optional since the AutoCloseable interface defines a default implementation.",
      "The close() method should avoid modifying data after it has been run once.",
      "The close() method should not throw any exceptions.",
      "The close() method should throw an exception if there is a problem closing the resource.",
      "The close() method should return a status code."
    ],
    "explanation": "First, option A is an incorrect statement, because the AutoCloseable interface does\nnot define a default implementation of close(). Next, the close() method should \nbe idempotent, which means it is able to be run multiple times without triggering any side \neffects. For this reason, option B is correct. After being run once, future calls to close() \nshould not change any data. Option D is correct, and option C is incorrect because the \nclose() method is fully capable of throwing exceptions if there is a problem. In fact, the \nsignature of the method in AutoCloseable throws a checked Exception. Option E is \nincorrect because the return type of close() is void, which means no return value can \nbe returned."
  },
  {
    "number": 20,
    "chapter": 4,
    "question": "Which of the following diagrams of java.lang classes shows the inheritance \nmodel properly?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": true,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "",
      "",
      "",
      ""
    ],
    "explanation": "Option D is the correct model. The class RuntimeException extends Exception,\nand both Exception and Error extend Throwable. Finally, like all Java classes, they \nall inherit from Object. Notice that Error does not extend Exception, even though we \noften refer to these generally as exceptions."
  },
  {
    "number": 21,
    "chapter": 4,
    "question": "Which exception classes, when inserted into the blank in the Problems class, allow the code \nto compile?\nclass MissingMoneyException {}\nclass MissingFoodException {}\npublic class Problems {\n   public void doIHaveAProblem() \n         throws MissingMoneyException, MissingFoodException {\n      System.out.println(\"No problems\");\n   }\n   public static void main(String[] s) throws  {\n      try {\n         final Problems p \u003d new Problems();\n         p.doIHaveAProblem();\n      } catch (Exception e) {\n         throw e;\n      } } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Exception",
      "RuntimeException",
      "MissingFoodException",
      "MissingMoneyException, MissingFoodException",
      "MissingMoneyException",
      "None of the above"
    ],
    "explanation": "The classes MissingMoneyException and MissingFoodException do not extend\nany exception classes; therefore, they cannot be used in a method declaration. The code  \ndoes not compile regardless of what is placed in the blank, making option F correct."
  },
  {
    "number": 22,
    "chapter": 4,
    "question": "Which statements about Closeable and AutoCloseable are true? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      2
    ],
    "options": [
      "AutoCloseable extends Closeable.",
      "Closeable extends AutoCloseable.",
      "The close() method in a class that implements AutoCloseable cannot throw an IOException.",
      "The close() method in a class that implements Closeable cannot throw an Exception.",
      "There is no difference; one was added for backward compatibility.",
      "Both have a generic return type."
    ],
    "explanation": "Closeable extends AutoCloseable, making option B correct and option \nA incorrect. The close() method in AutoCloseable throws Exception, while the \nclose() method in Closeable throws IOException, making option E incorrect. Since \nIOException is a subclass of Exception, both close() methods can throw an  \nIOException, making option C incorrect. On the other hand, Exception is not a  \nsubclass of IOException. For this reason, the close() method in a class that implements \nCloseable cannot throw an instance of the Exception class, because it is an invalid over-\nride using a broader exception type, making option D the correct answer. Finally, the return \ntype for both is void, making option F incorrect."
  },
  {
    "number": 23,
    "chapter": 4,
    "question": "Which expressions, when inserted into the blank in the following class, allow the code to \ncompile? (Choose two.)\npackage sun;\nimport java.io.*;\npublic class Beach {\n   class TideException extends Exception {}\n   public void surf() throws RuntimeException {\n      try {\n         throw new TideException();\n      } catch ( ) {}\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "Exception a | RuntimeException f",
      "IllegalStateException | TideException t",
      "TideException | IOException i",
      "TideException | Exception x",
      "Error e",
      "Exception z"
    ],
    "explanation": "Option A does not compile because a multi-catch expression uses a single variable, not\ntwo variables. Since the TideException is handled and neither exception class is a subtype \nof the other, option B is correct. Option C does not compile because the compiler notices \nthat it is not possible to throw a checked IOException in this try block. Option D does \nnot compile because multi-catch blocks cannot contain two exceptions in which one is a sub-\nclass of the other. If it did, one of the two exceptions would be redundant. Option E does not \ncompile because the checked TideException is not handled or declared by the surf() \nmethod. Remember, Error and Exception are not subclasses of each other, although they \nboth inherit Throwable. Option F is correct because TideException is a subclass of \nException, so both are handled by Exception."
  },
  {
    "number": 24,
    "chapter": 4,
    "question": "Which of the following are the best scenarios in which to use and catch an exception? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2
    ],
    "userAnswers": [
      1,
      2
    ],
    "options": [
      "The computer caught fire.",
      "A network connection goes down.",
      "A caller passes invalid data to a method.",
      "The code does not compile.",
      "A method finishes sooner than expected.",
      "The program runs out of memory."
    ],
    "explanation": "Option A is incorrect. You should probably seek help if the computer is on fire! Options\nB and C are correct answers, as invalid or missing data/resources should be expected of most \nprograms. Option D is incorrect because code that does not compile cannot run and there-\nfore cannot throw any exceptions. Option E is incorrect; finishing sooner is rarely considered \na problem. Option F is incorrect because an Error is thrown in this situation, and it should \nnot be caught, as the JVM cannot usually recover from this scenario."
  },
  {
    "number": 25,
    "chapter": 4,
    "question": "Which statement about the following program is correct?\n1:  package dogpark;\n2:  public class Fetch {\n3:     public int play(String name) throws RuntimeException {\n4:        try {\n5:           throw new RuntimeException(name);\n6:        } catch (Throwable e) {\n7:           throw new RuntimeException(e);\n8:        }\n9:     }\n10:    public static final void main(String[] ball) \n11:          throws RuntimeException {\n12:       new Fetch().play(\"Webby\");\n13:       new Fetch().play(\"Georgette\");\n14:    }\n15: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "One exception is thrown to the caller at runtime.",
      "Two exceptions are thrown to the caller at runtime.",
      "More than two exceptions are thrown to the caller at runtime.",
      "The class does not compile because of the play() method.",
      "The class does not compile because of the main() method.",
      "None of the above."
    ],
    "explanation": "The program compiles, making options D and E incorrect. At runtime, line 12 is executed,\ncalling the play() method. Line 5 then throws an exception that is immediately caught on \nline 6 .  Line 7 throws a new unchecked exception that is not caught by the program, with \nthis exception being thrown to the caller, and making option A correct. In this case, line 13 is \nnever executed. Even though the stack trace for the exception may include information about \nthe cause, only one exception is actually thrown to the caller."
  },
  {
    "number": 26,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage body;\nimport java.io.IOException;\nclass Organ {\n   public void operate() throws IOException {\n      throw new RuntimeException(\"Not supported\");\n   }\n}\npublic class Heart extends Organ {\n   public void operate() throws Exception {\n      System.out.print(\"beat\");\n   }\n   public static void main(String... c) throws Exception {\n      try {\n         new Heart().operate();\n      } finally {\n         System.out.print(\"!\");\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "beat",
      "beat!",
      "Not supported",
      "The code does not compile.",
      "The code compiles, but a stack trace is printed at runtime.",
      "None of the above."
    ],
    "explanation": "The code does not compile due to an invalid override of the operate() method. An\noverridden method must not throw any new or broader checked exceptions than the method \nit inherits. While both IOException and Exception are checked exceptions, Exception \nis broader than IOException. For this reason, the declaration of operate() in Heart \ndoes not compile, and option D is correct."
  },
  {
    "number": 27,
    "chapter": 4,
    "question": "Which of the following are not true of using a try-with-resources statement? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      0,
      2
    ],
    "options": [
      "It shortens the amount of code a developer must write.",
      "It is possible to close a resource before the end of the try block.",
      "Associated catch blocks are run before the declared resources have been closed.",
      "It is compatible with all classes that implement the Closeable interface.",
      "It is compatible with all classes that implement the AutoCloseable interface.",
      "It cannot be used with a finally block."
    ],
    "explanation": "Option A is a true statement and one of the primary motivations for using a try-with\nresources statement. Option B is also true, although it is recommended you let the try-with-\nresources statement automatically close the resource. The catch blocks are run after the \ndeclared resources have been closed, making option C the first answer. Options D and E are \nboth true, since Closeable extends AutoCloseable and the requirement for try-with-\nresources is that they must be of type AutoCloseable. A try-with-resources statement can \nbe used with a finally block, making option F the other answer."
  },
  {
    "number": 28,
    "chapter": 4,
    "question": "What is the result of compiling and executing the following class?\npackage wind;\npublic class Storm {\n   public static void main(String... rain) throws Exception {\n      var weatherTracker \u003d new AutoCloseable() {\n         public void close() throws RuntimeException {\n            System.out.println(\"Thunder\");\n         }\n      };\n      try (weatherTracker) {\n         System.out.println(\"Tracking\");\n      } catch (Exception e) {\n         System.out.println(\"Lightning\");\n      } finally {\n         System.out.println(\"Storm gone\");\n         weatherTracker.close();\n      }\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "It prints one line.",
      "It prints two lines.",
      "It prints three lines.",
      "It prints four lines.",
      "It does not compile due to an error in the declaration of the weatherTracker resource.",
      "It does not compile for a different reason."
    ],
    "explanation": "The code compiles without issue. It first prints Tracking from the try block. Upon the\ncompletion of the try block, the close() method is called, and Thunder is printed. No \nexception is thrown so the catch block is skipped. In the finally block, Storm gone is \nprinted, followed by Thunder. Since four lines were printed, option D is correct. While it is \nnot recommended to close a resource twice, it is allowed."
  },
  {
    "number": 29,
    "chapter": 4,
    "question": "How many of the following are valid exception declarations?\nclass Error extends Exception {}\nclass _X extends IllegalArgumentException {}\nclass 2BeOrNot2Be extends RuntimeException {}\nclass NumberException\u003cInteger\u003e extends NumberFormatException {}\ninterface Worry implements NumberFormatException {}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Error is a terrible name for an exception since it is a built-in class. However, it is\nlegal. Next, _X is also a bad choice, but it is valid exception as Java identifiers can begin \nwith underscores. By contrast, 2BeOrNot2Be does not compile because identifiers are not \nallowed to begin with a number. NumberException is not a valid exception, because it uses \ngenerics, and the parent class does not. Finally, Worry is not an exception, because it is an \ninterface. Since only two are valid exceptions, option C is the answer."
  },
  {
    "number": 30,
    "chapter": 4,
    "question": "If a try statement has catch blocks for both ClassCastException and  \nRuntime Exception, then which of the following statements is correct?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "The catch blocks for these two exception types can be declared in any order.",
      "A try statement cannot be declared with these two catch block types because they are incompatible.",
      "The catch block for ClassCastException must appear before the catch block for RuntimeException.",
      "The catch block for RuntimeException must appear before the catch block for ClassCastException.",
      "None of the above."
    ],
    "explanation": "ClassCastException is a subclass of RuntimeException, so it must appear first in\nany related catch blocks. For this reason, option C is correct."
  },
  {
    "number": 31,
    "chapter": 4,
    "question": "Assuming Scanner is a valid class that implements AutoCloseable, what is the expected output \nof the following application?\npackage castles;\nimport java.util.Scanner;\npublic class Fortress {\n   public void openDrawbridge() throws Exception {  // p1\n      try {\n         throw new Exception(\"Circle\");             // p2\n      } catch (Exception | Error e) {\n         System.out.print(\"Opening!\");\n      } finally {\n         System.out.print(\"Walls\");\n      }\n   }\n   public static void main(String[] moat) {\n      try (var e \u003d new Scanner(System.in)) {\n         new Fortress().openDrawbridge();           // p3\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Opening!Walls",
      "The code does not compile because of line p1.",
      "The code does not compile because of line p2.",
      "The code does not compile because of line p3.",
      "The code compiles, but a stack trace is printed at runtime.",
      "None of the above."
    ],
    "explanation": "The openDrawbridge() method declares a checked exception that is not handled or\ndeclared in the main() method where it is called. For this reason, line p3 does not com-\npile, and option D is correct. The rest of the lines do not contain any compiler errors. If the \nmain() method were changed to declare Exception, then the class would compile and \nprint Opening!Walls at runtime."
  },
  {
    "number": 32,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage game;\npublic class BasketBall {\n   public static void main(String[] dribble) {\n      try {\n         System.out.print(1);\n         throw new ClassCastException();\n      } catch (ArrayIndexOutOfBoundsException ex) {\n         System.out.print(2);\n      } catch (Throwable ex) {\n         System.out.print(3);\n      } finally {\n         System.out.print(4);\n      }\n      System.out.print(5);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "145",
      "1345",
      "1235",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The code compiles and runs without issues. The try block throws a \nClass CastException. Since ClassCastException is not a subclass of  \nArrayIndex OutOfBoundsException, the first catch block is skipped. For the second \ncatch block, ClassCastException is a subclass of Throwable so that block is exe-\ncuted. Afterward, the finally block is executed, and then control returns to the main() \nmethod with no exception being thrown. The result is that 1345 is printed, making option B \nthe correct answer."
  },
  {
    "number": 33,
    "chapter": 4,
    "question": "Which of the following statements about finally blocks are true? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      0,
      2
    ],
    "options": [
      "Every line of the finally block is guaranteed to be executed.",
      "The finally block is executed only if the related catch block is also executed.",
      "The finally statement requires curly braces, {}.",
      "A finally block cannot throw an exception.",
      "The first line of a finally block is guaranteed to be executed.",
      "A finally block can only throw unchecked exceptions."
    ],
    "explanation": "A finally block requires curly braces, making option C correct. A finally block\ncan throw an exception in which case not every line of the finally block will be executed. \nFor this reason, option E is correct, and options A and D are incorrect. Option B is incorrect \nbecause a finally block is called regardless of whether the related catch block is exe-\ncuted. A finally block can throw both checked and unchecked exceptions, making option \nF incorrect. If the exception is checked, then it must be handled or declared in the method in \nwhich the finally block is used."
  },
  {
    "number": 34,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage signlanguage;\nimport java.io.Closeable;\nclass ReadSign implements Closeable {\n   public void close() {}\n   public String get() {return \"Hello\";}\n}\nclass MakeSign implements AutoCloseable {\n   public void close() {}\n   public void send(String message) {\n      System.out.print(message);\n   }\n}\npublic class Translate {\n   public static void main(String... hands) {\n      try (ReadSign r \u003d new ReadSign();\n         MakeSign w \u003d new MakeSign();) {\n         w.send(r.get());\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Hello",
      "The code does not compile because of the ReadSign class.",
      "The code does not compile because of the MakeSign class.",
      "The code does not compile because of the Translate class.",
      "The code does not compile because of the try-with-resources statement.",
      "None of the above."
    ],
    "explanation": "The application compiles without issue and prints Hello, making option A the correct\nanswer. The ReadSign and MakeSign classes are both correctly implemented, with both \noverridden versions of close() dropping the checked exceptions. The try-with-resources \nstatement is also correctly implemented for two resources and does not cause any compila-\ntion errors or runtime exceptions. Note that the semicolon (;) after the second resource dec-\nlaration is optional."
  },
  {
    "number": 35,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage what;\nclass FunEvent implements AutoCloseable {\n   private final int value;\n   FunEvent(int value) { this.value \u003d value; }\n   public void close() {\n      System.out.print(value);\n   }\n}\npublic class Happening {\n   public static void main(String... lots) {\n      FunEvent e \u003d new FunEvent(1);\n      try (e; var f \u003d new FunEvent(8)) {\n         System.out.print(\"2\");\n         throw new ArithmeticException();\n      } catch (Exception x) {\n         System.out.print(\"3\");\n      } finally {\n         System.out.print(\"4\");\n      }\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "24",
      "21834",
      "23418",
      "23481",
      "28134",
      "The code does not compile."
    ],
    "explanation": "The try block is entered and 2 is printed, followed by an exception. Upon completion\nof the try block, the resources are closed in the reverse order in which they are declared, \nprinting 8 followed by 1 .  Next, the catch block executes, printing 3, followed by the \nfinally block printing 4 .  For these reasons, option E is correct."
  },
  {
    "number": 36,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage office;\nimport java.io.*;\npublic class Printer {\n   public void print() {\n      try {\n         throw new FileNotFoundException();\n      } catch (Exception | RuntimeException e) {\n         System.out.print(\"Z\");\n      } catch (Throwable f) {\n         System.out.print(\"X\");\n      } finally {\n         System.out.print(\"Y\");\n      }\n   }\n \n   public static void main(String... ink) {\n      new Printer().print();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Y",
      "XY",
      "ZY",
      "The code does not compile.",
      "The code compiles, but a stack trace is printed at runtime.",
      "None of the above."
    ],
    "explanation": "A multi-catch block cannot contain two exception types in which one inherits from the\nother. Since RuntimeException inherits Exception, RuntimeException is redundant. \nFor this reason, the code does not compile, and option D is correct."
  },
  {
    "number": 37,
    "chapter": 4,
    "question": "What is the output of the following code?\nclass ProblemException extends Exception {\n   ProblemException(Exception e) { super(e); }\n}\nclass MajorProblemException extends ProblemException {\n   MajorProblemException(Exception e) { super(e); }\n}\npublic class Unfortunate {\n   public static void main(String[] args) throws Exception {\n      try {\n         System.out.print(1);\n         throw new MajorProblemException(\n            new IllegalStateException());\n      } catch (ProblemException | RuntimeException e) {\n         System.out.print(2);\n         try {\n            throw new MajorProblemException(e);\n         } finally {\n            System.out.print(3);   \n         }\n      } finally {\n         System.out.print(4);\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "123",
      "123 followed by an exception stack trace",
      "1234",
      "1234 followed by an exception stack trace",
      "Does not compile",
      "None of the above"
    ],
    "explanation": "In the try block, the code prints 1 and throws an exception. The catch block success\nfully handles it by printing 2 and throwing another exception. Both the inner and outer \nfinally blocks run printing 3 and 4, respectively. Then the stack trace for the exception \nthrown by the inner try block is printed."
  },
  {
    "number": 38,
    "chapter": 4,
    "question": "What is the output of the following application?\n1:  package robot;\n2:  public class Computer {\n3:     public void compute() throws Exception {\n4:        throw new NullPointerException(\"Does not compute!\");\n5:     }\n6:     public static void main(String[] b) throws Exception {\n7:        try {\n8:           new Computer().compute();\n9:        } catch (RuntimeException e) {\n10:          System.out.print(\"zero\");\n11:          throw e;\n12:       } catch (Exception e) {\n13:          System.out.print(\"one\");\n14:          throw e;\n15:       }\n16:    }\n17: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "zero",
      "one",
      "zero followed by a stack trace",
      "one followed by a stack trace",
      "Does not compile",
      "None of the above"
    ],
    "explanation": "The code compiles without issue. Line 8 calls the compute() method, which throws a\nNullPointerException on line 4 .  This is caught in the main() method on line 9, since \nNullPointerException is a subclass of RuntimeException, printing zero followed \nby a stack trace to the caller and making option C correct."
  },
  {
    "number": 39,
    "chapter": 4,
    "question": "Given the following class diagram, which two classes are missing in the hierarchy at  \npositions 1 and 2?\n",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "IOException at position 1, Exception at position 2",
      "Exception at position 1, RuntimeException at position 2",
      "IllegalArgumentException at position 1, RuntimeException at position 2",
      "IllegalStateException at position 1, RuntimeException at position 2",
      "Exception at position 1, FileNotFoundException at position 2",
      "None of the above"
    ],
    "explanation": "The UnsupportedOperationException class is an unchecked exception that is a\ndirect child of RuntimeException. For this reason, we can eliminate any answer that  \ndoes not inherit from RuntimeException including options A and  E . Options C and  \nD are close, but UnsupportedOperationException is a direct subclass of  \nRuntime Exception. Option B is incorrect because RuntimeException is a subclass,  \nnot a superclass, of Exception. The correct diagram would be to reverse option B and  \nput RuntimeException at position 1, and Exception at position 2 .  Since this is not \navailable, option F is correct."
  },
  {
    "number": 40,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage vortex;\nclass TimeException extends Exception {}\nclass TimeMachine implements AutoCloseable {\n   int v;\n   public TimeMachine(int v) {this.v \u003d v;}\n   public void close() throws Exception {\n      System.out.print(v);\n   } }\npublic class TimeTraveler {\n   public static void main(String[] twelve) {\n      try (var timeSled \u003d new TimeMachine(1);\n           var delorean \u003d new TimeMachine(2);\n           var tardis \u003d new TimeMachine(3)) {\n      } catch (TimeException e) {\n         System.out.print(4);\n      } finally {\n         System.out.print(5);\n      }\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "1235",
      "3215",
      "5123",
      "5321",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The close() method in each of the resources throws an Exception, which must be\nhandled or declared in the main() method. The catch block supports TimeException, \nbut it is too narrow to catch Exception. Since there are no other catch blocks present and \nthe main() method does not declare Exception, the try-with-resources statement does \nnot compile, and option E is the correct answer. If the catch block were modified to handle \nException instead of TimeException, the code would compile without issue and print \n3215 at runtime, closing the resources in the reverse order in which they were declared."
  },
  {
    "number": 41,
    "chapter": 4,
    "question": "Which of the following are common reasons to add a checked exception to a method  \nsignature? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      4
    ],
    "userAnswers": [
      1,
      2,
      4
    ],
    "options": [
      "To alert developers that the state of the JVM has been corrupted",
      "To force a caller to handle or declare potential problems",
      "To ensure that exceptions never cause the application to terminate",
      "To notify the caller of potential types of problems",
      "To give the caller a chance to recover from a problem",
      "To annoy other developers"
    ],
    "explanation": "Checked exceptions are commonly used to notify or force a caller to deal with an\nexpected type of problem, such as the inability to write a file to the file system, and give them \nthe opportunity to recover without terminating the program. For these reasons, options B, D, \nand E are correct. Option A is incorrect as a corrupted JVM is likely an Error that cannot \nbe recovered from. Option C is also incorrect, as some problems should result in the applica-\ntion terminating. Finally, option F is incorrect and is ideally never the motivation for adding \na checked exception to a method signature!"
  },
  {
    "number": 42,
    "chapter": 4,
    "question": "Which statement about the following application is correct?\npackage highway;\nimport java.io.*;\nclass CarCrash extends RuntimeException {\n   CarCrash(Exception e) {}                               // w1\n}\npublic class Car {\n   public static void main(String[] s) throws Exception { // w2\n      try {\n         throw new IOException(\"Auto-pilot error\");\n      } catch (Exception | CarCrash e) {                  // w3\n         throw e;\n      } catch (Exception a) {                             // w4\n         throw a;\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "The code does not compile because of line w1.",
      "The code does not compile because of line w2.",
      "The code does not compile because of line w3.",
      "The code does not compile because of line w4.",
      "The code compiles and prints a stack trace at runtime.",
      "None of the above."
    ],
    "explanation": "A multi-catch block cannot contain two exceptions in which one is a subtype of the other,\nsince it is a redundant expression. Since CarCrash is a subclass of RuntimeException \nand RuntimeException is a subclass of Exception, line w3 contains a compilation error, \nmaking option C the correct answer. The rest of the lines of code do not contain any compi-\nlation errors."
  },
  {
    "number": 43,
    "chapter": 4,
    "question": "Which of the following exception classes must be handled or declared in the method in which \nthey are thrown? (Choose three.)\npublic class Happy extends IOException {}\npublic class Dopey extends Grumpy {}\npublic class Sleepy extends IllegalStateException {}\npublic class Sneezy extends UnsupportedOperationException {}\npublic class Doc extends AssertionError {}\npublic class Grumpy extends SQLException {}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      5
    ],
    "userAnswers": [
      0,
      1,
      5
    ],
    "options": [
      "Happy",
      "Dopey",
      "Sleepy",
      "Sneezy",
      "Doc",
      "Grumpy"
    ],
    "explanation": "Since IOException and SQLException are checked exceptions, Happy and\nGrumpy are checked exceptions, respectively, making options A and F correct. Since Dopey \ninherits Grumpy, option B is also a checked exception. Options C and D are unchecked \nexceptions because those classes inherit RuntimeException. Option E is also an \nunchecked exception because all Error classes are unchecked."
  },
  {
    "number": 44,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage pond;\nabstract class Duck {\n   protected int count;\n   public abstract int getDuckies();\n}\npublic class Ducklings extends Duck {\n   private int age;\n   public Ducklings(int age) { this.age \u003d age; }\n   public int getDuckies() { return this.age/count; }\n   public static void main(String[] pondInfo) {\n      Duck itQuacks \u003d new Ducklings(5);\n      System.out.print(itQuacks.getDuckies());\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "0",
      "1",
      "5",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The code compiles without issue, so option D is incorrect. The key here is noticing that\ncount, an instance variable, is initialized with a value of 0 .  The getDuckies() method \nends up computing 5/0, which leads to an unchecked ArithmeticException at runtime, \nmaking option E the correct answer."
  },
  {
    "number": 45,
    "chapter": 4,
    "question": "Which statements about the following line of code are correct? (Choose three.)\nthrow new IllegalArgumentException ();",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      5
    ],
    "userAnswers": [
      0,
      2,
      3
    ],
    "options": [
      "The method where this is called must declare a compatible exception.",
      "The code where this is called can include a try-with-resources block that handles this exception.",
      "This exception should not be handled or declared.",
      "The code where this is called can include a try/catch block that handles this exception.",
      "This exception should be thrown only at the start of a method.",
      "This exception does not need to be handled by the method in which it is called."
    ],
    "explanation": "An IllegalArgumentException is an unchecked exception. It can be handled or\ndeclared in the method in which it is defined, although it is optional and not required. For \nthis reason, options B, D, and F are correct, and options A and C are incorrect. Option E is \nincorrect, as there is no requirement where in a method this exception can be thrown."
  },
  {
    "number": 46,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage storage;\nimport java.io.*;\npublic class Backup {\n   public void performBackup() {\n      try {\n         throw new IOException(\"Disk not found\");  // z1\n      } catch (Exception e) {\n         try {\n            throw new FileNotFoundException(\"File not found\");\n         } catch (FileNotFoundException e) {       // z2\n            System.out.print(\"Failed\");\n         }\n      }\n   }\n   public static void main(String... files) {\n      new Backup().performBackup();                // z2\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Failed",
      "The application compiles, but a stack trace is printed at runtime.",
      "The code does not compile because of line z1.",
      "The code does not compile because of line z2.",
      "The code does not compile because of line z3.",
      "None of the above."
    ],
    "explanation": "While a catch block is permitted to include an embedded try-catch block, the issue here\nis that the variable name e is already used by the first catch block. In the second catch \nblock, it is equivalent to declaring a variable e twice. For this reason, line z2 does not com-\npile, and option D is the correct answer. If a different variable name was used for either \ncatch block, then the code would compile without issue, printing Failed at runtime."
  },
  {
    "number": 47,
    "chapter": 4,
    "question": "What is the output of the following?\npackage com.tps;\nimport java.io.IOException;\npublic class IncidentReportException extends RuntimeException {\n   public static void main(String[] args) throws Exception {\n      try {\n         throw new IncidentReportException(new IOException());\n      } catch (RuntimeException e) {\n         System.out.println(e.getCause());\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "com.tps.IncidentReportException",
      "java.lang.IOException",
      "The code does not compile because IOException is a checked exception.",
      "The code does not compile due to the declaration of IncidentReportException.",
      "None of the above."
    ],
    "explanation": "The declaration of IncidentReportException does not provide any constructors,\nwhich means only the default constructor is available. Since the code attempts to pass an \nIOException as a parameter, the main() method does not compile, so the correct answer \nis option  D ."
  },
  {
    "number": 48,
    "chapter": 4,
    "question": "Which expression, when inserted into the blank in the following class, allows the code \nto compile?\npackage music;\nimport java.sql.*;\npublic class Bells {\n   class Player implements AutoCloseable {\n      @Override public void close() throws RingException {}\n   }\n   class RingException extends Exception {\n      public RingException(String message) {}\n   }\n   public static void main(String[] notes) throws Throwable {\n      try (Player p \u003d null) {\n         throw new Exception();\n      } catch (Exception e) {\n      } catch ( ) {\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Error r",
      "IllegalStateException b",
      "RingException q",
      "SQLException p",
      "RuntimeException r",
      "The code does not compile regardless of the expression used."
    ],
    "explanation": "The try-catch block already catches Exception, so the correct answer would be the one\nthat is not a subtype of Exception. In this case, Error extends Throwable and is the only \nchoice that allows the code to compile, making option A correct."
  },
  {
    "number": 49,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage zoo;\nclass BigCat {\n   void roar(int level) throw RuntimeException {\n      if(level\u003c3) throw new IllegalArgumentException();\n      System.out.print(\"Roar!\");\n   }\n}\npublic class Lion extends BigCat {\n   public void roar() {\n      System.out.print(\"Roar!!!\");\n   }\n   void roar(int sound) {\n      System.out.print(\"Meow\");\n   }\n   public static void main(String[] cubs) {\n      final BigCat kitty \u003d new Lion();\n      kitty.roar(2);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Meow",
      "Roar!",
      "Roar!!!",
      "MeowRoar!",
      "A stack trace is printed at runtime.",
      "None of the above."
    ],
    "explanation": "The application does not compile because the roar() method in the BigCat class uses\nthrow instead of throws, making option F correct. Note that if the correct keyword was \nused, then the code would compile and print Meow at runtime. "
  },
  {
    "number": 50,
    "chapter": 4,
    "question": "Which statement about the following program is true?\npackage tag;\nclass MissedCallException extends Exception {}\npublic class Phone {\n   static void makeCall() throws RuntimeException {\n      throw new ArrayIndexOutOfBoundsException(\"Call\");\n   }\n   public static void main(String[] messages) {\n      try {\n         makeCall();\n      } catch (MissedCallException e) {\n         throw new RuntimeException(\"Voicemail\");\n      } finally {\n         throw new RuntimeException(\"Text\");\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "An exception is printed at runtime with Call in the message.",
      "An exception is printed at runtime with Voicemail in the message.",
      "An exception is printed at runtime with Text in the message.",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The MissedCallException is a checked exception since it extends Exception and\ndoes not inherit RuntimeException. For this reason, the first catch block fails to com-\npile, since the compiler detects that it is not possible to throw this checked exception inside \nthe try block, making option D the correct answer. Note that if MissedCallException \nwas changed to extend the unchecked RuntimeException class, then the code would  \ncompile and the RuntimeException from the finally block would replace the  \nArrayIndexOutOfBoundsException from the try block and Text would be in the \nmessage to the caller."
  },
  {
    "number": 51,
    "chapter": 4,
    "question": "If a try statement has catch blocks for both IllegalArgumentException and \nNullPointer Exception, then which of the following statements is correct?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "The catch blocks for these two exception types can be declared in any order.",
      "A try statement cannot be declared with these two catch block types because they are ",
      "The catch block for IllegalArgumentException must appear before the catch block for ",
      "The catch block for NullPointerException must appear before the catch block ",
      "None of the above."
    ],
    "explanation": "Both IllegalArgumentException and NullPointerException inherit \nRuntimeException, but neither inherits from each other. For this reason, they can be listed \nin catch blocks in either order, making option A the correct statement."
  },
  {
    "number": 52,
    "chapter": 4,
    "question": "What is the output of the following application?\npackage furniture;\nclass Chair {\n   public void sit() throws IllegalArgumentException {\n      System.out.print(\"creek\");\n      throw new RuntimeException();\n   }\n}\npublic class Stool extends Chair {\n   public void sit() throws RuntimeException {\n      System.out.print(\"thud\");\n   }\n   public static void main(String... c) throws Exception {\n      try {\n         new Stool().sit();\n      } finally {\n         System.out.print(\"?\");\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "creek",
      "thud",
      "thud?",
      "The code does not compile.",
      "The code compiles, but a stack trace is printed at runtime.",
      "None of the above."
    ],
    "explanation": "While RuntimeException is broader than IllegalArgumentException, the\nrestriction on overriding methods applies only to checked exceptions, not unchecked excep-\ntions. In other words, the code would not compile if both of the exceptions were checked. \nSince they are unchecked, though, the method override is valid. The program compiles and \nprints thud? at runtime, making option C correct."
  },
  {
    "number": 53,
    "chapter": 4,
    "question": "What is the output of the following application?\nimport java.io.*;\nimport java.sql.*;\npublic class DatabaseHelper {\n   static class MyDatabase implements Closeable {\n      public void close() throws SQLException {\n         System.out.print(\"2\");\n      }\n      public void write(String data) {}\n      public String read() {return null;}\n   }\n   public static void main(String... files) throws Exception {\n      try (MyDatabase myDb \u003d new MyDatabase()) {\n         // TODO: Decide what to read/rite\n      } finally {\n         System.out.print(\"1\");\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "12",
      "21",
      "The code does not compile because of the MyDatabase nested class.",
      "The code does not compile because of the try-with-resources statement.",
      "The code does not compile for a different reason."
    ],
    "explanation": "The Closeable interface defines a close() method that throws IOException. The\noverridden implementation of MyDatabase, which implements Closeable, declares a \nSQLException. This is a new checked exception not found in the inherited method signa-\nture. Therefore, the method override is invalid, and the close() method in MyDatabase \ndoes not compile, making option C the correct answer."
  },
  {
    "number": 54,
    "chapter": 4,
    "question": "What constructors are capable of being called on a custom exception class that directly \nextends the Exception class?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One that takes a single Exception",
      "One that takes a single String",
      "Both of these",
      "Neither of these"
    ],
    "explanation": "Custom exception classes may simply use the default constructor. It is also common to\noverride the constructors that take a single Exception or a single String, making option \nC correct."
  },
  {
    "number": 55,
    "chapter": 4,
    "question": "What is the result of compiling and running the following application?\npackage dinner;\npublic class Pizza {   \n   Exception order(RuntimeException e) {          // h1\n      throw e;                                    // h2\n   }   \n   public static void main(String... u) {\n      var p \u003d new Pizza();\n      try {\n         p.order(new IllegalArgumentException()); // h3\n      } catch(RuntimeException e) {               // h4\n         System.out.print(e);\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "java.lang.IllegalArgumentException is printed.",
      "The code does not compile because of line h1.",
      "The code does not compile because of line h2.",
      "The code does not compile because of line h3.",
      "The code does not compile because of line h4.",
      "The code compiles, but a stack trace is printed at runtime."
    ],
    "explanation": "While this code looks a bit strange, it does compile. An exception can be passed to\na method or set as the return type of a method. In this case, the exception passed to the \norder() method is thrown and caught on line h4 .  The output is just the name of the class, \nmaking option A correct."
  },
  {
    "number": 56,
    "chapter": 4,
    "question": "Given an application that hosts a website, which of the following would most likely result in \na java.lang.Error being thrown? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      2,
      5
    ],
    "options": [
      "A user tries to sign in too many times.",
      "Two users try to register an account at the same time.",
      "An order update page calls itself infinitely.",
      "The application temporarily loses connection to the network.",
      "A user enters their password incorrectly.",
      "The connections to a database are never released and keep accumulating."
    ],
    "explanation": "A Java application tends to only throw an Error when the application has encoun\ntered an unrecoverable error. Failure of a user to sign in or register are common occurrences, \nmaking options A, B, and E incorrect. On the other hand, calling a method infinitely can lead \nto an unrecoverable StackOverflowError, making option C correct. Option D uses the \nword temporarily, meaning the network connection could come back up allowing the appli-\ncation to recover. Option F is the other correct answer. Over time, failing to release database \nconnections could result in the application running out of available database connections or \nworse, out of memory, and being unable to recover."
  },
  {
    "number": 57,
    "chapter": 4,
    "question": "How many lines of text does the following program print?\npackage tron;\nclass DiskPlayer implements AutoCloseable {\n   public void close() {}\n}\npublic class LightCycle {\n   public static void main(String... bits) {\n      try (DiskPlayer john \u003d new DiskPlayer()) {\n         System.out.println(\"ping\");\n         john.close();\n      } finally {\n         System.out.println(\"pong\");\n         john.close();\n      }\n      System.out.println(\"return\");\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One.",
      "Two.",
      "Three.",
      "The code does not compile because of the DiskPlayer class.",
      "The code does not compile for a different reason.",
      "None of the above."
    ],
    "explanation": "The code does not compile because john is declared in the try-with-resources statement\nand not accessible in the finally block."
  },
  {
    "number": 58,
    "chapter": 4,
    "question": "What is the output of the following?\npackage com.tps;\nimport java.io.IOException;\npublic class IncidentReportException extends RuntimeException {\n   public IncidentReportException(Exception e) {\n      super(e);\n   }\n   public static void main(String[] args) throws Exception {\n      try {\n         throw new IncidentReportException(new IOException());\n      } catch (RuntimeException e) {\n         System.out.println(e.getCause());\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "com.tps.IncidentReportException",
      "java.lang.IOException",
      "The code does not compile because IOException is a checked exception.",
      "The code does not compile due to the declaration of IncidentReportException.",
      "None of the above."
    ],
    "explanation": "The code does compile, making options C and D incorrect. The catch block successfully\ncatches the IncidentReportException and prints the IOException passed to its con-\nstructor, making option B the correct answer."
  },
  {
    "number": 59,
    "chapter": 4,
    "question": "Given the following application, what is the name of the class printed at line e1?\npackage canyon;\nfinal class FallenException extends Exception {}\nfinal class HikingGear implements AutoCloseable {\n   @Override public void close() throws Exception {\n      throw new FallenException();\n   }\n}\npublic class Cliff {\n   public final void climb() throws Exception {\n      try (HikingGear gear \u003d new HikingGear()) {\n         throw new RuntimeException();\n      }\n   }\n   public static void main(String... rocks) {\n      try {\n         new Cliff().climb();\n      } catch (Throwable t) {\n         System.out.println(t);  // e1\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "canyon.FallenException",
      "java.lang.RuntimeException",
      "The code does not compile.",
      "The code compiles, but the answer cannot be determined until runtime.",
      "None of the above."
    ],
    "explanation": "The code compiles without issue, making option C incorrect. In the climb() method,\ntwo exceptions are thrown. The RuntimeException thrown in the try block is consid-\nered the primary exception, while the FallenException thrown by the close() method \nis suppressed. For this reason, java.lang.RuntimeException is reported to the caller in \nthe main() method, and option B is the correct answer."
  },
  {
    "number": 60,
    "chapter": 4,
    "question": "Given the following application, which specific type of exception will be printed in the stack \ntrace at runtime?\npackage carnival;\npublic class WhackAnException {\n   public static void main(String... hammer) {\n      try {\n         throw new ClassCastException();\n      } catch (IllegalArgumentException e) {\n         throw new IllegalArgumentException();\n      } catch (RuntimeException e) {\n         throw new NullPointerException();\n      } finally {\n         throw new RuntimeException();\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "ClassCastException",
      "IllegalArgumentException",
      "NullPointerException",
      "RuntimeException",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "For this question, notice that all the exceptions thrown or caught are unchecked \nexceptions. First, the ClassCastException is thrown in the try block and caught  \nby the second catch block, since it inherits from RuntimeException, not  \nIllegal ArgumentException. Next, a NullPointerException is thrown, but  \nbefore it can be returned the finally block is executed and a RuntimeException \nreplaces it. The application exits, and the caller sees the RuntimeException in the  \nstack trace, making option D the correct answer. If the finally block did not throw any \nexceptions, then NullPointerException would be printed at runtime."
  },
  {
    "number": 1,
    "chapter": 5,
    "question": "What is the output of the following?\nList\u003cString\u003e museums \u003d new ArrayList\u003c\u003e(1);\nmuseums.add(\"Natural History\");\nmuseums.add(\"Science\");\nmuseums.add(\"Art\");\nmuseums.remove(2);\nSystem.out.println(museums);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "[Natural History, Science]",
      "[Natural History, Art, Science]",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "While the ArrayList is declared with an initial capacity of one element, it is free to\nexpand as more elements are added. Each of the three calls to the add() method adds an \nelement to the end of the ArrayList. The remove() method call deletes the element at \nindex 2, which is Art. Therefore, option A is correct."
  },
  {
    "number": 2,
    "chapter": 5,
    "question": "How many of the following are legal declarations?\n[]String lions \u003d new String[];\nString[] tigers \u003d new String[1] {\"tiger\"};\nString bears[] \u003d new String[] {};\nString ohMy [] \u003d new String[0] {};",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "The array brackets, [], are not allowed to appear before the type, making the lions\ndeclaration incorrect. When using an array initializer with braces, {}, you are not allowed \nto specify the size separately. The size is inferred from the number of elements listed. There-\nfore, tigers and ohMy are incorrect. When you’re not using an array initializer, the \nsize is required. An empty array initializer is allowed. Option B is correct because only \nbears is legal."
  },
  {
    "number": 3,
    "chapter": 5,
    "question": "Which of the following can fill in the blank to make the code compile?\npublic class News\u003c \u003e {}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "? only",
      "N only",
      "? and N",
      "News, and Object",
      "N, News, and Object",
      "None of the above"
    ],
    "explanation": "When declaring a class that uses generics, you must specify a name for the formal type\nparameter. Java uses the standard rules for naming a variable or class. A question mark is not \nallowed in a variable name, making options A and C incorrect. While it is common practice \nto use a single uppercase letter for the type parameter, this is not required. It certainly isn’t a \ngood idea to use existing class names like the News class being declared here or the Object \nclass built into Java. However, both are allowed, making option E the answer."
  },
  {
    "number": 4,
    "chapter": 5,
    "question": "What is true of this code? (Choose two.)\n26: List\u003cString\u003e strings \u003d new ArrayList\u003c?\u003e();\n27: var ints \u003d new HashSet\u003cInteger\u003e();\n28: Double dbl \u003d 5.0;\n29: ints.add(2);\n30: ints.add(null);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "The code compiles as is.",
      "One line needs to be removed for the code to compile.",
      "Two lines need to be removed for the code to compile.",
      "One line of code uses autoboxing.",
      "Two lines of code use autoboxing.",
      "Three lines of code use autoboxing."
    ],
    "explanation": "Option B is one answer because line 26 does not compile. The ? wildcard cannot be\nused when instantiating a type on the right side of the assignment operator. The other lines \ndo compile. Additionally, option E is correct because lines 28 and 29 use autoboxing. They \nconvert a primitive to a wrapper object, in this case Double and Integer, respectively. Line \n30 is correct and does not use autoboxing. It places a null reference as the Integer object."
  },
  {
    "number": 5,
    "chapter": 5,
    "question": "Which of the following creates an empty two-dimensional array with dimensions 2×2?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "int[][] blue \u003d new int[2, 2];",
      "int[][] blue \u003d new int[2], [2];",
      "int[][] blue \u003d new int[2][2];",
      "int[][] blue \u003d new int[2 x 2];",
      "None of the above"
    ],
    "explanation": "A two-dimensional array is declared by listing both sizes in separate pairs of brackets, [].\nOption C correctly shows this syntax."
  },
  {
    "number": 6,
    "chapter": 5,
    "question": "What is the output of the following?\nvar q \u003d new ArrayDeque\u003cString\u003e();\nq.offer(\"snowball\");\nq.offer(\"minnie\");\nq.offer(\"sugar\");\n                \nSystem.out.println(q.peek() + \" \" + q.peek() + \" \" + q.size());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "sugar sugar 3",
      "sugar minnie 1",
      "snowball minnie 1",
      "snowball snowball 3",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The offer() method inserts an element at the end of the queue. This means the queue\ncontains [snowball, minnie, sugar]. The peek() method returns the element at the \nfront of the queue without removing it. Therefore, snowball is printed twice, but the queue \nremains with three elements. This matches option  D ."
  },
  {
    "number": 7,
    "chapter": 5,
    "question": "We are running a library. Patrons select books by name. They get at the back of the checkout \nline. When they get to the front, they scan the book’s ISBN, a unique identification number. \nThe checkout system finds the book based on this number and marks the book as checked \nout. Of these choices, which data structures best represent the line to check out the book and \nthe book lookup to mark it as checked out, respectively?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "ArrayList, HashSet",
      "ArrayList, TreeMap",
      "ArrayList, TreeSet",
      "LinkedList, HashSet",
      "LinkedList, TreeMap",
      "LinkedList, TreeSet"
    ],
    "explanation": "Notice how there is unnecessary information in this description. The fact that patrons\nselect books by name is irrelevant. The checkout line is a perfect example of a Queue. \nWe need easy access to one end of the Queue for patrons to add themselves to the queue. \nWe also need easy access for patrons to get off the queue when it is their turn. Since a \nLinkedList is a Queue, this narrows down the answer to options D, E, and  F .\nThe book lookup by ISBN is a lookup by key. We need a map for this. A HashMap is prob-\nably better here, but it isn’t a choice. So the answer is option E, which does include both a \nQueue and a Map."
  },
  {
    "number": 8,
    "chapter": 5,
    "question": "What is the result of running the following program?\n1:  package fun;\n2:  public class Sudoku {\n3:     static int[][] game;\n4:\n5:     public static void main(String[] args) {\n6:        game[3][3] \u003d 6;\n7:        Object[] obj \u003d game;\n8:        game[3][3] \u003d \"X\";\n9:        System.out.println(game[3][3]);\n10:    }\n11: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "X",
      "The code does not compile.",
      "The code compiles but throws a NullPointerException at runtime.",
      "The code compiles but throws a different exception at runtime."
    ],
    "explanation": "Line 8 attempts to store a String in an array meant for an int. Line 8 does not compile,\nand option B is correct."
  },
  {
    "number": 9,
    "chapter": 5,
    "question": "Suppose we want to implement a Comparator\u003cString\u003e so that it sorts the longest strings \nfirst. You may assume there are no null values. Which method could implement such a \ncomparator?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "public int compare(String s1, String s2) {\n   return s1.length() - s2.length();\n}",
      "public int compare(String s1, String s2) {\n   return s2.length() – s1.length();\n}",
      "public int compare(Object obj1, Object obj2) {\n   String s1 \u003d (String) obj1;\n   String s2 \u003d (String) obj2;\n   return s1.length() - s2.length();\n}",
      "public int compare(Object obj1, Object obj2) {\n   String s1 \u003d (String) obj1;\n   String s2 \u003d (String) obj2;\n   return s2.length() – s1.length();\n}",
      "None of the above"
    ],
    "explanation": "Options C and D are incorrect because the method signature is incorrect. Unlike the\nequals() method, the method in Comparator\u003cString\u003e takes the type being compared \nas the parameters when using generics. Option A is a valid Comparator\u003cString\u003e. How-\never, it sorts in ascending order by length. Option B is correct. If s1 is three characters and \ns2 is one character, it returns -2 .  The negative value says that s1 should sort first, which is \ncorrect, because we want the longest String first."
  },
  {
    "number": 10,
    "chapter": 5,
    "question": "How many lines does the following code output?\nvar days \u003d new String[] { \"Sunday\", \"Monday\", \"Tuesday\",\n   \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\n \nfor (int i \u003d 1; i \u003c days.length; i++)\n      System.out.println(days[i]);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Zero.",
      "Six.",
      "Seven.",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "In Java, arrays are indexed starting with 0. While it is unusual for the loop to start with 1,\nthis does not cause an error. It does cause the code to output six lines instead of seven, since \nthe loop doesn’t cover the first array element. Therefore, option B is correct."
  },
  {
    "number": 11,
    "chapter": 5,
    "question": "Which cannot fill in the blank for this code to compile?\nvar c \u003d new \u003cString\u003e();\nc.add(\"pen\");\nc.remove(\"pen\");\nSystem.out.println(c.isEmpty());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "ArrayList",
      "LinkedList",
      "TreeMap",
      "TreeSet",
      "All of these can fill in the blank."
    ],
    "explanation": "Java talks about the collections framework, but the Map interface does not actually \nimplement the Collection interface. TreeMap has different methods than the other \noptions. It cannot fill in the blank, so option C is correct."
  },
  {
    "number": 12,
    "chapter": 5,
    "question": "What is true of the following code? (Choose two.)\nprivate static void sortAndSearch(String... args) {\n   var one \u003d args[0];\n   Arrays.sort(args);\n    result \u003d Arrays.binarySearch(args, one);\n   System.out.println(result);\n}\npublic static void main(String[] args) {\n   sortAndSearch(\"seed\", \"flower\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "If the blank contains int, then the code outputs 0.",
      "If the blank contains int, then the code outputs 1.",
      "If the blank contains int, then the does not compile.",
      "If the blank contains String, then the code outputs flower.",
      "If the blank contains String, then the code outputs seed.",
      "If the blank contains String, then the code does not compile."
    ],
    "explanation": "In Java, Arrays.binarySearch() returns a positive int, representing the index of a\nmatch if one is found. An int cannot be stored in a String variable, making option F one \nof the answers. When using the correct data type and searching for seed, we find it at index \n1 .  Therefore, option B is the other correct answer."
  },
  {
    "number": 13,
    "chapter": 5,
    "question": "How many of the following are legal declarations?\npublic void greek() {\n   [][]String alpha;\n   []String beta;\n   String[][] gamma;\n   String[] delta[];\n   String epsilon[][];\n   var[][] zeta;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One",
      "Two",
      "Three",
      "Four",
      "Five",
      "Six"
    ],
    "explanation": "As with a one-dimensional array, the brackets, [], must be after the type, making alpha\nand beta illegal declarations. For a multidimensional array, the brackets may be before  \nand/or after the variable name. They do not need to be in the same place. Therefore, gamma,\ndelta, and epsilon are correct. Finally, var can be used as a local variable, but not with \narray brackets after it. The code would compile if it said var zeta. Since three options are \ncorrect, the answer is option  C ."
  },
  {
    "number": 14,
    "chapter": 5,
    "question": "What is the result of the following?\nvar list \u003d new ArrayList\u003cInteger\u003e();\nlist.add(56);\nlist.add(56);\nlist.add(3);\nvar set \u003d new TreeSet\u003cInteger\u003e(list);\nSystem.out.print(set.size());\nSystem.out.print(\" \" );\nSystem.out.print(set.iterator().next());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "2 3",
      "2 56",
      "3 3",
      "3 56",
      "None of the above"
    ],
    "explanation": "First the code creates an ArrayList of three elements. Then the list is transformed into\na TreeSet. Since sets are not allowed to have duplicates, the set only has two elements. \nRemember that a TreeSet is sorted, which means that the first element in the TreeSet is \n3 .  Therefore, option A is correct."
  },
  {
    "number": 15,
    "chapter": 5,
    "question": "What is true of the code when run as java Copier.java? (Choose two.)\n1:  import java.util.Arrays;\n2:\n3:  public class Copier {\n4:     public static void main(String... original) {\n5:        String... copy \u003d original;\n6:        Arrays.linearSort(original);\n7:        Arrays.search(original, \"\");\n8:        System.out.println(original.size() \n9:           + \" \" + original[0]);\n10:    }\n11: }\n ",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "One line contains a compiler error.",
      "Two lines contain a compiler error.",
      "Three lines contain a compiler error.",
      "Four lines contain a compiler error.",
      "If the compiler errors were fixed, the code would throw an exception.",
      "If the compiler errors were fixed, the code would run successfully."
    ],
    "explanation": "Three dots in a row is a varargs parameter. While varargs is used like an array \nfrom within the method, it can only be used as a method parameter. This syntax is \nnot allowed for a variable, causing a compiler error on line 5 .  Line 6 does not compile \nbecause linearSort() should be sort(). On line 7, the method name is also incor-\nrect. The search() should be binarySearch(). Finally, line 9 uses size() instead of \nlength. Since there are four errors, option D is correct. If all these errors were corrected, \noriginal[0] would cause an exception because the array is empty. Therefore, option E is \nalso correct."
  },
  {
    "number": 16,
    "chapter": 5,
    "question": "What is the output of the following? (Choose three.)\n20: var chars \u003d new \u003cCharacter\u003e();\n21: chars.add(\u0027a\u0027);\n22: chars.add(Character.valueOf(\u0027b\u0027));\n23: chars.set(1, \u0027c\u0027);\n24: chars.remove(0);\n25: System.out.print(chars.size() + \" \" + chars.contains(\u0027b\u0027));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      5
    ],
    "userAnswers": [
      0,
      3,
      5
    ],
    "options": [
      "When inserting ArrayList into the blank, the code prints 1 false.",
      "When inserting ArrayList into the blank, the code does not compile.",
      "When inserting HashMap into the blank, the code prints 1 false.",
      "When inserting HashMap into the blank, the code does not compile.",
      "When inserting HashSet into the blank, the code prints 1 false.",
      "When inserting HashSet into the blank, the code does not compile."
    ],
    "explanation": "Line 20 does not compile for a Map because it requires two generic types. Line 23\ndoes not compile for a Set because the elements are unordered and do not have an index. \nThis makes options D and F correct. Additionally, option A is correct because line 23 replaces \nthe second element with a new value, making chars contain [a, c]. Then line 24 removes \nthe first element, making it just [c]. There is only one element, but it is not the value b."
  },
  {
    "number": 17,
    "chapter": 5,
    "question": "What is the output of the following?\nclass Magazine {\n   private String name;\n   public Magazine(String name) {\n      this.name \u003d name;\n   }\n   public int compareTo(Magazine m) {\n      return name.compareTo(m.name);\n   }\n   public String toString() {\n      return name;\n   }\n}\npublic class Newsstand {\n   public static void main(String[] args) {\n      var set \u003d new TreeSet\u003cMagazine\u003e();\n      set.add(new Magazine(\"highlights\"));\n      set.add(new Magazine(\"Newsweek\"));\n      set.add(new Magazine(\"highlights\"));\n      System.out.println(set.iterator().next());\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "highlights",
      "Newsweek",
      "null",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "The Magazine class doesn’t implement Comparable\u003cMagazine\u003e. It happens to imple\nment the compareTo() method properly, but it is missing actually writing implements \nComparable. Since TreeSet doesn’t look to see if the object can be compared until run-\ntime, this code throws a ClassCastException when TreeSet calls add(), so option E \nis correct."
  },
  {
    "number": 18,
    "chapter": 5,
    "question": "Which is the first line to prevent this code from compiling and running without error?\nchar[][] ticTacToe \u003d new char[3][3];                 // r1\nticTacToe[1][3] \u003d \u0027X\u0027;                               // r2\nticTacToe[2][2] \u003d \u0027X\u0027;\nticTacToe[3][1] \u003d \u0027X\u0027;\nSystem.out.println(ticTacToe.length + \" in a row!\"); // r3",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Line r1",
      "Line r2",
      "Line r3",
      "None of the above"
    ],
    "explanation": "Arrays begin with an index of 0. This array is a 3×3 array, making only indexes 0, 1, and\n2 valid. Line r2 throws an ArrayIndexOutOfBoundsException. Therefore, option B \nis correct."
  },
  {
    "number": 19,
    "chapter": 5,
    "question": "What is the first line with a compiler error?\nclass Mammal {}\nclass Bat extends Mammal {}\nclass Cat extends Mammal {}\nclass Sat {}\n \nclass Fur\u003cT extends Mammal\u003e {    // line R\n \n   void clean() {\n      var bat \u003d new Fur\u003cBat\u003e();  // line S\n      var cat \u003d new Fur\u003cCat\u003e();  // line T\n      var sat \u003d new Fur\u003cSat\u003e();  // line U\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Line R",
      "Line S",
      "Line T",
      "Line U",
      "None of the above"
    ],
    "explanation": "The generic declaration on line R is valid. It sets a constraint on the generic type used\nwhen declaring a Fur object. Lines S and T compile as they meet this constraint. However, \nline U has a problem since Sat does not extend Mammal. Since this line does not compile, \noption D is the answer."
  },
  {
    "number": 20,
    "chapter": 5,
    "question": "What is a possible result of this code?\n17: var nums \u003d new HashSet\u003cLong\u003e();\n18: nums.add((long) Math.min(5, 3));\n19: nums.add(Math.round(3.14));\n20: nums.add((long) Math.pow(4,2));\n21: System.out.println(nums);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "[3]",
      "[16]",
      "[16, 3]",
      "[16, 3, 3]",
      "None of the above"
    ],
    "explanation": "Line 18 puts 3 in nums since it is the smaller value. Since a Set must have unique ele\nments, line 19 does not add another value to nums. Line 20 adds the final value of 16 .  The \nset has a total of two elements, 3 and 16 .  A HashSet does not commit to an output order, \nmaking option C correct."
  },
  {
    "number": 21,
    "chapter": 5,
    "question": "What is the output of the following?\n5: var x \u003d new LinkedList\u003cInteger\u003e();\n6: x.offer(18);\n7: x.offer(5);\n8: x.push(13);\n9: System.out.println(x.poll() + \" \" + x.poll());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "13 5",
      "13 18",
      "18 5",
      "18 13",
      "The code does not compile.",
      "The code compiles, but prints something else."
    ],
    "explanation": "Note that LinkedList is a Deque, or double-ended queue. This lets us add elements at\nboth ends. The offer() method adds an element to the back of the queue. After line 7 com-\npletes, the queue contains 18 and 5 in that order. The push() method adds an element to \nthe front of the queue. How rude! The element 13 pushes past everyone on the line. After line \n8 completes, the queue now contains 13, 18, and 5, in that order. Then we get the first two \nelements from the front, which are 13 and 18, making option B correct."
  },
  {
    "number": 22,
    "chapter": 5,
    "question": "Suppose we want to store JellyBean objects. Which of the following require JellyBean to \nimplement the Comparable interface or create a Comparator to add them to the collection? \n(Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4,
      5
    ],
    "userAnswers": [
      2,
      5
    ],
    "options": [
      "ArrayList",
      "HashMap",
      "HashSet",
      "SortedArray",
      "TreeMap",
      "TreeSet"
    ],
    "explanation": "TreeMap and TreeSet keep track of sort order when you insert elements. TreeMap\nsorts the keys and TreeSet sorts the objects in the set. This makes options E and F correct. \nNote that you have the option of having JellyBean implement Comparable, or you can \npass a Comparator to the constructor of TreeMap or TreeSet. Option D is trying to trick \nyou as SortedArray is not a class or interface in the collections framework."
  },
  {
    "number": 23,
    "chapter": 5,
    "question": "Which of the following references the first and last elements in a nonempty array?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "trains[0] and trains[trains.length]",
      "trains[0] and trains[trains.length - 1]",
      "trains[1] and trains[trains.length]",
      "trains[1] and trains[trains.length - 1]",
      "None of the above"
    ],
    "explanation": "Array indices start with 0, making options C and D incorrect. The length attribute refers\nto the number of elements in an array. It is one past the last valid array index. Therefore, \noption B is correct."
  },
  {
    "number": 24,
    "chapter": 5,
    "question": "Which of the following fills in the blank so this code compiles?\npublic static void throwOne(Collection\u003c \u003e coll) {\n   var iter \u003d coll.iterator();\n   if (iter.hasNext())\n      throw iter.next();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "?",
      "? extends RuntimeException",
      "? super RuntimeException",
      "None of the above"
    ],
    "explanation": "Since the method does not have any declared exceptions, it can only throw unchecked\nexceptions. Option B is the only one that requires the elements of coll to be  \nRuntime Exception or any subclasses."
  },
  {
    "number": 25,
    "chapter": 5,
    "question": "Which of these four array declarations produces a different array than the others?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "int[][] nums \u003d new int[2][1];",
      "int[] nums[] \u003d new int[2][1];",
      "int[] nums[] \u003d new int[][] { { 0 }, { 0 } };",
      "int[] nums[] \u003d new int[][] { { 0, 0 } };"
    ],
    "explanation": "Options A and B show that the brackets, [], can be before or after the variable name and\nproduce the same array. Option C specifies the same array the long way with two arrays of \nlength 1 .  Option D is the answer because it is different than the others. It instead specifies an \narray of length 1 where that element is of length 2 ."
  },
  {
    "number": 26,
    "chapter": 5,
    "question": "What does the following output?\nvar linux \u003d new String[] { \"Linux\", \"Mac\", \"Windows\" };\nvar mac \u003d new String[] { \"Mac\", \"Linux\", \"Windows\" };\n \nvar search \u003d Arrays.binarySearch(linux, \"Linux\");\nvar mismatch1 \u003d Arrays.mismatch(linux, mac);\nvar mismatch2 \u003d Arrays.mismatch(mac, mac);\n \nSystem.out.println(search + \" \" + mismatch1 + \" \" + mismatch2);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "-1 0 -1",
      "-1 -1 0",
      "0 -1 0",
      "0 0 -1",
      "The output is not defined.",
      "The code does not compile."
    ],
    "explanation": "Java requires having a sorted array before calling the binarySearch() method. You do\nnot have to call Arrays.sort to perform the sort, though. This array happens to already be \nsorted, so it meets the precondition. The target string of \"Linux\" is the first element in the \narray. Since Java uses zero-based indexing, search is 0 .  The Arrays.mismatch() method \nreturns -1 if the arrays are the same and returns the index of the first difference if they are \nnot. In our cases, mismatch1 is 0 because the first element differs, and mismatch2 is -1 \nbecause the arrays are the same. This makes option D the correct answer."
  },
  {
    "number": 27,
    "chapter": 5,
    "question": "Which line in the main() method doesn’t compile or points to a class that doesn’t compile?\n1:  interface Comic\u003cC\u003e {\n2:     void draw(C c);\n3:  }\n4:  class ComicClass\u003cC\u003e implements Comic\u003cC\u003e {\n5:     public void draw(C c) {\n6:        System.out.println(c);\n7:     }\n8:  }\n9:  class SnoopyClass implements Comic\u003cSnoopy\u003e {\n10:    public void draw(Snoopy c) {\n11:       System.out.println(c);\n12:    }\n13: }\n14: class SnoopyComic implements Comic\u003cSnoopy\u003e {\n15:    public void draw(C c) {\n16:       System.out.println(c);\n17:    }\n18: }\n19: public class Snoopy {\n20:    public static void main(String[] args) {\n21:       Comic\u003cSnoopy\u003e c1 \u003d c -\u003e System.out.println(c);\n22:       Comic\u003cSnoopy\u003e c2 \u003d new ComicClass\u003c\u003e();\n23:       Comic\u003cSnoopy\u003e c3 \u003d new SnoopyClass();\n24:       Comic\u003cSnoopy\u003e c4 \u003d new SnoopyComic();\n25:    }\n26: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Line 21.",
      "Line 22.",
      "Line 23.",
      "Line 24.",
      "None of the above. All of the code compiles."
    ],
    "explanation": "The Comic\u003cC\u003e interface declares a formal type parameter. This means that a class imple\nmenting it needs to specify this type. The code on line 21 compiles because the lambda refer-\nence supplies the necessary context making option A incorrect. Option B declares a generic \nclass. While this doesn’t tell us the type is Snoopy, it punts the problem to the caller of the \nclass. The declaration of c2 on line 22 compiles because it supplies the type, making option \nB incorrect. The code on line 23 compiles because the SnoopyClass itself supplies the type, \nmaking option C incorrect.\nOption D has a problem. SnoopyClass and SnoopyComic appear similar. However, \nSnoopyComic refers to  C . This type parameter exists in the interface. It isn’t available in the \nclass because the class has said it is using Snoopy as the type. Since the SnoopyComic class \nitself doesn’t compile, the line with c4 can’t instantiate it, and option D is the answer."
  },
  {
    "number": 28,
    "chapter": 5,
    "question": "Fill in the blank to make this code compile:\npublic class Truck implements Comparable\u003cTruck\u003e {\n   private int id;\n   public Truck(int id) {\n      this.id \u003d id;\n   }\n   @Override\n   public int  {\n      return id - t.id;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "compare(Truck t)",
      "compare(Truck t1, Truck t2)",
      "compareTo(Truck t)",
      "compareTo(Truck t1, Truck t2)",
      "None of the above"
    ],
    "explanation": "When implementing Comparable\u003cTruck\u003e, you implement the compareTo() method.\nSince this is an instance method, it already has a reference to itself and only needs the item \nit is comparing. Only one parameter is specified, and option C is correct. By contrast, the \nComparator\u003cTruck\u003e interface uses the compare() method, and the method takes two \nparameters."
  },
  {
    "number": 29,
    "chapter": 5,
    "question": "How many lines does the following code output?\nvar days \u003d new String[] { \"Sunday\", \"Monday\", \"Tuesday\",\n   \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\n \nfor (int i \u003d 0; i \u003c days.length; i++)\n   System.out.println(days[i]);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Six.",
      "Seven.",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "There is nothing wrong or tricky about this code. It correctly creates a seven-element\narray. The loop starts with index 0 and ends with index 6 .  Each line is correctly output. \nTherefore, option B is correct."
  },
  {
    "number": 30,
    "chapter": 5,
    "question": "Which of the following fill in the blank to print out true? (Choose two.)\nString[] array \u003d {\"Natural History\", \"Science\"};\nvar museums \u003d ;\nmuseums.set(0, \"Art\");\nSystem.out.println(museums.contains(\"Art\"));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [
      3,
      4
    ],
    "options": [
      "Arrays.asList(array)",
      "Arrays.asList(\"Natural History, Science\")",
      "List.of(array)",
      "List.of(\"Natural History\", \"Science\")",
      "new ArrayList\u003cString\u003e(\"Natural History\", \"Science\")",
      "new List\u003cString\u003e(\"Natural History\", \"Science\")"
    ],
    "explanation": "Options E and F are incorrect because they do not compile. List is an interface and\ndoes not have a constructor. ArrayList has a constructor but not one that takes individual \nelements as parameters. Options C and D are incorrect because List.of() creates an \nimmutable list. Trying to change one of its values causes an exception at runtime.\nOptions A and B are correct. Since we are creating the list from an array, it is a fixed size. We \nare allowed to change elements. When successfully completing this code, museums is [Art, \nScience] for both solutions."
  },
  {
    "number": 31,
    "chapter": 5,
    "question": "Which option cannot fill in the blank to print Clean socks?\nclass Wash\u003cT\u003e {\n   T item;\n   public void clean(T item) {\n      System.out.println(\"Clean \" + item);\n   }\n}\npublic class LaundryTime {\n   public static void main(String[] args) {\n      \n      wash.clean(\"socks\");\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "var wash \u003d new Wash\u003cString\u003e();",
      "var wash \u003d new Wash\u003c\u003e();",
      "Wash wash \u003d new Wash();",
      "Wash wash \u003d new Wash\u003cString\u003e();",
      "Wash\u003cString\u003e wash \u003d new Wash\u003c\u003e();",
      "All of these can fill in the blank."
    ],
    "explanation": "The Wash class takes a formal type parameter named T. Options A and E show the\nbest ways to call it. These option declare a generic reference type that specifies the type is \nString. Option A uses local variable type inference, whereas option E uses the diamond \nsyntax to avoid redundantly specifying the type of the assignment.\nOptions B, C, and D show that you can omit the generic type in the reference and still  \nhave the code compile. You do get a compiler warning scolding you for having a raw type. \nBut compiler warnings do not prevent compilation. With the raw type, the compiler treats \nT as if it is of type Object. That is OK in this example, because the only method we call \nis toString() implicitly when printing the value. Since toString() is defined on the \nObject class, we are safe, and options B, C, and D work. Since all can fill in the blank, \noption F is the answer."
  },
  {
    "number": 32,
    "chapter": 5,
    "question": "Which of the options in the graphic best represent the blocks variable?\nchar[][] blocks \u003d new char[][] {\n    { \u0027a\u0027, \u0027b\u0027, \u0027c\u0027 }, { \u0027d\u0027 }, { \u0027e\u0027, \u0027f\u0027 } };\nOption A\nblocks blocks\nOption B\nOption C\nblocks blocks\nOption D",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": true,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "",
      "",
      "",
      ""
    ],
    "explanation": "Options A, C, and D represent 3×3 2D arrays. Option B best represents the array in the\ncode. It shows there are three different arrays of different lengths."
  },
  {
    "number": 33,
    "chapter": 5,
    "question": "Fill in the blank so the code prints gamma. (Choose two.)\nvar list \u003d Arrays.asList(\"alpha\", \"beta\", \"gamma\");\nCollections.sort(list, );\nSystem.out.println(list.get(0));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      4,
      1,
      4
    ],
    "options": [
      "(s, t) -\u003e s.compareTo(t)",
      "(s, t) -\u003e t.compareTo(s)",
      "Comparator.comparing((String s) -\u003e s.charAt(0))",
      "Comparator.comparing((String s) -\u003e s.charAt(0)).reverse()",
      "Comparator.comparing((String s) -\u003e s.charAt(0)).reversed()"
    ],
    "explanation": "The goal is to write code that sorts in descending order. Option A sorts ascendingly and\noption B sorts descendingly. Similarly, option C sorts ascendingly and option E sorts descend-\ningly. Option D attempts to call the reverse() method, which is not defined."
  },
  {
    "number": 34,
    "chapter": 5,
    "question": "How many of the following are legal declarations?\nfloat[] lion \u003d new float[];\nfloat[] tiger \u003d new float[1];\nfloat[] bear \u003d new[] float;\nfloat[] ohMy \u003d new[1] float;",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "When creating an array object, a set of elements or size is required. Therefore, lion and\nbear are incorrect. The brackets containing the size are required to be after the type, making \nohMy incorrect. The only one that is correct is tiger, making the correct answer option  B ."
  },
  {
    "number": 35,
    "chapter": 5,
    "question": "Which is the first line of code that causes an ArrayIndexOutOfBoundsException?\nvar matrix \u003d new String[1][2];\nmatrix[0][0] \u003d \"Don\u0027t think you are, know you are.\";      // m1\nmatrix[0][1] \u003d \"I\u0027m trying to free your mind Neo\";        // m2\nmatrix[1][0] \u003d \"Is all around you \";                      // m3\nmatrix[1][1] \u003d \"Why oh why didn\u0027t I take the BLUE pill?\"; // m4",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "m1",
      "m2",
      "m3",
      "m4",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "This code creates a two-dimensional array of size 1×2. Lines m1 and m2 assign values to\nboth elements in the outer array. Line m3 attempts to reference the second element of the \nouter array. Since there is no such position, it throws an exception, and option C is correct."
  },
  {
    "number": 36,
    "chapter": 5,
    "question": "Suppose we have list of type List\u003cInteger\u003e. Which method allows you to pass a List \nand returns an immutable Set containing the same elements?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "List.copyOf(list)",
      "List.of(list)",
      "Set.copyOf(list);",
      "Set.of(list);",
      "None of the above"
    ],
    "explanation": "All four of these return immutable collections. Options B and D take a varargs rather\nthan a List. Option A returns a List, not a Set. Option C meets both our requirements."
  },
  {
    "number": 37,
    "chapter": 5,
    "question": "What does the following output? (Choose two.)\nvar os \u003d new String[] { \"Mac\", \"Linux\", \"Windows\" };\nArrays.sort(os);\n \nSystem.out.println(Arrays.binarySearch(os, \"RedHat\"));\nSystem.out.println(Arrays.binarySearch(os, \"Mac\"));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "-1",
      "-2",
      "-3",
      "0",
      "1",
      "2"
    ],
    "explanation": "The code sorts before calling the binarySearch() method, so it meets the precon\ndition for that method. The target string of \"RedHat\" is not found in the sorted array. If it \nwere found, it would be between the second and third elements. The rule is to take the neg-\native index of where it would be inserted and subtract 1 .  It would need to be inserted as the \nthird element. Since indexes are zero-based, this is index 2 .  We take the negative, which is -2, \nand subtract 1, giving -3 .\nThe target string of \"Mac\" is the second element in the sorted array. Since array indices begin \nwith zero, the second position is index 1 .  This makes the answer options C and  E ."
  },
  {
    "number": 38,
    "chapter": 5,
    "question": "What does the following output?\nvar names \u003d new HashMap\u003cString, String\u003e();\nnames.put(\"peter\", \"pan\");\nnames.put(\"wendy\", \"darling\");\nvar first \u003d names.entrySet();        // line x1\nSystem.out.println(first.getKey());  // line x2",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "peter",
      "wendy",
      "Does not compile due to line x1",
      "Does not compile due to line x2",
      "Does not compile due to another reason",
      "Throws an exception at runtime"
    ],
    "explanation": "Line x1 returns a Set of map entries. Set does not have a getKey() method, so line x2\ndoes not compile, and option D is the answer."
  },
  {
    "number": 39,
    "chapter": 5,
    "question": "Which of these elements are in the output of the following? (Choose three.)\nvar q \u003d new ArrayDeque\u003cString\u003e();\nq.offerFirst(\"snowball\");\nq.offer(\"sugar\");\nq.offerLast(\"minnie\");\n                \nSystem.out.println(q.poll());\nSystem.out.println(q.removeFirst());\nSystem.out.println(q.size());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      3
    ],
    "userAnswers": [
      0,
      2,
      3
    ],
    "options": [
      "sugar",
      "minnie",
      "snowball",
      "1",
      "2",
      "3"
    ],
    "explanation": "The offerLast() and offer() methods insert an element at the back of the\nqueue, while the offerFirst() method inserts the element at the front of the queue.  \nThis means the queue initially contains [snowball, sugar, minnie]. The poll() \nmethod returns the element at the front of the queue and removes it. In this case, it prints \nsnowball, and the queue is reduced from three elements to [sugar, minnie]. Then, the \nremoveFirst() method removes sugar, leaving the queue as only containing [minnie]. \nFurther, the queue becomes one smaller, and 1 is printed. These are options A, C, and  D ."
  },
  {
    "number": 40,
    "chapter": 5,
    "question": "Which of these four pairs of declarations can point to an array that is different from \nthe others?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "int[][][][] nums1a, nums1b;",
      "int[][][] nums2a[], nums2b;",
      "int[][] nums3a[][], nums3b[][];",
      "int[] nums4a[][][], numbs4b[][][];"
    ],
    "explanation": "All of the variables except nums2b point to a 4D array. Don’t create a 4D array in prac\ntice; it’s confusing. The options show that the brackets, [], can be before or after the variable \nin any combination. Option B is the answer because nums2b points to a 3D array. It has only \nthree pairs of brackets before the variable and none after. By comparison, nums2a has three \npairs of brackets before the variable and the fourth pair of brackets after."
  },
  {
    "number": 41,
    "chapter": 5,
    "question": "Which of the following does not behave the same way as the others?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "var set \u003d new HashSet\u003c\u003e();",
      "var set \u003d new HashSet\u003cObject\u003e();",
      "HashSet\u003c\u003e set \u003d new HashSet\u003cObject\u003e();",
      "HashSet\u003cObject\u003e set \u003d new HashSet\u003c\u003e();",
      "HashSet\u003cObject\u003e set \u003d new HashSet\u003cObject\u003e();"
    ],
    "explanation": "Option E is the longest way to specify this code. Options A and D shorten it by using the\ndiamond operator (\u003c\u003e). Options A and B shorten it using var. Option C does not compile \nbecause the diamond operator cannot be used on the left side of the assignment."
  },
  {
    "number": 42,
    "chapter": 5,
    "question": "What is true about the output of the following code?\nvar ints \u003d new int[] {3,1,4};\nvar others \u003d new int[] {2,7,1,8};\nSystem.out.println(Arrays.compare(ints, others));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "It is negative because ints has fewer elements.",
      "It is 0 because the arrays can’t be compared.",
      "It is positive because the first element is larger.",
      "It is undefined.",
      "The code does not compile."
    ],
    "explanation": "The Arrays.compare() method looks at each element in turn. Since the first elements\nare different, we get the result of comparing them. In this case, we get a positive number \nbecause 3 is larger than 2, and option C is correct."
  },
  {
    "number": 43,
    "chapter": 5,
    "question": "Fill in the blank so the code prints beta.\nvar list \u003d List.of(\"alpha\", \"beta\", \"gamma\");\nCollections.sort(list, );\nSystem.out.println(list.get(0));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "(s, t) -\u003e s.compareTo(t)",
      "(s, t) -\u003e t.compareTo(s)",
      "Comparator.comparing(String::length)",
      "Comparator.comparing(String::length).reversed()",
      "None of the above"
    ],
    "explanation": "List.of() makes an immutable list. Attempting to sort throws an exception so option E\nis the answer. If we were calling, Arrays.asList() instead, option C would be the answer \nbecause it is the only option to sort ascendingly by length."
  },
  {
    "number": 44,
    "chapter": 5,
    "question": "How many of these lines have a compiler error?\n20: var list \u003d List.of(\u0027a\u0027, \u0027c\u0027, \u0027e\u0027);\n21: Char letter1 \u003d list.get(0);\n22: char letter2 \u003d list.get(0);\n23: int letter3 \u003d list.get(0);\n24: Integer letter4 \u003d list.get(0);\n25: Object letter5 \u003d list.get(0);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5"
    ],
    "explanation": "Line 20 creates a List\u003cCharacter\u003e. Line 21 does not compile because it is the wrong\ntype. Char should be Character. Line 22 uses unboxing to get a primitive. Line 23 also \ncompiles because Character can be unboxed and widened to int automatically. How-\never, line 24 does not compile as Integer and Character are not in the same class hier-\narchy. The Character value cannot be unboxed, widened to int, and then autoboxed as \nInteger. Finally, line 25 is correct as Character is a subclass of Object. Since two lines \nof code fail to compile, option C is the answer."
  },
  {
    "number": 45,
    "chapter": 5,
    "question": "How many dimensions does the array reference moreBools allow?\nboolean[][] bools[], moreBools;",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "One dimension",
      "Two dimensions",
      "Three dimensions",
      "None of the above"
    ],
    "explanation": "This one is tricky since the array brackets, [], are split up. This means that bools is a \n3D array reference. The brackets both before and after the variable name count. For  \nmoreBools, it is only a 2D array reference because there are only two pairs of brackets \nnext to the type. In other words, boolean[][] applies to both variables. Then bools gets \nanother dimension from the brackets right after the variable name. However, moreBools \nstays at 2D, making option B correct."
  },
  {
    "number": 46,
    "chapter": 5,
    "question": "What is the result of the following?\nComparator\u003cInteger\u003e c \u003d (x, y) -\u003e y - x;\nvar ints \u003d Arrays.asList(3, 1, 4);\nCollections.sort(ints, c);\nSystem.out.println(Collections.binarySearch(ints, 1));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "-1",
      "0",
      "-1",
      "The code does not compile.",
      "The result is not defined."
    ],
    "explanation": "A custom sort order is specified using a Comparator to sort in descending order. \nHowever, this Comparator is not passed when searching. When a different sort order is \nused for searching and sorting, the result is undefined. Therefore, option E is correct."
  },
  {
    "number": 47,
    "chapter": 5,
    "question": "Which statement most accurately represents the relationship between searching and sorting \nwith respect to the Arrays class?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "If the array is not sorted, calling Arrays.binarySearch() will be accurate, but\nslower than if it were sorted.",
      "The array does not need to be sorted before calling Arrays.binarySearch() to get\nan accurate result.",
      "The array must be sorted before calling Arrays.binarySearch() to get an accurate result.",
      "None of the above."
    ],
    "explanation": "The binarySearch() method requires a sorted array in order to return a correct result.\nIf the array is not sorted, the results of a binary search are undefined."
  },
  {
    "number": 48,
    "chapter": 5,
    "question": "Which statement is true about the following figure while ensuring the code continues to  \ncompile? (Choose two.)\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "\u003c\u003e can be inserted at positions P and R without making any other changes.",
      "\u003c\u003e can be inserted at positions Q and S without making any other changes.",
      "\u003c\u003e can be inserted at all four positions.",
      "Both variables point to an ArrayList\u003cString\u003e.",
      "Only one variable points to an ArrayList\u003cString\u003e.",
      "Neither variable points to an ArrayList\u003cString\u003e."
    ],
    "explanation": "The \u003c\u003e is known as the diamond operator. Here, it works as a shortcut to avoid\nrepeating the generic type twice for the same declaration. On the right side of the expression, \nthis is a handy shortcut. Java still needs the type on the left side, so there is something to \ninfer. Positions Q and S are on the right side, making option B correct. In this question, the \ngeneric type is never specified, so it is Object. Since it is not String, option F is correct."
  },
  {
    "number": 49,
    "chapter": 5,
    "question": "What is the result of the following when called as java Binary.java? (Choose two.)\n1: import java.util.*;\n2: public class Binary {\n3:\n4:    public static void main(String... args) {\n5:       Arrays.sort(args);\n6:       System.out.println(Arrays.toString(args));\n7:       System.out.println(args[0]);\n8:    } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      0,
      1
    ],
    "options": [
      "null",
      "[]",
      "Binary",
      "The code throws an ArrayIndexOutOfBoundsException.",
      "The code throws a NullPointerException.",
      "The code does not compile."
    ],
    "explanation": "Since no arguments are passed from the command line, this creates an empty \narray. Sorting an empty array is valid and results in an empty array printed on line 6 . \nThen line 7 attempts to access an element of the empty array and throws an \nArrayIndexOut OfBoundsException. Therefore, options B and D are correct."
  },
  {
    "number": 50,
    "chapter": 5,
    "question": "What is the first line with a compiler error?\nclass Mammal {}\nclass Bat extends Mammal {}\nclass Cat extends Mammal {}\nclass Sat {}\n \nclass Fur\u003c? extends Mammal\u003e {    // line R\n \n   void clean() {\n      var bat \u003d new Fur\u003cBat\u003e();  // line S\n      var cat \u003d new Fur\u003cCat\u003e();  // line T\n      var sat \u003d new Fur\u003cSat\u003e();  // line U\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Line R",
      "Line S",
      "Line T",
      "Line U",
      "None of the above"
    ],
    "explanation": "The generic declaration on line R is not valid due to the question mark (?) wildcard.\nWhile a question mark is allowed on the left side of a declaration, it is not allowed when \nspecifying a constraint on a class. Since line R does not compile, option A is the answer."
  },
  {
    "number": 51,
    "chapter": 5,
    "question": "What is the result of running the following program?\n1:  package fun;\n2:  public class Sudoku {\n3:     static int[][] game \u003d new int[6][6];\n4:\n5:     public static void main(String[] args) {\n6:        game[3][3] \u003d 6;\n7:        Object[] obj \u003d game;\n8:        obj[3] \u003d \"X\";\n9:        System.out.println(game[3][3]);\n10:    }\n11: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "6",
      "X",
      "The code does not compile.",
      "The code compiles but throws a NullPointerException at runtime.",
      "The code compiles but throws a different exception at runtime."
    ],
    "explanation": "Line 6 assigns an int to a cell in a 2D array. This is fine. Line 7 casts to a general\nObject[]. This is dangerous, but legal. Why is it dangerous, you ask? That brings us to \nline 8 .  The compiler can’t protect us from assigning a String to the int[] because the ref-\nerence is more generic. Therefore, line 8 throws an ArrayStoreException because the \ntype is incorrect, and option E is correct. You couldn’t have assigned an int on line 8 either \nbecause obj[3] is really an int[] behind the scenes and not an int."
  },
  {
    "number": 52,
    "chapter": 5,
    "question": "How many of these allow inserting null values: ArrayList, LinkedList, HashSet, and TreeSet?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "TreeSet does not allow null values because it needs to compare the values. \nWhile HashSet does call hashCode(), it knows to skip that call if the value is null. \nArrayList and LinkedList do not make method calls on their contents. Three of the \nfour allow inserting null values, making option D the answer."
  },
  {
    "number": 53,
    "chapter": 5,
    "question": "What is the output of the following?\nvar threes \u003d Arrays.asList(\"3\", \"three\", \"THREE\");\nCollections.sort(threes);\nSystem.out.println(threes);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "[3, three, THREE]",
      "[3, THREE, three]",
      "[three, THREE, 3]",
      "[THREE, three, 3]",
      "None of the above"
    ],
    "explanation": "Unfortunately, you do have to memorize two facts about sort order. First, numbers sort\nbefore letters. Second, uppercase sorts before lowercase. Since, the first value is 3 and the last \nis three, option B is correct."
  },
  {
    "number": 54,
    "chapter": 5,
    "question": "How many dimensions does the array reference moreBools allow?\nboolean[][][] bools, moreBools;",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One dimension",
      "Two dimensions",
      "Three dimensions",
      "None of the above"
    ],
    "explanation": "Since the brackets in the declaration are before the variable names, the variable type\nboolean[][][] applies to both variables. Therefore, both bools and moreBools can \nreference a 3D array."
  },
  {
    "number": 55,
    "chapter": 5,
    "question": "What is the output of the following?\n20: List\u003cCharacter\u003e chars \u003d new ArrayList\u003c\u003e();\n21: chars.add(\u0027a\u0027);\n22: chars.add(\u0027b\u0027);\n23: chars.clear();\n24: chars.remove(0);\n25: System.out.print(chars.isEmpty() + \" \" + chars.length());",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "false 0",
      "true 1",
      "2",
      "The code does not compile.",
      "The code throws an exception at runtime."
    ],
    "explanation": "Line 25 does not compile, making option D the answer. On an ArrayList, the method\nto get the number of elements is size(). The length() method is used for a String or \nStringBuilder. If this were fixed, the answer would be option E .   Line 23 empties the \nArrayList. Then line 24 attempts to access an index that is not present."
  },
  {
    "number": 56,
    "chapter": 5,
    "question": "Which fills in the blank in the method signature to allow this code to compile?\nimport java.util.*;\npublic class ExtendingGenerics {\n   private static \u003c  , U\u003e U add(T list, U element) {\n      list.add(element);\n      return element;\n   }\n   public static void main(String[] args) {\n      var values \u003d new ArrayList\u003cString\u003e();\n      add(values, \"duck\");\n      add(values, \"duck\");\n      add(values, \"goose\");\n      System.out.println(values);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "? extends Collection\u003cU\u003e",
      "? implements Collection\u003cU\u003e",
      "T extends Collection\u003cU\u003e",
      "T implements Collection\u003cU\u003e",
      "None of the above"
    ],
    "explanation": "The ? is an unbounded wildcard. It is used in variable references but is not allowed in\ndeclarations. In a static method, the type parameter specified inside the \u003c\u003e is used in the \nrest of the method declaration. Since it needs an actual name, options A and B are incorrect. \nWe need to specify a type constraint so we can call the add() method. Regardless of whether \nthe type is a class or interface, Java uses the extends keyword for generics. Therefore, \noption D is incorrect, and option C is the answer."
  },
  {
    "number": 57,
    "chapter": 5,
    "question": "What does the following output?\nString[] os \u003d new String[] { \"Mac\", \"Linux\", \"Windows\" };\nSystem.out.println(Arrays.binarySearch(os, \"Linux\"));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "0",
      "1",
      "2",
      "The output is not defined."
    ],
    "explanation": "Java requires having a sorted array before calling the binarySearch() method. Since\nthe array is not sorted, the result is undefined, and option D is correct. It may happen that \nyou get 1 as the result, but this behavior is not guaranteed. You need to know for the exam \nthat this is undefined even if you happen to get the “right” answer."
  },
  {
    "number": 58,
    "chapter": 5,
    "question": "Which is the first line to prevent this code from compiling and running without error?\nchar[][] ticTacToe \u003d new char[3,3];                  // r1\nticTacToe[1][3] \u003d \u0027X\u0027;                               // r2\nticTacToe[2][2] \u003d \u0027X\u0027;\nticTacToe[3][1] \u003d \u0027X\u0027;\nSystem.out.println(ticTacToe.length + \" in a row!\"); // r3",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Line r1",
      "Line r2",
      "Line r3",
      "None of the above"
    ],
    "explanation": "A multidimensional array is created with multiple sets of size parameters. The first line\nshould be char[] ticTacToe \u003d new char[3][3];. Therefore, option A is the answer."
  },
  {
    "number": 59,
    "chapter": 5,
    "question": "What is the result of the following?\nvar list \u003d new ArrayList\u003cString\u003e();\nlist.add(\"Austin\");\nlist.add(\"Boston\");\nlist.add(\"San Francisco\");\nlist.removeIf(a -\u003e a.length() \u003e 10);\nSystem.out.println(list.size());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "1",
      "2",
      "3",
      "None of the above"
    ],
    "explanation": "On a stream, the filter() method only keeps values matching the lambda. The\nremoveIf() does the reverse on a Collection and keeps the elements that do not match. \nIn this case, that is Austin and Boston, so option B is correct."
  },
  {
    "number": 60,
    "chapter": 5,
    "question": "What happens when calling the following method with a non-null and non-empty array?\npublic static void addStationName(String[] names) {\n   names[names.length] \u003d \"Times Square\";\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "It adds an element to the array the value of which is Times Square.",
      "It replaces the last element in the array with the value Times Square.",
      "It does not compile.",
      "It throws an exception.",
      "None of the above."
    ],
    "explanation": "The names.length value is the number of elements in the array. The last valid index in\nthe array is one less than names.length. In Java, arrays do not resize automatically. There-\nfore, the code throws an ArrayIndexOutOfBoundsException, and option D is correct."
  },
  {
    "number": 61,
    "chapter": 5,
    "question": "Which is not a true statement about an array?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "An array expands automatically when it is full.",
      "An array is allowed to contain duplicate values.",
      "An array understands the concept of ordered elements.",
      "An array uses a zero index to reference the first element."
    ],
    "explanation": "An ArrayList expands automatically when it is full. An array does not, making option\nA the answer. The other three statements are true of both an array and an ArrayList."
  },
  {
    "number": 62,
    "chapter": 5,
    "question": "Which of the following cannot fill in the blank to make the code compile?\nprivate void output( \u003c?\u003e x) {\n   x.forEach(System.out::println);\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Collection",
      "LinkedList",
      "TreeMap",
      "None of these can fill in the blank.",
      "All of these can fill in the blank."
    ],
    "explanation": "The forEach() method that takes one parameter is defined on the Collection inter\nface allowing options A and B to fill in the blank. Option C requires you to notice that only \none generic parameter is passed. A Map needs two parameters, so option C is the answer."
  },
  {
    "number": 63,
    "chapter": 5,
    "question": "Which of the following fills in the blank so this code compiles?\npublic static void getExceptions(Collection\u003c \u003e coll) {\n   coll.add(new RuntimeException());\n   coll.add(new Exception());\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "?",
      "? extends RuntimeException",
      "? super RuntimeException",
      "None of the above"
    ],
    "explanation": "Option A is incorrect because coll could be any type, which doesn’t necessarily allow\nexceptions to be added. Option B is incorrect because neither add() method compiles. We \ncould have Collection\u003cIllegalStateException\u003e as a parameter. That would not \nallow either type to be added. Finally, option C is incorrect as the second add() method \ndoes not compile because broader types than the generic allows are a problem when adding \nto coll. Therefore, option D is the answer."
  },
  {
    "number": 64,
    "chapter": 5,
    "question": "What is the output of the following? (Choose two.)\n35: var mags \u003d new HashMap\u003cString, Integer\u003e();\n36: mags.put(\"People\", 1974);\n37: mags.put(\"Readers Digest\", 1922);\n38: mags.put(\"The Economist\", 1843);\n39:\n40: Collection\u003cInteger\u003e years \u003d mags.values();\n41:\n42: List\u003cInteger\u003e sorted \u003d new ArrayList\u003c\u003e(years);\n43: Collections.sort(sorted);\n44:\n45: int first \u003d sorted.get(0);\n46: System.out.println(first);\n47:\n48: Integer last \u003d sorted.get(sorted.size());\n49: System.out.println(last);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "1843",
      "1922",
      "1974",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "Lines 35–38 create a Map with three key/value pairs. Lines 40–43 sort just the values\nascendingly by year. Lines 45 and 48 show you can assign the Integer values to an int \nvia unboxing or an Integer directly. Line 46 shows the values are properly sorted, making \noption A correct. Finally, line 48 throws an exception because sorted.size() returns 3 \nand the maximum index in the List is 2 .  This makes option D correct as well."
  },
  {
    "number": 65,
    "chapter": 5,
    "question": "How do you access the array element with the value of \"z\"?\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "dimensions[\"three\"][2]",
      "dimensions[\"three\"][3]",
      "dimensions[2][2]",
      "dimensions[3][3]"
    ],
    "explanation": "Arrays are indexed using numbers, not strings, making options A and B incorrect. Since\narray indexes are zero-based, option C is the answer."
  },
  {
    "number": 66,
    "chapter": 5,
    "question": "What is the output of the following?\nclass Magazine implements Comparable\u003cMagazine\u003e {\n   private String name;\n   public Magazine(String name) {\n      this.name \u003d name;\n   }\n   @Override\n   public int compareTo(Magazine m) {\n      return name.compareTo(m.name);\n   }\n   @Override\n   public String toString() {\n      return name;\n   }\n}\npublic class Newsstand {\n   public static void main(String[] args) {\n      var set \u003d new TreeSet\u003cMagazine\u003e();\n      set.add(new Magazine(\"highlights\"));\n      set.add(new Magazine(\"Newsweek\"));\n      set.add(new Magazine(\"highlights\"));\n      System.out.println(set.iterator().next());\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "highlights",
      "Newsweek",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "This code shows a proper implementation of Comparable. It has the correct method\nsignature. It compares the magazine names in alphabetical order. Remember that upper-\ncase letters sort before lowercase letters. Since Newsweek starts with uppercase, option B \nis correct."
  },
  {
    "number": 67,
    "chapter": 5,
    "question": "Which options can fill in the blanks to print Cleaned 2 items?\nimport java.util.*;\nclass Wash\u003cT  Collection\u003e {\n   T item;\n   public void clean(T items) {\n      System.out.println(\"Cleaned \" + items.size() + \" items\");\n   }\n}\npublic class LaundryTime {\n   public static void main(String[] args) {\n      Wash\u003cList\u003e wash \u003d new Wash\u003c \u003e();\n      wash.clean(List.of(\"sock\", \"tie\"));\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "extends, ArrayList",
      "extends, List",
      "super, ArrayList",
      "super, List",
      "None of the above"
    ],
    "explanation": "Options A and C are incorrect because a generic type cannot be assigned to another direct\ntype unless you are using upper or lower bounds in that statement. Now, we just have to \ndecide whether a lower or upper bound is correct for the T formal type parameter in Wash. \nThe clue is that the method calls size(). This method is available on Collection, and all \nclasses that extend/implement it. Therefore, option B is correct."
  },
  {
    "number": 68,
    "chapter": 5,
    "question": "How many lines does the following code output?\nvar days \u003d new String[] { \"Sunday\", \"Monday\", \"Tuesday\",\n   \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\nfor (int i \u003d 1; i \u003c\u003d days.length; i++)\n   System.out.println(days[i]);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Six.",
      "Seven.",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "In Java, arrays are indexed starting with 0. While it is unusual for the loop to start with 1\nthis does not cause an error. What does cause an error is the loop ending at data.length, \nbecause the \u003c\u003d operator is used instead of the \u003c operator. The last loop index is 6, not 7 .  On \nthe last iteration of the loop, the code throws an ArrayIndexOutOfBoundsException. \nTherefore, option D is correct."
  },
  {
    "number": 69,
    "chapter": 5,
    "question": "What is the output of the following?\nvar listing \u003d new String[][] {\n    { \"Book\" }, { \"Game\", \"29.99\" } };\nSystem.out.println(listing.length + \" \" + listing[0].length);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "1 2",
      "2 1",
      "2 2",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "This array has two elements, making listing.length output 2. While each array\nelement does not have the same size, this does not matter because we are only looking at the \nfirst element. The first element has one. This makes the answer option  B ."
  },
  {
    "number": 70,
    "chapter": 5,
    "question": "What is the output of the following?\nQueue\u003cString\u003e q \u003d new ArrayDeque\u003c\u003e();\nq.add(\"snowball\");\nq.addLast(\"sugar\");\nq.addFirst(\"minnie\");\n                                 \nSystem.out.println(q.peek() + \" \" + q.peek() + \" \" + q.size());",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "sugar sugar 3",
      "sugar minnie 1",
      "minnie minnie 3",
      "minnie snowball 1",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The addFirst() and addLast() methods are on the Deque interface. While \nArray Deque does implement this interface, it also implements Queue. Since the q variable \nis of type Queue, these methods do not compile, and option E is the answer. If the correct \ninterface were used, minnie minnie 3 would be printed."
  },
  {
    "number": 71,
    "chapter": 5,
    "question": "What is the result of the following?\n13: var numbers \u003d Arrays.asList(3, 1, 4);\n14: numbers.set(1, null);\n15: int first \u003d numbers.get(0);\n16: int middle \u003d numbers.get(1);\n17: int last \u003d numbers.get(3);\n18: System.out.println(first + \" \" + middle + \" \" + last);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The code does not compile.",
      "Line 14 throws an exception.",
      "Line 15 throws an exception.",
      "Line 16 throws an exception.",
      "Line 17 throws an exception.",
      "3null4"
    ],
    "explanation": "The code does compile, making option A incorrect. Line 13 creates a fixed-size list. While\nwe are using var, the type is List\u003cInteger\u003e. Line 14 successfully changes the contents of \nthe list to [3, null, 4]. Line 15 automatically unboxes to the primitive 3 .  Line 16 has \na problem. The list has a null value at index 1 .  This cannot be unboxed to a primitive and \nthrows a NullPointerException. Therefore, option D is the answer. If line 16 were com-\nmented out, line 17 would have thrown an exception because Java uses zero based indexes, \nand there is no element at index 3 ."
  },
  {
    "number": 72,
    "chapter": 5,
    "question": "Fill in the blank so the code prints gamma.\nvar list \u003d Arrays.asList(\"alpha\", \"beta\", \"gamma\");\nCollections.sort(list, );\nSystem.out.println(list.get(0));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Comparator.comparing(String::length)\n   .andCompare(s -\u003e s.charAt(0))",
      "Comparator.comparing(String::length)\n   .thenCompare(s -\u003e s.charAt(0))",
      "Comparator.comparing(String::length)\n   .thenComparing(s -\u003e s.charAt(0))",
      "Comparator.comparing(String::length)\n   .andCompare(s -\u003e s.charAt(0))\n   .reversed()",
      "Comparator.comparing(String::length)\n   .thenCompare(s -\u003e s.charAt(0))\n   .reversed()",
      "Comparator.comparing(String::length)\n   .thenComparing(s -\u003e s.charAt(0))\n   .reversed()"
    ],
    "explanation": "We need to first sort descendingly and then ascendingly by first character. Options A, B,\nand C are missing the logic to sort descendingly. Options D and E call the andCompare() \nand thenCompare() methods, which do not exist. Option F is correct."
  },
  {
    "number": 73,
    "chapter": 5,
    "question": "What is the output of the following when run as java FirstName Wolfie? \n(Choose two.)\npublic class FirstName {\n   public static void main(String... names) {\n      System.out.println(names[0]);\n      System.out.println(names[1]);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2
    ],
    "userAnswers": [
      1,
      2
    ],
    "options": [
      "FirstName",
      "Wolfie",
      "The code throws an ArrayIndexOutOfBoundsException.",
      "The code throws a NullPointerException.",
      "The code throws a different exception."
    ],
    "explanation": "Array indexes begin with zero. FirstName is the name of the class, not an argument.\nThe first argument is Wolfie, making option B correct. There is not a second argument, and \nthe array is of size 1, so option C is also correct."
  },
  {
    "number": 74,
    "chapter": 5,
    "question": "What does the following output?\n11: var pennies \u003d new ArrayList\u003c\u003e();\n12: pennies.add(1);\n13: pennies.add(2);\n14: pennies.add(Integer.valueOf(3));\n15: pennies.add(Integer.valueOf(4));\n16: pennies.remove(2);\n17: pennies.remove(Integer.valueOf(1));\n18: System.out.println(pennies);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "[1, 2]",
      "[1, 4]",
      "[2, 4]",
      "[2, 3]",
      "[3, 4]",
      "The code does not compile."
    ],
    "explanation": "This one is tricky. Line 11 creates an ArrayList with a generic type Object rather than\nInteger. This is allowed since we aren’t trying to assign any of the values to an int or \nInteger after getting them from pennies. This gives us the list [1, 2, 3, 4].\nThe next trick is that there are two remove() methods available on ArrayList. One \nremoves an element by index and takes an int parameter. The other removes an element by \nvalue and takes an Object. On line 16, the int primitive is a better match, and the element \nwith index 2 is removed, which is the value of 3 .  At this point, we have [1, 2, 4].\nThen on line 17, the other remove() method is called because we are explicitly using the \nwrapper object. This deletes the object that is equal to 1, and now we have [2, 4]. This \nbrings us to option C as the answer."
  },
  {
    "number": 75,
    "chapter": 5,
    "question": "What is true of the following code? (Choose two.)\nprivate static void sortAndSearch(String... args) {\n   var one \u003d args[1];\n   Comparator\u003cString\u003e comp \u003d (x, y) -\u003e ;\n   Arrays.sort(args, comp);\n   var result \u003d Arrays.binarySearch(args, one, comp);\n   System.out.println(result);\n}\npublic static void main(String[] args) {\n   sortAndSearch(\"seed\", \"flower\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "If the blank contains -x.compareTo(y), then the code outputs 0.",
      "If the blank contains -x.compareTo(y), then the code outputs -1.",
      "If the blank contains x.compareTo(y), then the code outputs 0.",
      "If the blank contains -y.compareTo(x), then the code outputs 0.",
      "If the blank contains -y.compareTo(x), then the code outputs -1.",
      "If the blank contains y.compareTo(x), then the code outputs 0."
    ],
    "explanation": "The code will output 0 when the array is sorted in ascending order since flower\nwill be first. Option C is the most straightforward way of doing this, making it one of the \nanswers. Reversing the order of the variables or adding a negative sign sorts in descending \norder makes options A, B, E, F, and G incorrect. Doing both is a complicated way of sorting \nin ascending order, making option D the other correct answer."
  },
  {
    "number": 76,
    "chapter": 5,
    "question": "What does this code output?\nString[] nums \u003d new String[] { \"1\", \"9\", \"10\" };\nArrays.sort(nums);\nSystem.out.println(Arrays.toString(nums));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "[1, 9, 10]",
      "[1, 10, 9]",
      "[9, 1, 10]",
      "[9, 10, 1]",
      "[10, 1, 9]",
      "[10, 9, 1]"
    ],
    "explanation": "The elements of the array are of type String rather than int. Therefore, we use alpha\nbetical order when sorting. The character 1 sorts before the character 9, alphabetically mak-\ning option A incorrect. Shorter strings sort before longer strings when all the other characters \nare the same, making option B the answer."
  },
  {
    "number": 77,
    "chapter": 5,
    "question": "Which is the first line to prevent this code from compiling and running without error?\nchar[][] ticTacToe \u003d new char[3][3];                 // r1\nticTacToe[0][0] \u003d \u0027X\u0027;                               // r2\nticTacToe[1][1] \u003d \u0027X\u0027;\nticTacToe[2][2] \u003d \u0027X\u0027;\nSystem.out.println(ticTacToe.length + \" in a row!\"); // r3",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Line r1",
      "Line r2",
      "Line r3",
      "None of the above"
    ],
    "explanation": "This code is correct. Line r1 correctly creates a 2D array. The next three lines correctly\nassign a value to an array element. Line r3 correctly outputs 3 in a row!"
  },
  {
    "number": 78,
    "chapter": 5,
    "question": "What is true of the following code? (Choose three.)\n36: var names \u003d new HashMap\u003cString, String\u003e();\n37: names.put(\"peter\", \"pan\");\n38: names.put(\"wendy\", \"darling\");\n39:\n40: String w \u003d names.getOrDefault(\"peter\");\n41: String x \u003d names.getOrDefault(\"peter\", \"x\");\n42: String y \u003d names.getOrDefault(\"john\", \"x\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      5
    ],
    "userAnswers": [
      0,
      3,
      5
    ],
    "options": [
      "One line does not compile.",
      "Two lines do not compile.",
      "If any lines that do not compile are removed, the String on line 40 is set to null.",
      "If any lines that do not compile are removed, the String on line 41 is set to \"pan\".",
      "If any lines that do not compile are removed, the String on line 41 is set to \"x\".",
      "If any lines that do not compile are removed, the String on line 42 is set to \"x\"."
    ],
    "explanation": "Line 40 does not compile since getOrDefault() requires two parameters. This\nmakes option A the first answer. The rest of the code does compile. Option D is the next \nanswer because getOrDefault() returns the value from the map when the key is present. \nFinally, option F is correct because getOrDefault() returns the second parameter when \nthe key is not present."
  },
  {
    "number": 79,
    "chapter": 5,
    "question": "What does the following output?\n18: List\u003cString\u003e list \u003d List.of(\n19:    \"Mary\", \"had\", \"a\", \"little\", \"lamb\");\n20: Set\u003cString\u003e set \u003d new HashSet\u003c\u003e(list);\n21: set.addAll(list);\n22: for(String sheep : set)\n23:    if (sheep.length() \u003e 1)\n24:       set.remove(sheep);\n25: System.out.println(set);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "[a, lamb, had, Mary, little]",
      "[a]",
      "[a, a]",
      "The code does not compile.",
      "The code throws an exception at runtime."
    ],
    "explanation": "Lines 18 and 19 create a list with five elements. Line 20 makes a set with the same \nfive elements. Line 21 does not change the contents of the set since sets must have  \nunique  elements. The loop on line 22 tries to delete elements but instead throws a  \nConcurrent ModificationException, making option E the answer."
  },
  {
    "number": 80,
    "chapter": 5,
    "question": "Which of the following fills in the blank so this code compiles?\npublic static void getExceptions(Collection\u003c \u003e coll) {\n   coll.add(new RuntimeException());\n   coll.add(new Exception());\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "?",
      "? extends Exception",
      "? super Exception",
      "None of the above"
    ],
    "explanation": "Option C is correct because all the types being added are of type Exception or direct\nsubclasses."
  },
  {
    "number": 1,
    "chapter": 6,
    "question": "The following figure represents a stream pipeline. Given this, would the boxes X, Y, Z best \nrepresent?\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Origin, intermediate operation, and final operation",
      "Origin, intermediate operation, and sink",
      "Origin, intermediate operation, and terminal operation",
      "Source, intermediate operation, and final operation",
      "Source, intermediate operation, and sink",
      "Source, intermediate operation, and terminal operation"
    ],
    "explanation": "The source is the first operation, and the terminal operation comes last, making option F\nthe answer. You need to know this terminology."
  },
  {
    "number": 2,
    "chapter": 6,
    "question": "Which of the following is required for all valid lambda expressions?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "()",
      "-\u003e",
      "{}",
      "Parameter data type(s)",
      "None of the above"
    ],
    "explanation": "The lambda expression s -\u003e true is valid, making options A, C, and D incorrect. Paren\ntheses, (), are not required on the left-hand side if there is only one variable. Braces, {}, \nare not required if the right-hand side is a single expression. Parameter data types are only \nrequired if the data type for at least one parameter is specified; otherwise, none are required. \nThe remaining choice, the arrow operator, -\u003e, is required for all lambda expressions, making \noption B the correct answer."
  },
  {
    "number": 3,
    "chapter": 6,
    "question": "Fill in the blanks: The ______________ functional interface does not take any inputs, while \nthe ______________ functional interface does not return any data.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "IntConsumer, LongSupplier",
      "IntSupplier, Function",
      "Supplier, DoubleConsumer",
      "UnaryOperator, Consumer",
      "None of the above"
    ],
    "explanation": "The Supplier functional interface does not take any inputs, while the Consumer\nfunctional interface does not return any data. This behavior extends to the primitive ver-\nsions of the functional interfaces, making option C the correct answer. Option A is incorrect \nbecause IntConsumer takes a value, while LongSupplier returns a value. Options B \nand D are incorrect because Function and UnaryOperator both take an input and pro-\nduce a value."
  },
  {
    "number": 4,
    "chapter": 6,
    "question": "What is the result of executing the following application multiple times?\npackage bears;\nimport java.util.*;\npublic class Bounce {\n   public static void main(String... legend) {\n      List.of(1,2,3,4).stream()\n         .forEach(System.out::println);\n      List.of(1,2,3,4).parallel()\n         .forEach(System.out::println);\n      List.of(1,2,3,4).parallel()\n         .forEachOrdered(System.out::println);\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Only the first stream prints the same order every time.",
      "Only the first and second streams print the same order every time.",
      "Only the first and third streams print the same order every time.",
      "All of the streams print the same order every time.",
      "None of the streams prints the same order every time.",
      "None of the above."
    ],
    "explanation": "A List instance, which inherits the Collection interface, does not have a parallel()\nmethod. Instead, parallelStream() must be used, making option F correct. If the code\nwas corrected to use parallelStream(), then the first and third streams would be con-\nsistently printed in the same order. Remember that the forEachOrdered() method forces \nparallel streams to run in sequential order. The order of the second operation would be \nunknown ahead of time, since it uses a parallel stream."
  },
  {
    "number": 5,
    "chapter": 6,
    "question": "A lambda expression for which of the following functional interfaces could be used to return \na Double value? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "UnaryOperator",
      "BiPredicate",
      "BiOperator",
      "BiConsumer",
      "BiFunction",
      "BiSupplier"
    ],
    "explanation": "The UnaryOperator and BiFunction return a generic argument, such as \nDouble, making options A and E correct. Option B is incorrect because all predicate \nfunctions return boolean. Option C is incorrect because BiOperator does not exist in \nthe java.util.function package. The correct name is BinaryOperator. Option D is \nincorrect because all consumer functions return void. Finally, option F is incorrect because \nBiSupplier does not exist in the java.util.function package. Supplier functions \nreturn values, and Java does not support methods with more than one return type."
  },
  {
    "number": 6,
    "chapter": 6,
    "question": "What does the following output?\nvar list \u003d new ArrayList\u003cString\u003e();\nlist.add(\"Austin\");\nlist.add(\"Boston\");\nlist.add(\"San Francisco\");\nvar c \u003d list.stream()\n   .filter(a -\u003e a.length() \u003e 10)    // line x\n   .count();\nSystem.out.println(c + \" \" + list.size());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "1 1",
      "1 3",
      "2 3",
      "The code does not compile due to line x.",
      "None of the above."
    ],
    "explanation": "The stream pipeline is correct and filters all values out that are 10 characters or smaller.\nOnly San Francisco is long enough, so c is 1 . The stream() call creates a new object, \nso stream operations do not affect the original list. Since the original list is still 3 elements, \noption B is correct."
  },
  {
    "number": 7,
    "chapter": 6,
    "question": "Identify the correct functional interfaces to fill in this table correctly. (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      4
    ],
    "userAnswers": [
      1,
      2,
      4
    ],
    "options": [
      "Interface X is Predicate.",
      "Interface X is Supplier.",
      "Interface Y is Comparator.",
      "Interface Y is Supplier.",
      "Interface Z is Consumer.",
      "Interface Z is Supplier."
    ],
    "explanation": "Interface X is tricky. If it returned a boolean primitive, option A would be correct \nas Predicate returns a boolean. However, it returns a wrapper object, so it has to be a \nSupplier, making option B the answer instead.\nInterface Y and Z are more straightforward as a Comparator and Consumer, respectively. \nThis makes options C and E the final two answers."
  },
  {
    "number": 8,
    "chapter": 6,
    "question": "What is a common reason for a stream pipeline not to run?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "The source doesn’t generate any items.",
      "There are no intermediate operations.",
      "The terminal operation is missing.",
      "The version of Java is too old.",
      "None of the above."
    ],
    "explanation": "Option A is incorrect because a pipeline still runs if the source doesn’t generate any items\nand the rest of the pipeline is correct. Granted, some of the operations have nothing to do, \nbut control still passes to the terminal operation. Option B is incorrect because intermediate \noperations are optional. Option C is the answer. The terminal operation triggers the pipeline \nto run. Option D is incorrect because the code would not compile at all if the version of Java \nwere too old."
  },
  {
    "number": 9,
    "chapter": 6,
    "question": "Which functional interface takes a long value as an input argument and has an \naccept() method?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "LongConsumer",
      "LongFunction",
      "LongPredicate",
      "LongSupplier",
      "None of the above"
    ],
    "explanation": "The LongSupplier interface does not take any input, making option D incorrect. It also\nuses the method name getAsLong(). The rest of the functional interfaces all take a long \nvalue but vary on the name of the abstract method they use. LongFunction contains \napply() and LongPredicate contains test(), making options B and C, respectively, \nincorrect. That leaves us with LongConsumer, which contains accept(), making option A \nthe correct answer."
  },
  {
    "number": 10,
    "chapter": 6,
    "question": "Given a parallel Stream\u003cT\u003e, which method would you use to obtain an equivalent serial \nStream\u003cT\u003e?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "unordered()",
      "reduce()",
      "concat()",
      "stream()",
      "boxed()",
      "None of the above"
    ],
    "explanation": "The correct method to obtain an equivalent sequential stream of an existing stream is\nsequential(), which is inherited by any class that implements BaseStream\u003cT\u003e. Since \nthis isn’t an option, option F is correct. Note that unordered() creates a stream that can be \nevaluated in any order, but it can still be processed in a sequential or parallel stream."
  },
  {
    "number": 11,
    "chapter": 6,
    "question": "Which of the following is a valid lambda expression?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "r -\u003e {return 1\u003d\u003d2}",
      "(q) -\u003e true",
      "(x,y) -\u003e {int test; return test\u003e0;}",
      "a,b -\u003e true",
      "None of the above"
    ],
    "explanation": "Option A is incorrect because the lambda expression is missing a semicolon (;) at the\nend of the return statement. Option C is incorrect because the local variable test is used \nwithout being initialized. Option D is also incorrect. The parentheses are required on the \nleft-hand side of the lambda expression when there is more than one value or a data type is \nspecified. Option B is the correct answer and the only valid lambda expression."
  },
  {
    "number": 12,
    "chapter": 6,
    "question": "Which are true of the following? (Choose two.)\nvar empty \u003d Optional.empty();\nvar param \u003d Optional.of(null);\nvar method \u003d Optional.ofNullable(null);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "All of these will run without error.",
      "One of the lines fails to compile or throws an exception.",
      "Two of the lines fail to compile or throw an exception.",
      "None of these returns true when calling opt.isPresent()",
      "One of these returns true when calling opt.isPresent()",
      "Two of these return true when calling opt.isPresent()"
    ],
    "explanation": "The second line throws a NullPointerException when you pass a null reference\nto the of() method. The others compile and run successfully, making option B correct. The \nfirst and third lines return false because they represent an empty Optional. This makes \noption D the other answer."
  },
  {
    "number": 13,
    "chapter": 6,
    "question": "Which of the following statements about DoubleSupplier and Supplier\u003cDouble\u003e \nis not true?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Both are functional interfaces.",
      "Both take zero parameters.",
      "Lambdas for both can return a double value.",
      "Lambdas for both cannot return a null value.",
      "One supports a generic type; the other does not.",
      "All of these are true."
    ],
    "explanation": "Both are functional interfaces in the java.util.function package, making option\nA true. Additionally, both lack parameters, making option B true. The major difference bet-\nween the two is that Supplier\u003cDouble\u003e takes the generic type Double, while the other \ndoes not take any generic type and instead uses the primitive double. For this reason, \noptions C and E are true statements. For Supplier\u003cDouble\u003e in option C, remember that \nthe returned double value can be implicitly autoboxed to Double. Option D is the correct \nanswer. Lambdas for Supplier\u003cDouble\u003e can return a null value since Double is an \nobject type, while lambdas for DoubleSupplier cannot; they can only return primitive \ndouble values."
  },
  {
    "number": 14,
    "chapter": 6,
    "question": "What is the output of the following program?\nimport java.util.stream.*;\npublic class Bull {\n   void charge() {\n      IntStream.range(1,6)\n         .parallel()\n         .forEachOrdered(System.out::print);\n   }\n   public static void main(String[] args) {\n      var b \u003d new Bull();\n      b.charge();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "12345",
      "54321",
      "The output cannot be determined ahead of time.",
      "The code does not compile.",
      "An exception is thrown at runtime.",
      "None of the above."
    ],
    "explanation": "Even though a parallel stream is used, the forEachOrdered() method forces the\nstream to operate in the order of its data source. The code compiles and runs without issue \nprinting 12345 every time, and making option A correct. If forEach() was used instead, \nthen the output would vary at runtime."
  },
  {
    "number": 15,
    "chapter": 6,
    "question": "Fill in the blank with the functional interface from java.util.function that allows the \ncode to compile and print 3 at runtime.\n_____________ transformer \u003d x -\u003e x;\n \nvar prime \u003d List.of(3,1,4,1,5,9)\n   .stream()\n   .limit(1)\n   .peek(s -\u003e {})\n   .mapToInt(transformer)\n   .peek(s -\u003e {})\n   .sum();\nSystem.out.println(prime);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Function\u003cInteger,Integer\u003e",
      "UnaryOperator\u003cInteger\u003e",
      "ToIntFunction\u003cInteger\u003e",
      "IntUnaryOperator",
      "The code does not compile regardless of what functional interface is placed in the blank.",
      "The code is capable of compiling, but since prime is an OptionalInt value, it cannot be 3 "
    ],
    "explanation": "The first line that contains the lambda expression will actually compile with any of the\nfunctional interfaces listed in the options. The stream operation, though, will compile only \nif ToIntFunction\u003cInteger\u003e is used. It requires this functional interface, which takes a \ngeneric argument and returns int. For this reason, option C is correct. Option F is incorrect \nbecause sum() on an IntStream returns an int, not an OptionalInt. Note that the \npeek() operations in this stream have no effect."
  },
  {
    "number": 16,
    "chapter": 6,
    "question": "Which fills in the blank so the code is guaranteed to print 1?\nvar stream \u003d Stream.of(1, 2, 3);\nSystem.out.println(stream.__________);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "anyMatch()",
      "findAny()",
      "first()",
      "min()",
      "None of the above"
    ],
    "explanation": "Option A is incorrect because anyMatch() returns a boolean. Option B is incorrect\nbecause findAny() might not return 1 .  The result could be any of the three numbers. \nOption C is incorrect because there is no first() method available as a terminal operation. \nOption D is tempting because there is a min() method. However, since we are working with \na Stream (not a primitive stream like IntStream), this method requires a Comparator as \na parameter. Therefore, option E is the answer."
  },
  {
    "number": 17,
    "chapter": 6,
    "question": "What is the result of the following?\n6:  var list \u003d new ArrayList\u003cString\u003e();\n7:  list.add(\"Monday\");\n8:  list.add(String::new);\n9:  list.add(\"Tuesday\");\n10: list.remove(0);\n11: System.out.println(list.get(0));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "null",
      "An empty String.",
      "Monday",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "Line 8 does not compile. String::new is a constructor reference. This constructor refer\nence is equivalent to writing the lambda () -\u003e new String(). It participates in deferred \nexecution. When it is executed later, it will return a String. It does not return a String on \nline 8, though. The method reference is a Supplier\u003cString\u003e, which cannot be stored in \nlist. Since the code does not compile, option D is correct."
  },
  {
    "number": 18,
    "chapter": 6,
    "question": "Which functional interface, when filled into the blank, allows the class to compile?\npackage space;\nimport java.util.function.*;\n \npublic class Asteroid {\n   public void mine(___________ lambda) {\n      // IMPLEMENTATION OMITTED\n   }\n   public static void main(String[] debris) {\n      new Asteroid().mine((s,p) -\u003e s+p);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "BiConsumer\u003cInteger,Double\u003e",
      "BiConsumer\u003cInteger,Double,Double\u003e",
      "BiFunction\u003cInteger,Double,Double\u003e",
      "BiFunction\u003cInteger,Integer,Double\u003e",
      "Function\u003cInteger,Double\u003e",
      "None of the above"
    ],
    "explanation": "The lambda (s,p) -\u003e s+p takes two arguments and returns a value. For this reason,\noptions A and B are incorrect because BiConsumer does not return any values. Option E \nis also incorrect, since Function takes only one argument and returns a value. This leaves \nus with options C and D, which both use BiFunction, which takes two generic arguments \nand returns a generic value. Option D is incorrect because the datatype of the unboxed sum \ns+q is int, and int cannot be both autoboxed and implicitly cast to Double. Option C is \ncorrect. The sum s+p is of type double, and double can be autoboxed to Double."
  },
  {
    "number": 19,
    "chapter": 6,
    "question": "What best describes a reduction?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "A source operation that creates a small value",
      "An intermediate operation where it filters the stream it receives",
      "An intermediate operation where it mathematically divides each element in the stream",
      "A terminal operation where a single value is generated by reading each element in the\nprior step in a stream pipeline",
      "A terminal operation where one element is returned from the prior step in a stream\npipeline without reading all the elements"
    ],
    "explanation": "The word reduction is used with streams for a terminal operation, so options A, B, and C\nare incorrect. Option E describes a valid terminal operation like anyMatch(), but is not a \nreduction. Option D is correct because a reduction has to look at each element in the stream \nto determine the result."
  },
  {
    "number": 20,
    "chapter": 6,
    "question": "Which statements about the following application are correct? (Choose two.)\nimport java.util.concurrent.atomic.*;\nimport java.util.stream.*;\npublic class TicketTaker {\n   long ticketsSold;\n   final AtomicInteger ticketsTaken;\n   public TicketTaker() {\n      ticketsSold \u003d 0;\n      ticketsTaken \u003d new AtomicInteger(0);\n   }\n   public void performJob() {\n      IntStream.iterate(1, p -\u003e p+1)\n         .parallel()\n         .limit(100)\n         .forEach(i -\u003e ticketsTaken.getAndIncrement());\n      IntStream.iterate(1, q -\u003e q+1)\n         .parallel()\n         .limit(500)\n         .forEach(i -\u003e ++ticketsSold);\n      System.out.print(ticketsTaken+\" \"+ticketsSold);\n   }\n   public static void main(String[] matinee) {\n      new TicketTaker().performJob();\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "The TicketTaker constructor does not compile.",
      "The performJob() method does not compile.",
      "The class compiles.",
      "The first number printed is consistently 100.",
      "The second number printed is consistently 500.",
      "A ConcurrentModificationException is thrown at runtime."
    ],
    "explanation": "The class compiles and runs without throwing an exception, making option C correct\nand options A, B, and F incorrect. The class defines two values that are incremented by mul-\ntiple threads in parallel. The first IntStream statement uses an atomic class to update a \nvariable. Since updating an atomic numeric instance is thread-safe by design, the first number \nprinted is always 100, making option D correct. The second IntStream statement uses an \nint with the pre-increment operator (++), which is not thread-safe. It is possible two threads \ncould update and set the same value at the same time, a form of race condition, resulting in a \nvalue less than 500 and making option E incorrect."
  },
  {
    "number": 21,
    "chapter": 6,
    "question": "Suppose you have a stream with one element and the code  \nstream.xxxx.forEach(System.out::println). Filling in xxxx from top to bottom \nin the table, how many elements can be printed out? Assume a valid lambda expression is \npassed to each method in the table.\nMethod Number elements printed\nfilter() ?\nflatMap() ?\nmap() ?",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Zero or one, zero or more, exactly one",
      "Zero or one, exactly one, zero or more",
      "Zero or one, zero or more, zero or more",
      "Exactly one, zero or more, exactly one",
      "Exactly one, exactly one, zero or more",
      "Exactly one, zero or more, zero or more"
    ],
    "explanation": "The filter() method either passes along a given element or doesn’t, making options\nD, E, and F incorrect. The flatMap() method doesn’t pass along any elements for \nempty streams. For nonempty streams, it flattens the elements, allowing it to return zero \nor more elements. This makes option B incorrect. Finally, the map() method applies a \none-to-one function for each element. It has to return exactly one element, so option A is the \ncorrect answer."
  },
  {
    "number": 22,
    "chapter": 6,
    "question": "Assuming the proper generic types are used, which lambda expression can be assigned to a \nToDoubleBiFunction functional interface reference? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      3
    ],
    "userAnswers": [
      0,
      3,
      5
    ],
    "options": [
      "(Integer a, Double b) -\u003e {int c; return b;}",
      "(h,i) -\u003e (long)h",
      "(String u, Object v) -\u003e u.length()+v.length()",
      "(x,y) -\u003e {int z\u003d2; return y/z;}",
      "z -\u003e z",
      "(double y, double z) -\u003e y + z"
    ],
    "explanation": "To begin with, ToDoubleBiFunction\u003cT,U\u003e takes two generic inputs and returns \na double value. Option A is correct because it takes an Integer and Double and returns  \na Double value that can be implicitly unboxed to double. Option B is correct because  \nlong can be implicitly cast to double. While we don’t know the data types for the input \narguments, we know that some values, such as using Integer for both, will work. Option  \nC cannot be assigned and does not compile because the variable v is of type Object and \nObject does not have a length() method. Option D is correct. The variable y could \nbe declared Double in the generic argument to the functional interface, making y/z a \ndouble return value. Option E is not correct because the lambda only has one parameter. \nFinally, option F is incorrect because the interface uses the class Double rather than primi-\ntive double."
  },
  {
    "number": 23,
    "chapter": 6,
    "question": "Given a Stream\u003cT\u003e, which method would you use to obtain an equivalent parallel \nStream\u003cT\u003e?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "getParallelStream()",
      "parallelStream()",
      "parallel()",
      "getParallel()",
      "parallels()",
      "None of the above"
    ],
    "explanation": "The correct method to obtain an equivalent parallel stream of an existing stream is\nparallel(), which is inherited by any class that implements BaseStream\u003cT\u003e. For this \nreason, option C is correct."
  },
  {
    "number": 24,
    "chapter": 6,
    "question": "Rewrite this lambda that takes an int n using a constructor reference:\nn -\u003e new ArrayList\u003c\u003e(n)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "ArrayList::new",
      "ArrayList::new()",
      "ArrayList::new(n)",
      "ArrayList::new[n]",
      "None of the above"
    ],
    "explanation": "The lambda is a Function\u003cInteger, ArrayList\u003e. We need a constructor reference\nthat uses the new keyword where a method name would normally go in a method reference. \nIt can implicitly take zero or one parameters just like a method reference. In this case, we \nhave one parameter, which gets passed to the constructor. Option A is correct. Options B, C, \nand D use syntax that is not supported with method references."
  },
  {
    "number": 25,
    "chapter": 6,
    "question": "On a DoubleStream, how many of the methods average(), count(), max(), and \nsum() return an OptionalDouble?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "The average() method returns an OptionalDouble. This reflects that it doesn’t make\nsense to calculate an average when you don’t have any numbers. Similarly, max() returns \nan OptionalDouble because there isn’t a maximum of no number. By contrast, counting \nwithout any numbers gives the long number 0 and summing gives the double number  0 .0 . \nSince only two methods matches the desired return type, option C is correct."
  },
  {
    "number": 26,
    "chapter": 6,
    "question": "Which of the following is not a functional interface in the java.util.function package? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3,
      4
    ],
    "userAnswers": [
      3,
      4
    ],
    "options": [
      "BiPredicate",
      "DoubleUnaryOperator",
      "IntUnaryOperator",
      "ObjectDoubleConsumer",
      "ObjectIntConsumer",
      "ToLongFunction"
    ],
    "explanation": "The BiPredicate interface takes two generic arguments and returns a boolean\nvalue. Next, DoubleUnaryOperator and IntUnaryOperator exist and transform values \nof type double and int, respectively. Last, ToLongFunction takes a generic argument \nand returns a long value. That leaves options D and E, which is the answer. While there are \nObjDoubleConsumer and ObjIntConsumer functional interfaces, there is no such thing \nas ObjectDoubleConsumer or ObjectIntConsumer. Remember that Object is abbre-\nviated to Obj in all functional interfaces in java.util.function."
  },
  {
    "number": 27,
    "chapter": 6,
    "question": "Five of the following six methods always produce the same result whether they are executed \non an ordered serial or parallel stream. Which one does not?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "findAny()",
      "findFirst()",
      "limit()",
      "skip()",
      "anyMatch()",
      "count()"
    ],
    "explanation": "The findAny() method can return the first, last, or any element of the stream, regardless\nof whether the stream is serial or parallel. While on serial streams this is likely to be the first \nelement in the stream, on parallel streams the result is less certain. For this reason, option \nA is the correct answer. The anyMatch() and count() methods produce the same result, \nregardless of whether the stream is serial or parallel. The rest of the operations force the \nstream to behave in a sequential manner when applied to an ordered stream, even if it is \nparallel. Note that the behavior is not the same on an unordered stream. For example,  \nfindFirst() can return any element when applied to an unordered stream."
  },
  {
    "number": 28,
    "chapter": 6,
    "question": "In a stream pipeline, which can return a value other than a Stream?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Source",
      "Intermediate operation",
      "Terminal operation",
      "None of the above"
    ],
    "explanation": "The result of the source and any intermediate operations are chained and eventually\npassed to the terminal operation. The terminal operation is where a nonstream result is gen-\nerated, making option C correct."
  },
  {
    "number": 29,
    "chapter": 6,
    "question": "When working with a Stream\u003cString\u003e, which of these types can be returned from the \ncollect() terminal operator by passing arguments to Collectors.groupingBy()?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Only Map\u003cBoolean, HashSet\u003cString\u003e\u003e",
      "Only Map\u003cInteger, List\u003cString\u003e\u003e",
      "Both Map\u003cBoolean, HashSet\u003cString\u003e\u003e and Map\u003cInteger, List\u003cString\u003e\u003e",
      "Only List\u003cInteger\u003e",
      "Only List\u003cString\u003e",
      "Both List\u003cInteger\u003e and List\u003cString\u003e"
    ],
    "explanation": "The groupingBy() collector always returns a Map (or a specific implementation \nclass of Map), so options D, E, and F are incorrect. The other two are definitely possible.  \nTo get one, you can group using a Function that returns an Integer such as  \ns.collect(groupingBy(String::length)). To get the other, you need to  \ngroup using a Function that returns a Boolean and specify the type, such as  \ns.collect(groupingBy(String::isEmpty, toCollection(HashSet::new))). \nTherefore, option C is correct."
  },
  {
    "number": 30,
    "chapter": 6,
    "question": "What does the following output?\n12: Set\u003cString\u003e set \u003d new HashSet\u003c\u003e();\n13: set.add(\"tire-\");\n14: List\u003cString\u003e list \u003d new LinkedList\u003c\u003e();\n15: Deque\u003cString\u003e queue \u003d new ArrayDeque\u003c\u003e();\n16: queue.push(\"wheel-\");\n17: Stream.of(set, list, queue)\n18:    .flatMap(x -\u003e x)\n19:    .forEach(System.out::print);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "[tire-][wheel-]",
      "tire-wheel-",
      "[wheel-][tire-]",
      "wheel-tire-",
      "None of the above.",
      "The code does not compile."
    ],
    "explanation": "The flatMap() method works with streams rather than collections. Line 18 is problem\natic because the return value is not a stream. Since the code does not compile, option F is \ncorrect. If the lambda was changed to x -\u003e x.stream(), option B would be the answer."
  },
  {
    "number": 31,
    "chapter": 6,
    "question": "What is the result of executing the following?\nvar list \u003d new LinkedList\u003c\u003e();\nlist.add(\"Archie\");\nlist.add(\"X-Men\");\nStream s \u003d list.stream();  // line w\ns.forEach(System.out::println);\ns.forEach(System.out::println);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "The code runs without exception and prints two lines.",
      "The code runs without exception and prints four lines.",
      "The code does not compile due to line w.",
      "The code does not compile due to another line.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "Since no generic type is specified, list is a LinkedList\u003cObject\u003e. Line w compiles\nbecause no generic type is specified. However, Java only allows you to operate on a stream \nonce. The final line of code throws an IllegalStateException because the stream has \nalready been used up, making option D correct."
  },
  {
    "number": 32,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage zoo;\nimport java.util.function.*;\n \npublic class TicketTaker {\n   private static int AT_CAPACITY \u003d 100;\n   public int takeTicket(int currentCount,\n      IntUnaryOperator\u003cInteger\u003e counter) {\n \n      return counter.applyAsInt(currentCount);\n   }\n   public static void main(String...theater) {\n      final TicketTaker bob \u003d new TicketTaker();\n      final int oldCount \u003d 50;\n      final int newCount \u003d bob.takeTicket(oldCount,t -\u003e {\n         if(t\u003eAT_CAPACITY) {\n            throw new RuntimeException(\n               \"Sorry, max has been reached\");\n         }\n         return t+1;\n      });\n      System.out.print(newCount);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "50",
      "51",
      "The code does not compile because of the lambda expression.",
      "The code does not compile for a different reason.",
      "The code compiles but prints an exception at runtime."
    ],
    "explanation": "The code does not compile, so options A, B, and E are incorrect. The\nIntUnary Operator functional interface is not generic, so the argument \nIntUnaryOperator\u003cInteger\u003e in the takeTicket() does not compile, making option \nD the correct answer. The lambda expression compiles without issue, making option C \nincorrect. If the generic argument \u003cInteger\u003e was dropped from the argument declara-\ntion, the class would compile without issue and output 51 at runtime, making option B the \ncorrect answer."
  },
  {
    "number": 33,
    "chapter": 6,
    "question": "What are the three requirements for performing a parallel reduction with the collect() \nmethod, which takes a Collector argument. (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      4
    ],
    "userAnswers": [
      0,
      3,
      4
    ],
    "options": [
      "The Collector argument is marked concurrent.",
      "The elements of the stream implement the Comparable interface.",
      "The stream is parallel.",
      "The stream is thread-safe.",
      "The stream or Collector is marked unordered.",
      "The stream is not a primitive stream."
    ],
    "explanation": "Options A, C, and E are the precise requirements for Java to perform a concurrent\nreduction using the collect() method, which takes a Collector argument. Recall \nfrom your studies that a Collector is considered concurrent and unordered if it has the \nCollector.Characteristics enum values CONCURRENT and UNORDERED, respectively. \nThe rest of the options are not required for a parallel reduction."
  },
  {
    "number": 34,
    "chapter": 6,
    "question": "What is true about the following code? (Choose two.)\n27: public static void main(String[] s) {\n28:    Predicate dash \u003d c -\u003e c.startsWith(\"-\");\n29:    System.out.println(dash.test(\"–\"));\n30:\n31:    Consumer clear \u003d x -\u003e System.out.println(x);\n32:    clear.accept(\"pink\");\n33:\n34:    Comparator\u003cString\u003e c \u003d (String s, String t) -\u003e 0;\n35:    System.out.println(c.compare(\"s\", \"t\"));\n36: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "The code compiles successfully.",
      "One line does not compile.",
      "Two lines do not compile.",
      "Three lines do not compile.",
      "If any lines that do not compile are fixed, the output includes pink.",
      "If any lines that do not compile are fixed, the output does not include pink."
    ],
    "explanation": "While it is common for a Predicate to have a generic type, it is not required. How\never, it is treated like a Predicate of type Object if the generic type is missing. Since \nstartsWith() does not exist on Object, line 28 does not compile.\nLine 34 would be a correct lambda declaration in isolation. However, it uses the variable s, \nwhich is already taken from the main() method parameter. This causes a compiler error \non line 34 .  These are the only two compiler errors, making option C correct. If Predicate \nwere changed to Predicate\u003cString\u003e and lambda variable were changed to x, the \nConsumer would in fact print pink, making option E the other answer."
  },
  {
    "number": 35,
    "chapter": 6,
    "question": "Which functional interface returns a primitive value?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "BiPredicate",
      "CharSupplier",
      "LongFunction",
      "UnaryOperator",
      "TriDoublePredicate",
      "None of the above"
    ],
    "explanation": "Option A is the correct answer because BiPredicate takes two generic types and\nreturns a primitive boolean value. Option B is incorrect, since CharSupplier does not \nexist in java.util.function. Option C is also incorrect, since LongFunction takes \na primitive long value and returns a generic type. Remember, Java only includes primitive \nfunctional interfaces that operate on double, int, or long. Option D is incorrect because \nUnaryOperator takes a generic type and returns a generic value. Finally, option E is incor-\nrect because TriDoublePredicate is not a built-in functional interface."
  },
  {
    "number": 36,
    "chapter": 6,
    "question": "Given the following code snippet, which lambda expressions are the best choices for an accu-\nmulator? (Choose two.)\nimport java.util.*;\nimport java.util.function.*;\npublic class GoodAccumulator {\n   int i \u003d 0;\n   List\u003cString\u003e words \u003d new ArrayList\u003c\u003e();\n   public void test() {\n      BiFunction\u003cInteger,Integer,Integer\u003e x \u003d _____________;\n      System.out.print(List.of(1,2,3,4,5)\n         .parallelStream()\n         .reduce(0,x,(s1, s2) -\u003e s1 + s2));\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "(a,b) -\u003e (a-b)",
      "(a,b) -\u003e 5",
      "(a,b) -\u003e i++",
      "(a,b) -\u003e {words.add(\"awesome\"); return 0;}",
      "(a,b) -\u003e {return 0;}",
      "(a,b) -\u003e words.add(\"awesome\")"
    ],
    "explanation": "An accumulator in a serial or parallel reduction should be associative and stateless. In\na parallel reduction, problematic accumulators tend to produce more visible errors. Option \nA is not associative, since (a-b)-c is not the same as a-(b-c) for all values a, b, and c. \nOptions C and D are incorrect because they represent stateful lambda expressions, which \nshould be avoided especially on parallel streams. Option F doesn’t even compile, since \nthe return type is a boolean, not an Integer. That leaves us with the correct answers, \noptions B and E .  While these accumulators may not seem useful, they are both stateless and \nassociative, which meets the qualifications for performing a reduction."
  },
  {
    "number": 37,
    "chapter": 6,
    "question": "Fill in the blanks so that both methods produce the same output for all inputs.\nprivate static void longer(Optional\u003cBoolean\u003e opt) {\n   if (opt.___________())\n      System.out.println(\"run: \" + opt.get());\n}\nprivate static void shorter(Optional\u003cBoolean\u003e opt) {\n   opt.map(x -\u003e \"run: \" + x)\n      ._________(System.out::println);\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "isNotNull, isPresent",
      "ifPresent, isPresent",
      "isPresent, forEach",
      "isPresent, ifPresent",
      "None of the above"
    ],
    "explanation": "The Optional class has an isPresent() method that doesn’t take any parameters. It\nreturns a boolean and is commonly used in if statements. There is also an ifPresent() \nmethod that takes a Consumer parameter and runs it only if the Optional is nonempty. \nThe methods isNotNull() and forEach() are not declared in Optional. Therefore, \noption D is correct."
  },
  {
    "number": 38,
    "chapter": 6,
    "question": "Rewrite this lambda using a method reference:\n() -\u003e Math.random()",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Math.random",
      "Math::random",
      "Math::random()",
      "java.lang::Math.random",
      "None of the above"
    ],
    "explanation": "The lambda is a Supplier\u003cDouble\u003e. Since the random() method is static, we need\na static method reference. It uses :: to separate the class name and method name. Option \nB is correct. Options A, C, and D use syntax that is not supported with method references."
  },
  {
    "number": 39,
    "chapter": 6,
    "question": "Which operation can occur more than once in a stream pipeline?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Origin",
      "Sink",
      "Source",
      "Intermediate operation",
      "Terminal operation",
      "None of the above"
    ],
    "explanation": "Options A and B are incorrect because they are not operations in a stream pipeline. A\nsource and the terminal operation are required parts of a stream pipeline and must occur \nexactly once. The intermediate operation is optional. It can appear zero or more times. Since \nmore than once falls within zero or more, option D is correct."
  },
  {
    "number": 40,
    "chapter": 6,
    "question": "What is true of the following code?\n21: var list \u003d List.of(\u0027c\u0027, \u0027b\u0027, \u0027a\u0027);\n22:\n23: list.stream()\n24:    .sorted()\n25:    .findAny()\n26:    .ifPresent(System.out::println);\n27:\n28: System.out.println(list.stream().sorted().findFirst());",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Both streams are guaranteed to print the single character a.",
      "Both streams will print a single character of a, b, or c.",
      "Only one stream is guaranteed to print the single character a.",
      "Only one stream will print a single character of a, b, or c.",
      "The code does not compile."
    ],
    "explanation": "All of the code compiles. The first stream source has three elements. The intermediate\noperations both sort the elements of this stream and then we request one from findAny(). \nThe findAny() method is not guaranteed to return a specific element. Since we are not \nusing parallelization, it is highly likely that the code will print a. However, you need to \nknow this is not guaranteed. Additionally, the stream on line 28 prints Optional[a], \nOptional[b], or Optional[c]. Since only lines 23–26 print a single character, option D \nis the answer."
  },
  {
    "number": 41,
    "chapter": 6,
    "question": "Which functional interface, when entered into the following blank, allows the class \nto compile?\npackage groceries;\nimport java.util.*;\nimport java.util.function.*;\n \npublic class Market {\n   private static void checkPrices(List\u003cDouble\u003e prices,\n         ____________ scanner) {\n      prices.forEach(scanner);\n   }\n   public static void main(String[] right) {\n      List\u003cDouble\u003e prices \u003d List.of(1.2, 6.5, 3.0);\n      checkPrices(prices,\n            p -\u003e {\n               String result \u003d p\u003c5 ? \"Correct\" : \"Too high\";\n               System.out.println(result);\n            });\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Consumer",
      "Consumer\u003cInteger\u003e",
      "DoubleConsumer",
      "Supplier\u003cDouble\u003e",
      "None of the above"
    ],
    "explanation": "First, the forEach() method requires a Consumer instance. Option D can be imme\ndiately discarded because Supplier\u003cDouble\u003e does not inherit Consumer. For this same \nreason, option C is also incorrect. DoubleConsumer does not inherit from Consumer. \nIn this manner, primitive functional interfaces cannot be used in the forEach() method. \nOption A seems correct, since forEach() does take a Consumer instance, but it is missing \na generic argument. Without the generic argument, the lambda expression does not com-\npile because the expression p\u003c5 cannot be applied to an Object. Option B is also close, \nhowever, a Double cannot be passed to an Integer. The correct functional interface is \nConsumer\u003cDouble\u003e, and since that is not available, option E is the correct answer."
  },
  {
    "number": 42,
    "chapter": 6,
    "question": "Which of the following is not a valid lambda expression?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "(Integer j, k) -\u003e 5",
      "(p,q) -\u003e p+q",
      "(Integer x, Integer y) -\u003e x*y",
      "(left,right) -\u003e {return \"null\";}",
      "All of these are valid."
    ],
    "explanation": "Option A is the invalid lambda expression because the type is specified for the variable\nj, but not the variable k. The rest of the options are valid lambda expressions. To be a valid \nlambda expression, the type must be specified for all of the variables, as in option C, or none \nof them, as in options B and  D ."
  },
  {
    "number": 43,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage exercise;\nimport java.util.*;\npublic class Concat {\n   public String concat1(List\u003cString\u003e values) {\n      return values.parallelStream()\n            .reduce(\"a\",\n                  (x,y)-\u003ex+y,\n                  String::concat);\n   }\n   public String concat2(List\u003cString\u003e values) {\n      return values.parallelStream()\n            .reduce((w,z)-\u003ez+w).get();\n   }\n   public static void main(String... questions) {\n      Concat c \u003d new Concat();\n      var list \u003d List.of(\"Cat\",\"Hat\");\n      String x \u003d c.concat1(list);\n      String y \u003d c.concat2(list);\n      System.out.print(x+\" \"+y);\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "CatHat CatHat",
      "aCataHat HatCat",
      "The code does not compile because the stream in concat1() returns an Optional.",
      "The code does not compile for a different reason.",
      "An exception is printed at runtime.",
      "None of the above."
    ],
    "explanation": "The code compiles and runs without issue. The three-argument reduce() method\nreturns a generic type, while the one-argument reduce() method returns an Optional. \nThe concat1() method is passed an identity \"a\", which it applies to each element, result-\ning in the reduction to aCataHat. The lambda expression in the concat2() method \nreverses the order of its inputs, leading to a value of HatCat. For these reasons, option B is \nthe correct answer."
  },
  {
    "number": 44,
    "chapter": 6,
    "question": "Which of the following three functional interfaces is not equivalent to the other two?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "BiFunction\u003cDouble,Double,Double\u003e",
      "BinaryOperator\u003cDouble\u003e",
      "DoubleFunction\u003cDouble\u003e",
      "None of the above. All three are equivalent."
    ],
    "explanation": "BiFunction\u003cDouble,Double,Double\u003e and BinaryOperator\u003cDouble\u003e both\ntake two Double input arguments and return a Double value, making them equivalent \nto one another. On the other hand, DoubleFunction\u003cDouble\u003e takes a single double \nvalue and returns a Double value. For this reason, it is different from the other two, making \noption C correct and option D incorrect."
  },
  {
    "number": 45,
    "chapter": 6,
    "question": "Given the following code snippet, what changes should be made for the JVM to correctly \nprocess this as a concurrent reduction? (Choose two.)\nvar w \u003d Stream.of(\"c\",\"a\",\"t\")\n   .collect(HashSet::new, Set::add, Set::addAll);\nSystem.out.println(w);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "Replace HashSet with LinkedHashSet.",
      "Mark the stream parallel.",
      "Remove the second argument of the collect() method.",
      "Remove the third argument of the collect() method.",
      "Replace HashSet with ConcurrentSkipListSet.",
      "Mark the stream unordered."
    ],
    "explanation": "For a concurrent reduction, the underlying type should be a thread-safe collection. For\nthis reason, option A is incorrect and option E is correct. The streams must all be parallel, \nmaking option B correct and option F incorrect. Options C and D are incorrect, as there is no \ntwo-argument version of collect() within the Stream interface."
  },
  {
    "number": 46,
    "chapter": 6,
    "question": "Fill in the blank so this code outputs three lines:\nvar list \u003d new ArrayList\u003cString\u003e();\nlist.add(\"Atlanta\");\nlist.add(\"Chicago\");\nlist.add(\"New York\");\nlist.stream()\n   .filter( )\n   .forEach(System.out::println);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "String::isEmpty",
      "! String::isEmpty",
      "String::! isEmpty",
      "String::isNotEmpty",
      "None of the above"
    ],
    "explanation": "Option A is the only one of the three options to compile. However, it results in no lines\nbeing output since none of the three strings is empty. Options B and C do not even compile \nbecause a method reference cannot have an operator next to it. Option D does not compile \nbecause String does not have an isNotEmpty() method. Therefore, option E is correct."
  },
  {
    "number": 47,
    "chapter": 6,
    "question": "What does the following output?\nvar chars \u003d Stream.generate(() -\u003e \u0027a\u0027);\nchars.filter(c -\u003e c \u003c \u0027b\u0027)\n     .sorted()\n     .findFirst()\n     .ifPresent(System.out::print);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "a",
      "The code runs successfully without any output.",
      "The code does not complete.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "The source of this stream is infinite. Sorting something infinite never finishes, so the\nstream pipeline never completes. This corresponds to option  C ."
  },
  {
    "number": 48,
    "chapter": 6,
    "question": "What is the expected output of the following code snippet?\nStream.iterate(1, x -\u003e x + 1)\n   .limit(5)\n   .skip(2)\n   .peek(System.out::print)\n   .collect(Collectors.toList())\n   .forEach(System.out::print);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "It does not compile.",
      "It throws an exception at runtime.",
      "It does not print any output at runtime.",
      "345345",
      "334455",
      "The behavior of the code snippet cannot be determined until runtime."
    ],
    "explanation": "The code compiles and does not throw any exception at runtime, so options A and B are\nincorrect. The code snippet is serial, by default, so the order is predictable, making option \nF incorrect. The peek() method executes on each member of the pipeline, printing five \nnumbers as the elements are then collected into a List, which gives us 345 .  They are then \nprinted again, making the final output 345345 and option D correct."
  },
  {
    "number": 49,
    "chapter": 6,
    "question": "What is the output of the following program?\npackage ai;\nimport java.util.function.*;\n \npublic class Android {\n   public void wakeUp(Supplier supplier) {             // d1\n      supplier.get();\n   }\n   public static void main(String... electricSheep) {\n      Android data \u003d new Android();\n      data.wakeUp(() -\u003e System.out.print(\"Started!\")); // d2\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Started!",
      "The code does not compile because of line d1 only.",
      "The code does not compile because of line d2 only.",
      "The code does not compile because of both lines d1 and d2."
    ],
    "explanation": "The program does not compile, so option A is incorrect. The Supplier functional inter\nface normally takes a generic argument, although generic types are not strictly required, since\nthey are removed by the compiler. Therefore, line d1 compiles while triggering a compiler \nwarning, and options B and D are incorrect. On the other hand, line d2 does cause a com-\npiler error, because the lambda expression does not return a value. Therefore, it is not com-\npatible with Supplier, making option C the correct answer."
  },
  {
    "number": 50,
    "chapter": 6,
    "question": "Given the following code snippet, what statement about the values printed on lines p1 and p2 \nis correct?\nvar db \u003d Collections.synchronizedList(new ArrayList\u003c\u003e());\nIntStream.range(1,6)\n   .parallel()\n   .map(i -\u003e {db.add(i); return i;})\n   .forEachOrdered(System.out::print);  // p1\nSystem.out.println();\ndb.forEach(System.out::print);          // p2",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "They are always the same.",
      "They are sometimes the same.",
      "They are never the same.",
      "The code does not compile.",
      "The code will produce a ConcurrentModificationException at runtime.",
      "None of the above."
    ],
    "explanation": "First, the class uses a synchronized list, which is thread-safe and allows modification \nfrom multiple threads, making option E incorrect. The process generates a stream of num-\nbers from 1 to 5 and sends them into a parallel stream where the map() is applied, possibly \nout of order. This results in elements being written to db in a random order. The stream \nthen applies the forEachOrdered() method to its elements, which will force the parallel \nstream into a single-threaded state. At runtime, line p1 will print the results in order every \ntime as 12345 .  On the other hand, since the elements were added to db in a random order, \nthe output of line p2 is random and cannot be predicted ahead of time. Since the results may \nsometimes be the same, option B is the correct answer. Part of the reason that the results are \nindeterminate is that the question uses a stateful lambda expression, which, based on your \nstudies, should be avoided!"
  },
  {
    "number": 51,
    "chapter": 6,
    "question": "Fill in the blanks so this code prints *8.0-8.0*? (Choose two.)\nvar ints \u003d IntStream.of(6, 10);\nvar longs \u003d ints.mapToLong(i -\u003e i);\nvar first \u003d longs.________________;\n \nvar moreLongs \u003d LongStream.of(6, 10);\nvar stats \u003d moreLongs.summaryStatistics();\nvar second \u003d _________________________;\nSystem.out.println(\"*\" + first + \"-\" + second + \"*\");",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "averageAsDouble() in the first blank",
      "average().getAsDouble() in the first blank",
      "getAverage().get() in the first blank",
      "stats.average() in the second blank",
      "stats.average().get() in the second blank",
      "stats.getAverage() in the second blank"
    ],
    "explanation": "Primitive streams, like LongStream, declare an average() method that returns an\nOptionalDouble object. This object declares a getAsDouble() method rather than a \nget() method. Therefore, option A is incorrect, and option B is correct.\nBy contrast, the summary statistics classes provide getters in order to access the data. The \ngetAverage() method returns a double and not an OptionalDouble, which makes \noption F correct. The other options do not compile."
  },
  {
    "number": 52,
    "chapter": 6,
    "question": "Starting with DoubleConsumer and going downward, fill in the missing values for \nthe table.\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "0, 1, 1, 1",
      "0, 1, 0, 2",
      "0, 2, 1, 2",
      "1, 1, 0, 2",
      "1, 1, 1, 1",
      "None of the above"
    ],
    "explanation": "Remember that all Supplier interfaces take zero parameters. For this reason, the third\nvalue in the table is 0, making options A, C, and E incorrect. Next, DoubleConsumer and \nIntFunction each take one value, double and int, respectively. On the other hand,  \nObjDoubleConsumer takes two values, a generic value and a double, and returns void. \nFor this reason, option D is correct, and option B is incorrect."
  },
  {
    "number": 53,
    "chapter": 6,
    "question": "Starting with DoubleConsumer and going downward, fill in the values for the table. For the \nfollowing choices, assume R is a generic type.\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "double, int, long, R",
      "double, R, long, R",
      "R, int, long, R",
      "R, int, long, void",
      "void, int, R, void",
      "void, R, long, void"
    ],
    "explanation": "All Consumer functional interfaces have a void return type. For this reason, the first and\nlast values in the table are both void, making options A, B and C incorrect. Int Function \ntakes an int and returns a generic value, ruling out option  D . Finally, LongSupplier \ndoes not take any values and returns a long value. For this reason, option E is incorrect, and \noption F is correct."
  },
  {
    "number": 54,
    "chapter": 6,
    "question": "What is a possible output of the following application?\npackage salvage;\nimport java.util.*;\nimport java.util.stream.*;\npublic class Car {\n   private String model;\n   private int year;\n   @Override public String toString() {return model;}\n   // Constructor/Getters/Setters Omitted\n \n   public static void main(String... make) {\n      var cars \u003d new ArrayList\u003cCar\u003e();\n      cars.add(new Car(\"Mustang\",1967));\n      cars.add(new Car(\"Thunderbird\",1967));\n      cars.add(new Car(\"Escort\",1975));\n      var map \u003d cars\n         .stream()\n         .collect(\n            Collectors.groupingByConcurrent(Car::getYear));\n      System.out.print(map);\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "{1975\u003d[Escort], 1967\u003d[ Mustang, Thunderbird]}",
      "{Escort\u003d[1975], Thunderbird\u003d[1967], Mustang\u003d[1967]}",
      "The code does not compile.",
      "The code hangs indefinitely at runtime.",
      "The application throws an exception at runtime because the stream is not parallel.",
      "None of the above."
    ],
    "explanation": "The code compiles and runs without issue. The JVM will fall back to a single-threaded\nprocess if all of the conditions for performing the parallel reduction are not met. The stream \nused in the main() method is not parallel, but the groupingByConcurrent() method \ncan still be applied without throwing an exception at runtime. Although performance will \nsuffer from not using a parallel stream, the application will still process the results correctly. \nSince the process groups the data by year, option A is the correct answer."
  },
  {
    "number": 55,
    "chapter": 6,
    "question": "How many lines does this code output?\nvar list \u003d new LinkedList\u003cString\u003e();\nlist.add(\"Archie\");\nlist.add(\"X-Men\");\nlist.stream().forEach(System.out.println);\nlist.stream().forEach(System.out.println);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Two.",
      "Four.",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "This code is almost correct. Calling two different streams is allowed. The code attempts to\nuse a method reference when calling the forEach() method. However, it does not use the \nright syntax for a method reference. A double colon needs to be used. The code would need \nto be changed to System.out::println to work and print two lines for each call. Since it \ndoes not compile, option C is correct."
  },
  {
    "number": 56,
    "chapter": 6,
    "question": "Which lambda expression can replace the instance of new BiologyMaterial() in the \nScientist class and produce the same results under various inputted values?\npackage university;\n@FunctionalInterface interface Study {\n   abstract int learn(String subject, int duration);\n}\n \nclass BiologyMaterial implements Study {\n   @Override public int learn(String subject, int duration) {\n      if(subject \u003d\u003d null)\n         return duration;\n      else\n         return duration+1;\n   }\n}\n \npublic class Scientist {\n   public static void main(String[] courses) {\n      final Study s \u003d new BiologyMaterial();\n      System.out.print(s.learn(courses[0], \n        Integer.parseInt(courses[1])));\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "(p,q) -\u003e q\u003d\u003dnull ? p : p+1",
      "(c,d) -\u003e {int d\u003d1; return c!\u003dnull ? d+1 : d;}",
      "(x,y) -\u003e {return x\u003d\u003dnull ? y : y+1;}",
      "(a,b) -\u003e 1",
      "None of the above"
    ],
    "explanation": "First, option A does not compile, since the variables p and q are reversed, making the\nreturn type of the method and usage of operators invalid. The first argument p is a String \nand q is an int, but the lambda expression reverses them, and the code does not com-\npile. Option B also does not compile. The variable d is declared twice, first in the lambda \nargument list and then in the body of the lambda expression. The second declaration in the \nbody of the lambda expression causes the compiler to generate a duplicate local variable \nmessage. Note that other than it being used twice, the expression is valid; the ternary oper-\nator is functionally equivalent to the learn() method in the BiologyMaterial class. \nOption C is the correct answer since it compiles and handles the input in the same way as the \nlearn() method in the BiologyMaterial class. Option D compiles but does not return \nthe same result."
  },
  {
    "number": 57,
    "chapter": 6,
    "question": "What is true of the following? (Choose two.)\nvar s \u003d Stream.of(\"speak\", \"bark\", \"meow\", \"growl\");\nBinaryOperator\u003cString\u003e merge \u003d (a, b) -\u003e a;\nvar map \u003d s.collect(toMap(String::length, k -\u003e k, merge));\nSystem.out.println(map.size() + \" \" + map.get(4));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      5
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "The output is 2 bark.",
      "The output is 2 meow.",
      "The output is 4 bark.",
      "The output is 4 meow.",
      "If \"meow\" was replaced by a null reference, the output would remain the same.",
      "If \"meow\" was replaced by a null reference, the output would change."
    ],
    "explanation": "This code does compile. Remember that imports are implied, including the static\nimport for Collectors. The collector tries to use the number of characters in each stream \nelement as the key in a map. This works fine for the first two elements, speak and bark, \nbecause they are of length 5 and 4, respectively. When it gets to meow, it sees another key \nof 4 .  The merge function says to use the first one, so it chooses bark for the value. Simi-\nlarly, growl is 5 characters, but the first value of speak is used. There are only two distinct \nlengths, so option A is correct.\nIf the stream had a null instead of \"meow\", the code would throw a  \nNullPointer Exception, since we need to check the length of the String to determine \nwhich part of the Map it goes in. Since you cannot call a method on null, option F is correct."
  },
  {
    "number": 58,
    "chapter": 6,
    "question": "Which statement about a source in a Stream is true?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The source is mandatory in a stream pipeline.",
      "The source is only allowed to return primitives.",
      "The source must be retrieved by calling the stream() method.",
      "The source must return a finite number of elements.",
      "None of the above."
    ],
    "explanation": "Option A is correct as the source and terminal operation are mandatory parts of a stream\npipeline. Option B is incorrect because a Stream must return objects. Specialized interfaces \nlike IntStream are needed to return primitives. Option C is incorrect because Stream has \nmethods such as of() and iterate() that return a Stream. Option D is incorrect because \ninfinite streams are possible."
  },
  {
    "number": 59,
    "chapter": 6,
    "question": "Given an IntStream, which method would you use to obtain an equivalent parallel \nStream\u003cT\u003e?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "parallel()",
      "parallelStream()",
      "parallels()",
      "getParallel()",
      "getParallelStream()",
      "None of the above"
    ],
    "explanation": "Trick question! The correct method to obtain an equivalent parallel stream of an existing\nIntStream is parallel(), but for an IntStream this returns another IntStream, not \na generic Stream\u003cT\u003e. For this reason, option F is correct."
  },
  {
    "number": 60,
    "chapter": 6,
    "question": "Which can fill in the blank to have the code print true?\nvar stream \u003d Stream.iterate(1, i -\u003e i+1);\nvar b \u003d stream.________(i -\u003e i \u003e 5);\nSystem.out.println(b);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "anyMatch",
      "allMatch",
      "noneMatch",
      "None of the above"
    ],
    "explanation": "This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc. The Predicate\nchecks if the element is greater than 5 .  With anyMatch(), the stream pipeline ends once \nelement 6 is hit, and the code prints true. For the allMatch() operator, it sees that the  \nfirst element in the stream does not match, and the code prints false. Similarly, the  \nnoneMatch() operator gets to the point where i is 6 and returns false because there is a \nmatch. Therefore, option A is correct."
  },
  {
    "number": 61,
    "chapter": 6,
    "question": "Which of the following fills in the blank so that the code outputs one line but uses a \npoor practice?\nimport java.util.*;\n \npublic class Cheater {\n   int count \u003d 0;\n   public void sneak(Collection\u003cString\u003e coll) {\n      coll.stream()._____________________________;\n   }\n \n   public static void main(String[] args) {\n      var c \u003d new Cheater();\n      c.sneak(Arrays.asList(\"weasel\"));\n  }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "peek(System.out::println)",
      "peek(System.out::println).findFirst()",
      "peek(r -\u003e System.out.println(r)).findFirst()",
      "peek(r -\u003e {count++; System.out.println(r); }).findFirst()",
      "None of the above compile.",
      "None of these are bad practice."
    ],
    "explanation": "Option A is incorrect because it doesn’t print out one line. The peek() method is an\nintermediate operation. Since there is no terminal operation, the stream pipeline is not exe-\ncuted, so the peek() method is never executed, and nothing is printed. Options B and C \nare incorrect because they correctly output one line using a method reference and lambda, \nrespectively, and don’t use any bad practices. Option D is the correct answer. It does output \none line. However, it is bad practice to have a peek() method that has side effects like mod-\nifying a variable."
  },
  {
    "number": 62,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage nesting;\nimport java.util.function.*;\n \npublic class Doll {\n   private int layer;\n   public Doll(int layer) {\n      super();\n      this.layer \u003d layer;\n   }\n \n   public static void open(\n      UnaryOperator\u003cDoll\u003e task, Doll doll) {\n \n      while((doll \u003d task.accept(doll)) !\u003d null) {\n         System.out.print(\"X\");\n      }\n   }\n \n   public static void main(String[] wood) {\n      open(s -\u003e {\n         if(s.layer\u003c\u003d0) return null;\n         else return new Doll(s.layer--);\n      }, new Doll(5));\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "XXXXX",
      "The code does not compile because of the lambda expression.",
      "The code does not compile for a different reason.",
      "The code compiles, but produces an infinite loop at runtime.",
      "The code compiles, but throws an exception at runtime."
    ],
    "explanation": "The code does not compile, so option A, D, and E are incorrect. The lambda expres\nsion compiles without issue, making option B incorrect. The task variable is of type \nUnaryOperator\u003cDoll\u003e, with the abstract method apply(). There is no accept() \nmethod defined on that interface, therefore the code does not compile, and option C is the \ncorrect answer. If the code was corrected to use the apply() method, the rest of it would \ncompile without issue. At runtime, it would then produce an infinite loop. On each iteration \nof the loop, a new Doll instance would be created with 5, since the post-decrement (--) \noperator returns the original value of the variable, and that would be option  D ."
  },
  {
    "number": 63,
    "chapter": 6,
    "question": "What is the expected output of the following code snippet?\nRandom r \u003d new Random();\nStream.generate(r::nextDouble)\n   .skip(2)\n   .limit(4)\n   .sorted()\n   .peek(System.out::println)\n   .forEach(System.out::println);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "It does not compile.",
      "It throws an exception at runtime.",
      "It does not print any output at runtime.",
      "It prints four numbers twice each.",
      "It can print up to eight distinct numbers.",
      "The behavior of the code snippet cannot be determined until runtime."
    ],
    "explanation": "The code compiles and does not throw any exception at runtime, so options A and B are\nincorrect. As an element goes through the pipeline, it is printed once by the peek() method, \nthen once by the forEach() method. For example, 0 .1  0 .1  0 .54  0 .54  0 .6  0 .6  0 .3 \n0 .3 is a possible output from this code. For this reason, option D is correct."
  },
  {
    "number": 64,
    "chapter": 6,
    "question": "Which statements about the findAny() method applied to a stream are correct? \n(Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      5
    ],
    "userAnswers": [
      1,
      3,
      5
    ],
    "options": [
      "It always returns the first element on an ordered serial stream.",
      "It may return any element on an ordered serial stream.",
      "It always returns the first element on an unordered stream.",
      "It may return any element on an unordered stream.",
      "It always returns the first element on an ordered parallel stream.",
      "It may return any element on an ordered parallel stream."
    ],
    "explanation": "The findAny() method is capable to return any element of the stream regardless of\nwhether it is serial, parallel, ordered, or unordered. For this reason, options B, D, and F are \ncorrect. Option C is actually invalid, as an unordered stream does not have a first element."
  },
  {
    "number": 65,
    "chapter": 6,
    "question": "Which functional interface has a get() method?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Consumer",
      "Function",
      "Supplier",
      "UnaryOperator",
      "None of the above"
    ],
    "explanation": "To begin with, Consumer uses accept(), making option A incorrect. Next, Function\nand UnaryOperator use apply(), making options B and D, respectively, incorrect. Finally, \nSupplier uses get(), making option C the correct answer."
  },
  {
    "number": 66,
    "chapter": 6,
    "question": "Why can’t String::charAt be used as a method reference within a Function?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Method references can only be used on static methods.",
      "The charAt() method takes an int rather than Integer parameter.",
      "The method reference is not compatible with Function.",
      "The method reference syntax is illegal.",
      "There is no charAt() method in the String class.",
      "None of the above."
    ],
    "explanation": "Option D is incorrect as the syntax is fine. Option E is incorrect because there is a\ncharAt() instance method. While option B is correct that the method takes in an int \nparameter, autoboxing would take care of conversion for us if there were no other prob-\nlems. So, option B is not the answer either. Option A is not true because there are con-\nstructor and instance method references. This method reference could be assigned to \nBiFunction\u003cString,Integer, Character\u003e. However, it cannot be assigned to a \nFunction. This makes option C the correct answer."
  },
  {
    "number": 67,
    "chapter": 6,
    "question": "Given the following independent stream operations, which statements are correct? \n(Choose three.)\nList.of(2,4,6,8)\n   .parallel()\n   .parallelStream()\n   .forEach(System.out::print);\n \nList.of(2,4,6,8)\n   .parallelStream()\n   .parallel()\n   .forEach(System.out::print);\n \nList.of(2,4,6,8)\n   .parallelStream()\n   .parallel().parallel().parallel()\n   .forEach(System.out::print);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      3
    ],
    "userAnswers": [
      0,
      4,
      5
    ],
    "options": [
      "The first stream operation compiles.",
      "The second stream operation compiles.",
      "The third stream operation compiles.",
      "None of the stream operations that compile produce an exception at runtime.",
      "At least one of the stream operations that compiles produces at exception at runtime.",
      "The output of the stream operations that compile is consistent between executions."
    ],
    "explanation": "While the second and third stream operations compile, the first does not. The\nparallel() method should be applied to a stream, while the parallelStream() \nmethod should be applied to a Collection\u003cE\u003e. For this reason, option A is incorrect, and \noptions B and C are correct. Neither the second or third stream operation are expected to \nproduce an exception at runtime, making option D correct and option E incorrect. Note that \ncalling parallel() on an already parallel stream is unnecessary but allowed. Finally, the \noutput of the second and third stream operations will vary at runtime since the streams are \nparallel, making option F incorrect."
  },
  {
    "number": 68,
    "chapter": 6,
    "question": "Which method reference can replace the lambda on the first line so the output is the same?\nBiPredicate\u003cString, String\u003e pred \u003d (a, b) -\u003e a.contains(b);\nSystem.out.println(pred.test(\"fish\", \"is\"));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "a::contains(b)",
      "a::contains",
      "String::contains(b)",
      "String::contains",
      "The supplied code does not compile.",
      "None of the above."
    ],
    "explanation": "Since the code uses a BiPredicate, it takes two parameters in the test() call. The\nfirst is the instance of String and the second is the substring value to check. Since both \nparameters are passed in, we use the type of String in the method reference, making option \nD the correct answer."
  },
  {
    "number": 69,
    "chapter": 6,
    "question": "What is the result of the following?\nimport static java.util.stream.Collectors.*;\nimport java.util.stream.Stream;\n \nclass Ballot {\n   private String name;\n   private int judgeNumber;\n   private int score;\n \n   public Ballot(String name, int judgeNumber, int score) {\n      this.name \u003d name;\n      this.judgeNumber \u003d judgeNumber;\n      this.score \u003d score;\n   }\n   // all getters and setters\n}\n \npublic class Speaking {\n   public static void main(String[] args) {\n      Stream\u003cBallot\u003e ballots \u003d Stream.of(\n         new Ballot(\"Mario\", 1, 10),\n         new Ballot(\"Christina\", 1, 8),\n         new Ballot(\"Mario\", 2, 9),\n         new Ballot(\"Christina\", 2, 8)\n      );\n \n      var scores \u003d ballots.collect(\n         groupingBy(Ballot::getName, \n         summingInt(Ballot::getScore)));\n      System.out.println(scores.get(\"Mario\"));\n  }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "2",
      "18",
      "19",
      "110",
      "The code does not compile."
    ],
    "explanation": "This code compiles. It creates a stream of Ballot objects. Then it creates a map with the\ncontestant’s name as the key and the sum of the scores as the value. For Mario, this is 10 + \n9, or 19, so option C is correct."
  },
  {
    "number": 70,
    "chapter": 6,
    "question": "Which of the following can fill in the blank to have the code print 44?\nvar stream \u003d Stream.of(\"base\", \"ball\");\nstream. (s -\u003e s.length()).forEach(System.out::print);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Only map",
      "Only mapToInt",
      "Only mapToObject",
      "Both map and mapToInt",
      "Both map and mapToObject",
      "map, mapToInt, and mapToObject"
    ],
    "explanation": "The map() method can fill in the blank. The lambda converts a String to an int, and\nJava uses autoboxing to turn that into an Integer. The mapToInt() method can also fill \nin the blank, and Java doesn’t even need to autobox. There isn’t a mapToObject() in the \nstream API. Note there is a similarly named mapToObj() method on IntStream. Since \nboth map() and mapToInt() work here, option D is correct."
  },
  {
    "number": 71,
    "chapter": 6,
    "question": "What does the following do? (Choose two.)\npublic class Shoot {\n   interface Target {\n      boolean needToAim(double angle);\n   }\n   static void prepare(double angle, Target t) {\n      boolean ready \u003d t.needToAim(angle);  // k1\n      System.out.println(ready);\n   }\n   public static void main(String[] args) {\n      prepare(45, d -\u003e d \u003e 5 || d \u003c -5);   // k2\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [
      0,
      2,
      0,
      2
    ],
    "options": [
      "If any compiler errors are fixed, it prints true.",
      "If any compiler errors are fixed, it prints false.",
      "It compiles without issue.",
      "It doesn’t compile due to line k1.",
      "It doesn’t compile due to line k2."
    ],
    "explanation": "This is a correct example of code that uses a lambda. The interface has a single abstract\nmethod. The lambda correctly takes one double parameter and returns a boolean. This \nmatches the interface. The lambda syntax is correct. Since it compiles, option C is correct. \nFinally, option A is correct because 45 is greater than 5 ."
  },
  {
    "number": 72,
    "chapter": 6,
    "question": "Which statements about the following code are correct?\nvar data \u003d List.of(1,2,3);\nint f \u003d data.parallelStream()\n   .reduce(1, (a,b) -\u003e a+b, (a,b) -\u003e a+b);\nSystem.out.println(f);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It consistently prints 6.",
      "It consistently prints 7.",
      "It consistently prints another value.",
      "It does not consistently print the same value on every execution.",
      "It compiles but throws an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The reduction is parallel, but since the accumulator and combiner are well-behaved (state\nless and associative), the result is consistent, making option D incorrect. The identity is 1, \nwhich is applied to every element meaning the operation sums the values (1+1), (1+2), and \n(1+3). For this reason, 9 is consistently printed at runtime, making option C correct."
  },
  {
    "number": 73,
    "chapter": 6,
    "question": "What is the result of the following?\n11: var s1 \u003d IntStream.empty();\n12: System.out.print(s1.average().getAsDouble());\n13:\n14: var s2 \u003d IntStream.of(-1,0, 1);\n15: System.out.print(s2.average().getAsDouble());",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Both statements print 0.",
      "Both statements print 0.0.",
      "The statements print different values.",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "The average() method returns an OptionalDouble. This interface has a \ngetAsDouble() method rather than a get() method, so the code does compile. However, \nthe stream is empty, so the optional is also empty. When trying to get the value on line 12, the \ncode throws a NoSuchElementException, making option E correct."
  },
  {
    "number": 74,
    "chapter": 6,
    "question": "Which lambdas can replace the method references in this code? (Choose two.)\nStream.of(\"fish\", \"mammal\", \"amphibian\")\n   .map(String::length)\n   .findFirst()\n   .ifPresent(System.out::println);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "x.length()",
      "x -\u003e x.length()",
      "x -\u003e x::length",
      "System.out.println(s)",
      "s -\u003e System.out.println(s)",
      "s -\u003e System.out::println"
    ],
    "explanation": "Options A and D are incorrect since they are missing the arrow (-\u003e), which makes them\nlambdas. Options C and F are incorrect as they try to mix lambdas and method references. \nThis leaves options B and E as the answers."
  },
  {
    "number": 75,
    "chapter": 6,
    "question": "What collector can turn the stream at left to the Map at right?\n",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Only grouping()",
      "Only groupingBy()",
      "Only partitioning()",
      "Only partitioningBy()",
      "Both grouping() and partitioning()",
      "Both groupingBy() and partitioningBy()"
    ],
    "explanation": "Both Collectors.groupingBy() and Collectors.partitioningBy() are \nuseful for turning a stream into a Map. The other two methods do not exist. The  \npartitioningBy() method automatically groups using a Boolean key. However,  \nwe can also have a Boolean key with groupingBy(). For example, we could write  \ns -\u003e s.length() \u003e 3 .  Therefore, option F is correct."
  },
  {
    "number": 76,
    "chapter": 6,
    "question": "Which expression is compatible with the IntSupplier functional interface?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "() -\u003e 1\u003c10 ? \"3\" : 4",
      "() -\u003e {return 1/0;}",
      "() -\u003e return 4",
      "System.out::print",
      "None of the above"
    ],
    "explanation": "Option A is incorrect because \"3\" is a String, which is not compatible with the\nreturn type int required for IntSupplier. Option B is the correct answer. Although this \nwill result in a divide-by-zero issue at runtime, the lambda is valid and compatible with \nIntSupplier. Option C is incorrect because the lambda expression is invalid. The return \nstatement is allowed only inside a set of braces ({}). Finally, option D is incorrect. The \nmethod reference is used for Consumer, not Supplier, since it takes a value and does not \nreturn anything."
  },
  {
    "number": 77,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage beach;\nimport java.util.function.*;\n \nclass Tourist {\n   public Tourist(double distance) {\n      this.distance \u003d distance;\n   }\n   public double distance;\n}\npublic class Lifeguard {\n   private void saveLife(Predicate\u003cTourist\u003e canSave, \n      Tourist tourist) {\n      \n     System.out.print(canSave.test(tourist) \n        ? \"Saved\" : \"Too far\");\n   }\n   public final static void main(String... sand) {\n      new Lifeguard().saveLife(s -\u003e s.distance\u003c4, \n         new Tourist(2));\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Saved",
      "Too far",
      "The code does not compile because of the main() method.",
      "The code does not compile because of the saveLife() method.",
      "None of the above."
    ],
    "explanation": "The code compiles without issue, so options C and D are incorrect. The value for distance\nis 2, which based on the lambda for the Predicate will result in a true expression, and \nSaved will be printed, making option A correct."
  },
  {
    "number": 78,
    "chapter": 6,
    "question": "Given a LinkedList\u003cE\u003e, which method would you call to obtain a parallel stream that uses it \nas a data source?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "getParallel()",
      "parallels()",
      "getParallelStream()",
      "parallel()",
      "parallelStream()",
      "None of the above"
    ],
    "explanation": "The correct method to obtain a parallel stream from a Collection\u003cE\u003e is \nparallelStream(), making option E correct."
  },
  {
    "number": 79,
    "chapter": 6,
    "question": "How many lines does the following code output?\nimport java.util.*;\nclass Blankie {\n   String color;\n   String getColor() {\n      return color;\n   }\n}\npublic class PreSchool {\n   public static void main(String[] args) {\n      var b1 \u003d new Blankie();\n      var b2 \u003d new Blankie();\n      b1.color \u003d \"pink\";\n      List\u003cBlankie\u003e list \u003d Arrays.asList(b1, b2);\n      list.stream()\n         .filter(Blankie::getColor)       // line x\n         .forEach(System.out::println);   // line y\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One.",
      "Two.",
      "The code does not compile due to line x.",
      "The code does not compile due to line y.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "The filter() method takes a Predicate, which requires a boolean return type from\nthe lambda or method reference. The getColor() method returns a String and is not \ncompatible. This causes the code to not compile and option C to be the answer."
  },
  {
    "number": 80,
    "chapter": 6,
    "question": "Which are true statements? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "A source cannot return an infinite stream.",
      "A source may return an infinite stream.",
      "A source must return an infinite stream.",
      "An intermediate operation cannot return an infinite stream.",
      "An intermediate operation may return an infinite stream.",
      "An intermediate operation must return an infinite stream."
    ],
    "explanation": "The generate() and iterate() sources return an infinite stream. Further, the of()\nsource returns a finite stream, which shows option B is one of the answers.\nThe limit() intermediate operation returns a finite stream. When given an infinite stream, \nthe map() intermediate operations keeps the infinite stream, which means option E is the \nother correct answer."
  },
  {
    "number": 81,
    "chapter": 6,
    "question": "How many of these lines have compiler errors?\n14: Consumer\u003cObject\u003e c1 \u003d ArrayList::new;\n15: Consumer\u003cObject\u003e c2 \u003d String::new;\n16: Consumer\u003cObject\u003e c3 \u003d System.out::println;\n17: var c4 \u003d ArrayList::new;\n18: var c5 \u003d String::new;\n19: var c6 \u003d System.out::println;",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "Five.",
      "The code compiles as is."
    ],
    "explanation": "Like a lambda, method references use type inference. When assigned to a local variable,\nvar cannot be used because there is not enough information to infer the type. Due to this, \nlines 17, 18, and 19 do not compile.\nConsumer\u003cObject\u003e takes a single Object argument and does not return any data. The \nclasses ArrayList and String do not contain constructors that take an Object, so \nlines 14 and 15 do not compile either. Line 16 does support an Object variable, since the \nSystem.out.println(Object) method exists. For these reasons, option E is the correct \nanswer."
  },
  {
    "number": 82,
    "chapter": 6,
    "question": "What is the output of the following program?\nvar p \u003d List.of(new StringBuilder(\"hello\"),\n   new StringBuilder(\"goodbye\"));\nvar q \u003d p.parallelStream().reduce(0,\n   (w,x) -\u003e w.length() + x.length(),\n   (y,z) -\u003e y.length() + z.length());\nSystem.out.print(q);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "0",
      "12",
      "14",
      "One line does not compile.",
      "Two lines do not compile.",
      "None of the above."
    ],
    "explanation": "Based on the reduction operation, the data types of w, y, and z are Integer, while \nthe data type of x is StringBuilder. Since Integer does not define a length() \nmethod, both the accumulator and combiner lambda expressions are invalid, making option \nE correct."
  },
  {
    "number": 83,
    "chapter": 6,
    "question": "What is true of this code? (Choose two.)\nvar bools \u003d Stream.of(Boolean.TRUE, null);\nvar map \u003d bools\n   .limit(1)    // line k\n   .collect(partitioningBy(b -\u003e b));\nSystem.out.println(map);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      0,
      5
    ],
    "options": [
      "It outputs {true\u003d[true]}.",
      "It outputs {false\u003dnull, true\u003d[true]}.",
      "It outputs {false\u003d[], true\u003d[true]}.",
      "It outputs {false\u003d[null], true\u003d[true]}.",
      "The output is the same if line k is removed.",
      "The output is different after line k is removed."
    ],
    "explanation": "The first intermediate operation, limit(1), gets rid of the null. The \npartitioningBy() method returns a map with two keys, true and false, regardless \nof whether any elements actually match. If there are no matches, the value is an empty list, \nmaking option C correct. If line k is removed, the code throws a NullPointerException, \nsince null is neither true nor false. Therefore, option F is the other answer."
  },
  {
    "number": 84,
    "chapter": 6,
    "question": "What is the output of the following code snippet?\nvar apples \u003d List.of(1, 2);\nvar oranges \u003d List.of(1, 2);\nfinal var count \u003d Stream.of(apples, oranges)\n   .flatMapToInt(List::stream)\n   .peek(System.out::print)\n   .count();\nSystem.out.print(count);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "12124",
      "11224",
      "122",
      "The code does not compile.",
      "The code compiles but does not output anything at runtime.",
      "None of the above."
    ],
    "explanation": "The code does not compile because flatMapToInt() requires a Function with a\nreturn value of IntStream, not Stream, making option D correct."
  },
  {
    "number": 85,
    "chapter": 6,
    "question": "Which functional interface, when filled into the blank, prevents the class from compiling?\npackage morning;\nimport java.util.function.*;\n \npublic class Sun {\n   public static void dawn(  sunrise) {}\n   public void main(String... rays) {\n      dawn(s -\u003e s+1);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "DoubleUnaryOperator",
      "Function\u003cString,String\u003e",
      "IntToLongFunction",
      "UnaryOperator",
      "All of the above allow the code to compile."
    ],
    "explanation": "A lambda expression can match multiple functional interfaces. It matches \nDoubleUnaryOperator, which takes a double value and returns a double value.  \nNote that the data type of s+1 is double because one of the operands, in this case s, is \ndouble. It also matches Function\u003cString,String\u003e since the addition (+) operator can \nbe used for String concatenation. Finally, it matches IntToLongFunction, since the int \nvalue s+1 can be implicitly cast to long. On the other hand, the lambda expression is not \ncompatible with UnaryOperator without a generic type. When UnaryOperator is used \nwithout a generic argument, the type is assumed to be Object. Since the addition operator \nis not defined on Object, the code does not compile due to the lambda expression body, \nmaking option D the correct answer. Note that if the lambda expression did not rely on the \naddition operator, such as s -\u003e s, then UnaryOperator would be allowed by the com-\npiler, even without a generic type."
  },
  {
    "number": 86,
    "chapter": 6,
    "question": "Which statements about applying forEachOrdered() to a parallel ordered stream instead of \nusing forEach() are correct? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "The operation will likely be faster.",
      "The operation will likely be slower.",
      "There is no expected change in performance.",
      "It forces some stream operations in the pipeline to be performed in a serial manner.",
      "It forces all stream operations in the pipeline to be performed in a serial manner.",
      "All stream operations will continue to be performed in a parallel manner."
    ],
    "explanation": "Applying forEachOrdered() to a parallel stream forces the terminal operation to be\nperformed in a single-threaded, rather than parallel, manner. For this reason, it is likely that \nit will be slower, making option B correct. Intermediate operations can still take advantage of \nparallel processing, since forEachOrdered() is only applied at the end of the pipeline. For \nthis reason, option D is correct."
  },
  {
    "number": 87,
    "chapter": 6,
    "question": "What is the true of the following? (Choose two.)\nIntegerSummaryStatistics stats \u003d Stream.of(20, 40)\n   .mapToInt(i -\u003e i)\n   .summaryStatistics();\nlong total \u003d stats.getSum();\nlong count \u003d stats.getCount();\nlong max \u003d stats.getMax();\nSystem.out.println(total + \"-\" + count + \"-\" + max);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      3,
      5
    ],
    "options": [
      "The output is 60-0-40",
      "The output is 60-2-40",
      "The code does not compile for one reason.",
      "The code does not compile for two reasons.",
      "Correct code could be written without summary statistics using a single stream pipeline.",
      "Correct code could not be written without summary statics using a single stream "
    ],
    "explanation": "The code does not compile because the class should be IntSummaryStatistics, not\nIntegerSummaryStatistics. This makes option C correct. The purpose of using the \nsummary statistics class is to avoid multiple trips through the stream pipeline, making option \nF the other answer."
  },
  {
    "number": 88,
    "chapter": 6,
    "question": "What is a difference between lambdas and method references?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Only one can take a method parameter.",
      "Only one can reference an effectively final local variable.",
      "Only one can make a method call where the method parameter is the hard-coded number 3.",
      "Only one can use deferred execution.",
      "None of the above."
    ],
    "explanation": "Both lambda and method references can be passed to another method as a parameter and\nexecuted later ruling out options A and D .  One big difference is with a lambda like: () -\u003e \ns.charAt(3). The s variable must be final or effectively final variable in both lambdas \nand method references, making option B incorrect. However, there isn’t a way to use the \nhard-coded number in a method reference. Therefore, option C is a difference and the answer."
  },
  {
    "number": 89,
    "chapter": 6,
    "question": "Following the generate() method, which of the four method calls in this code can be removed \nand have the method still compile and run without error?\npublic static void main(String[] args) {\n   Stream.generate(() -\u003e \u0027a\u0027)\n      .limit(5)\n      .filter(c -\u003e c \u003c \u0027b\u0027)\n      .sorted()\n      .findFirst()\n      .ifPresent(System.out::print);\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "filter()",
      "sorted()",
      "filter() and sorted()",
      "filter() and ifPresent()",
      "filter(), sorted(), and ifPresent()",
      "filter(), sorted(), findFirst(), and ifPresent()"
    ],
    "explanation": "A stream pipeline is allowed to have zero or more intermediate operations. This means\nboth filter() and sorted() can be removed. The source and terminal operations are \nrequired, so cannot be removed. Therefore, generate() and findFirst() must stay. The \nifPresent() call is not part of the stream pipeline. It is a method on Optional."
  },
  {
    "number": 90,
    "chapter": 6,
    "question": "What is true of the following? (Choose three.)\nimport java.util.*;\npublic class Catch {\n   public static void main(String[] args) {\n      Optional opt \u003d Optional.empty();\n      var message \u003d \"\";\n      try {\n         message \u003d (opt);\n      } catch (IllegalArgumentException e) {\n         System.out.print(\"Caught it\");\n      }\n      System.out.print(message);\n   }\n   private static String x(Optional\u003cString\u003e opt) {\n      return opt.orElseThrow();\n   }\n   private static String y(Optional\u003cString\u003e opt) {\n      return opt.orElseThrow(IllegalArgumentException::new);\n   }\n   private static String z(Optional\u003cString\u003e opt) {\n      return opt.orElse(\"Caught it\");\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "If filling in the blank with method x, the code outputs Caught it.",
      "If filling in the blank with method x, the code prints a stack trace.",
      "If filling in the blank with method y, the code outputs Caught it.",
      "If filling in the blank with method y, the code prints a stack trace.",
      "If filling in the blank with method z, the code outputs Caught it.",
      "If filling in the blank with method z, the code prints a stack trace."
    ],
    "explanation": "The orElseThrow() method throws a NoSuchElementException when the\nOptional is empty. Since this exception is not caught, a stack trace is printed. This matches \noption  B .  The overloaded method that takes a parameter throws the specified exception. \nSince we do catch an IllegalArgumentException, the code prints the message, which is \noption  C . Finally, the orElse() method returns the specified string, and option E is correct."
  },
  {
    "number": 91,
    "chapter": 6,
    "question": "Which statement is not true of Predicate?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "A boolean is returned from the method it declares.",
      "It is an interface.",
      "The method it declares accepts two parameters.",
      "The method it declares is named test.",
      "All of the above are true."
    ],
    "explanation": "Predicate is an interface with one method. The method signature is boolean test(T\nt). Option C is the answer because the method accepts one parameter rather than two."
  },
  {
    "number": 92,
    "chapter": 6,
    "question": "Which functional interface does not have the correct number of generic arguments? \n(Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2
    ],
    "userAnswers": [],
    "options": [
      "BiFunction\u003cT,U,R\u003e",
      "BinaryOperator\u003cT, U\u003e",
      "DoubleFunction\u003cT,R\u003e",
      "ToDoubleFunction\u003cT\u003e",
      "ToIntBiFunction\u003cT,U\u003e"
    ],
    "explanation": "The BiFunction interface takes two different generic values and returns a generic\nvalue, taking a total of three generic arguments. Next, ToDoubleFunction takes exactly \none generic value and returns a double value, requiring one generic argument. The  \nToIntBiFunction interface takes two generic values and returns an int value, for a total \nof two generic arguments. For these reasons, Options A, D, and E have the correct number \nof generics.\nBinaryOperator\u003cT\u003e takes two parameters of a generic type and returns the same type. \nTherefore, only one generic is needed when declaring the type. DoubleFunction\u003cR\u003e takes \na double value and returns a generic result, taking exactly one generic argument, not two. \nThis makes the answer options B and  C ."
  },
  {
    "number": 93,
    "chapter": 6,
    "question": "How many changes need to be made to the following stream operation to execute a parallel \nreduction?\nvar r \u003d new Random();\nvar data \u003d Stream.generate(() -\u003e String.valueOf(r.nextInt()))\n   .limit(50_000_000)\n   .collect(Collectors.toSet());\nvar map \u003d data.stream()\n   .collect(Collectors.groupingBy(String::length));",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "None, it is already a parallel reduction.",
      "One.",
      "Two.",
      "Three.",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "To execute a parallel reduction with the collect() method, the stream or Collector\nmust be unordered, the Collector must be concurrent, and the stream must be parallel. \nSince an unordered Set is used as the data source, the first property is fulfilled. To be a \nparallel reduction, though, Collectors.groupByConcurrent() should be used instead \nof Collectors.groupingBy(). In addition, parallelStream() should be called on \nthe Set, instead of stream(). For these two reasons, option C is correct."
  },
  {
    "number": 94,
    "chapter": 6,
    "question": "What is the output of this code?\nStream.of(\"one\", \"two\", \"bloat\")\n   .limit(1)\n   .map(String::toUpperCase)       // line x\n   .sorted()\n   .forEach(System.out::println);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "bloat",
      "BLOAT",
      "one",
      "ONE",
      "The code does not compile due to line x.",
      "None of the above."
    ],
    "explanation": "This is a correct stream pipeline. The source creates a stream of three elements. The first\noperation makes a stream of one element, one. Then that single element is made uppercase \nand sorted to complete the intermediate operations. Finally, the terminal operation prints \nONE, which corresponds to option  D ."
  },
  {
    "number": 95,
    "chapter": 6,
    "question": "Which lambda expression can be passed to the magic() method?\npackage show;\nimport java.util.function.*;\n \npublic class Magician {\n   public void magic(BinaryOperator\u003cLong\u003e lambda) {\n      lambda.apply(3L, 7L);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "(a) -\u003e a",
      "(b,w) -\u003e (long)w.intValue()",
      "(c,m) -\u003e {long c\u003d4; return c+m;}",
      "(Integer d, Integer r) -\u003e (Long)r+d",
      "None of the above"
    ],
    "explanation": "BinaryOperator\u003cLong\u003e takes two Long arguments and returns a Long value. For\nthis reason, option A, which takes one argument, and option D, which takes two Integer \nvalues that do not inherit from Long, are both incorrect. Option C is incorrect because the \nlocal variable c is re-declared inside the lambda expression, causing the expression to fail \nto compile. The correct answer is option B because intValue() can be called on a Long \nobject. The result is then be cast to long, which is autoboxed to Long."
  },
  {
    "number": 96,
    "chapter": 6,
    "question": "Fill in the blank: ______________ is the only functional interface that does not involve  \ndouble, int, or long.",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "BooleanSupplier",
      "CharPredicate",
      "FloatUnaryOperator",
      "ShortConsumer",
      "None of the above"
    ],
    "explanation": "BooleanSupplier is the only functional interface that does not involve double,\nint, or long, making option A the correct answer. The rest of the functional interfaces are \nnot found in java.util.function. Java does not have built-in support for primitive \nfunctional interfaces that include char, float, or short."
  },
  {
    "number": 97,
    "chapter": 6,
    "question": "Which statements about parallel streams are correct? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3,
      5
    ],
    "userAnswers": [],
    "options": [
      "A parallel stream is always faster than a serial stream.",
      "The JVM will automatically apply a parallel stream operation to an arbitrary stream in\norder to boost performance.",
      "A parallel stream synchronizes its operations so that they are atomic.",
      "All streams can be converted to a parallel stream.",
      "If a stream uses a reduction method, the result will be the same regardless of whether the\nstream is parallel or serial.",
      "Sometimes, a parallel stream will still operate in a single-threaded manner."
    ],
    "explanation": "Certain stream operations, such as limit() or skip(), force a parallel stream to\nbehave in a serial manner, so option A is incorrect, and option F is correct. Option B is \nalso incorrect. The stream must be explicitly set to be parallel in order for the JVM to \napply a parallel operation. Option C is incorrect because parallel stream operations are not \nsynchronized. It is up to the developer to provide synchronization or use a concurrent col-\nlection if required. Option D is also correct. The BaseStream interface, which all streams \ninherit, includes a parallel() method. Of course, the results of an operation may change \nin the presence of a parallel stream, such as using a problematic (non-associative) accumu-\nlator. For this reason, option E is incorrect."
  },
  {
    "number": 98,
    "chapter": 6,
    "question": "What is the output of the following?\nvar s \u003d Stream.of(\"over the river\",\n    \"through the woods\",\n    \"to grandmother\u0027s house we go\");\n \ns.filter(n -\u003e n.startsWith(\"t\"))\n   .sorted(Comparator::reverseOrder)\n   .findFirst()\n   .ifPresent(System.out::println);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "over the river",
      "through the woods",
      "to grandmother\u0027s house we go",
      "None of the above"
    ],
    "explanation": "The sorted() method allows an optional Comparator to be passed as a reference.\nHowever, Comparator.reverseOrder() does not implement the Comparator inter-\nface. It takes zero parameters instead of the required two. Since it cannot be used as a \nmethod reference, the code does not compile, and option D is correct."
  },
  {
    "number": 99,
    "chapter": 6,
    "question": "Which can fill in the blank to have the code print the single digit 9?\nvar stream \u003d LongStream.of(9);\nstream.____________(p -\u003e p).forEach(System.out::print);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "Only mapToDouble",
      "Only mapToInt",
      "Only mapToLong",
      "Both mapToDouble and mapToInt",
      "mapToDouble, mapToInt, and mapToLong",
      "None of the above"
    ],
    "explanation": "The mapToDouble() method compiles. However, it converts 9 into 9.0 rather than\nthe single digit 9 .  The mapToInt() method does not compile because a long cannot be \nconverted into an int without casting. The mapToLong() method is not available on \nLongStream so it does not compile. It is available on DoubleStream, IntStream, and \nStream implementations. Since none of the options outputs the single digit 9, option F is \ncorrect."
  },
  {
    "number": 100,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage savings;\nimport java.util.function.*;\n \npublic class Bank {\n   private int savingsInCents;\n   private static class ConvertToCents {\n      static DoubleToIntFunction f \u003d p -\u003e p*100;\n   }\n   public static void main(String... currency) {\n      Bank creditUnion \u003d new Bank();\n      creditUnion.savingsInCents \u003d 100;\n      double deposit \u003d 1.5;\n \n      creditUnion.savingsInCents +\u003d \n         ConvertToCents.f.applyAsInt(deposit);  // j1\n      System.out.print(creditUnion.savingsInCents);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "100",
      "200",
      "250",
      "The code does not compile because of line j1.",
      "None of the above."
    ],
    "explanation": "The code does not compile because the lambda expression p -\u003e p*100 is not compat\nible with the DoubleToIntFunction functional interface. The input to the functional \ninterface is double, meaning p*100 is also double. The functional interface requires \na return value of int, and since double cannot be implicitly cast to int, the code does \nnot compile, making option E the correct answer. If the correct cast was applied to make \n(p*100) an int, then the rest of the class would compile and 250 would be printed at \nruntime, making option C correct."
  },
  {
    "number": 101,
    "chapter": 6,
    "question": "Which statements about stateful lambda expressions are correct? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [],
    "options": [
      "Stateful lambda expressions should be avoided on both serial and parallel streams.",
      "Stateful lambda expressions should be avoided on only serial streams.",
      "Stateful lambda expressions should be avoided on only parallel streams.",
      "One way to avoid modifying a List with a stateful lambda expression is to use a\nconcurrent collection.",
      "One way to avoid modifying a List with a stateful lambda expression is to use a\ncollector that outputs a List.",
      "One way to avoid modifying a List with a stateful lambda expression is to use a\nsynchronized list."
    ],
    "explanation": "Stateful lambda expressions should be avoided with both serial and parallel streams\nbecause they can lead to unintended side effects, making option A correct. A common way \nto remove a stateful lambda expression that modifies a List is to have the stream opera-\ntion output a new List. For this reason, option E is correct. Options D and F are incorrect \nbecause while a concurrent or synchronized list may make the stream operation thread-safe, \nthey are still stateful lambda expressions."
  },
  {
    "number": 102,
    "chapter": 6,
    "question": "Which method reference can replace the lambda on the second line so the output is the \nsame?\nvar s \u003d \"fish\";\nPredicate\u003cString\u003e pred \u003d (a) -\u003e s.contains(a);\nSystem.out.println(pred.test(\"fish\", \"is\"));",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "a::contains(b)",
      "a::contains",
      "String::contains(b)",
      "String::contains",
      "The supplied code does not compile.",
      "None of the above."
    ],
    "explanation": "The code does not compile, making option E the answer. In particular, the call to\ntest() should have one parameter instead of two."
  },
  {
    "number": 103,
    "chapter": 6,
    "question": "What is the best example of lazy evaluation?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "The pipeline can execute before seeing all the data.",
      "The pipeline does not begin until the terminal operation is executed.",
      "The pipeline executes all operations as quickly as possible.",
      "The pipeline loses data.",
      "The pipeline takes a nap."
    ],
    "explanation": "Lazy evaluation delays execution until it is needed. Option B is the only one that\nmatches this requirement. While option A is true, this can be done without lazy evaluation. \nOption C requires parallelization rather than deferred execution. Option D is incorrect as \ndata loss is bad. Finally, pipelines are run by the computer, which does not get tired."
  },
  {
    "number": 104,
    "chapter": 6,
    "question": "Which method can be applied to an existing Stream\u003cT\u003e to return a stream with a different \ngeneric type?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "distinct()",
      "iterate()",
      "peek()",
      "sorted()",
      "filter()",
      "None of the above"
    ],
    "explanation": "The distinct() and filter() methods can reduce the number of elements in\na stream but do not change the generic type, making options A and E incorrect. The \niterate() method creates a new stream and cannot be applied to an existing stream, \nmaking option B incorrect. The peek() and sorted() methods do not alter the generic \ntype of the stream, making options C and D incorrect. For these reasons, option F is correct."
  },
  {
    "number": 105,
    "chapter": 6,
    "question": "The ______________ functional interface has an apply() method, while the \n______________ functional interface has an applyAsDouble() method. (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [],
    "options": [
      "BiConsumer",
      "BiFunction",
      "BiPredicate",
      "DoubleConsumer",
      "DoublePredicate",
      "DoubleUnaryOperator"
    ],
    "explanation": "Option B fills in the first blank because BiFunction includes the apply() method.\nDoubleUnaryOperator contains the applyAsDouble() method, making option F \ncorrect. For the exam, pay attention to methods that have a different name for primitives."
  },
  {
    "number": 106,
    "chapter": 6,
    "question": "Given the following code snippet, what statement about the values printed on lines q1 and \nq2 is correct?\nvar mitchsWorkout \u003d new CopyOnWriteArrayList\u003cInteger\u003e();\nList.of(1,5,7,9).stream().parallel()\n   .forEach(mitchsWorkout::add);\nmitchsWorkout\n   .forEachOrdered(System.out::print);  // q1\nList.of(1,5,7,9).stream().parallel()\n   .forEachOrdered(System.out::print);  // q2",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "They are always the same.",
      "They are sometimes the same.",
      "They are never the same.",
      "The code does not compile.",
      "The code will produce a ConcurrentModificationException at runtime.",
      "None of the above."
    ],
    "explanation": "The forEachOrdered() method is available on streams, not collections. For this\nreason, line q1 does not compile. and option D is correct. If the forEach() method was \nused instead, then the code would compile with the values printed on line q1 varying at \nruntime and the values printed on line q2 being consistent."
  },
  {
    "number": 107,
    "chapter": 6,
    "question": "Which of the following can fill in the blank to have the code print out *?\nStream.generate(() -\u003e \"*\")\n   .limit(3)\n   .sorted( )\n   .distinct()\n   .forEach(System.out::println);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "(s,t) -\u003e s.length() - t.length()",
      "String::isEmpty",
      "Both of these will produce the desired output.",
      "Neither of these will allow the code to compile.",
      "The code does not complete regardless of what goes in the blank."
    ],
    "explanation": "The sorted() method takes an optional Comparator as the parameter, which takes\ntwo String parameters and returns an int. Option A is correct because the lambda imple-\nments this interface. Option B is incorrect because the method reference doesn’t take any \nparameters, nor does it return an int. While generate() starts with an infinite stream, \nthe limit() intermediate operation immediately makes it finite. Finally, the distinct() \nintermediate operation gives us one star instead of three."
  },
  {
    "number": 108,
    "chapter": 6,
    "question": "Which statement about functional interfaces and lambda expressions is not true?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "A lambda expression may be compatible with multiple functional interfaces.",
      "A lambda expression must be assigned to a functional interface when it is declared.",
      "A method can return a lambda expression in the form of a functional interface instance.",
      "The compiler uses deferred execution to skip determining whether a lambda expression compiles or not.",
      "All of these are true."
    ],
    "explanation": "Options A, B, and C are true statements about functional interfaces. A lambda may be\ncompatible with multiple functional interfaces, but it must be assigned to a functional inter-\nface when it is declared or passed as a method argument. Also, a method can be created \nwith the return type that matches a functional interface, allowing a lambda expression to be \nreturned. Option D is the correct answer. Deferred execution means the lambda expression \nis not evaluated until runtime, but it is compiled. Compiler errors in the lambda expression \nwill still prevent the code from compiling."
  },
  {
    "number": 109,
    "chapter": 6,
    "question": "Which can fill in the blank to have the code print true?\nvar stream \u003d Stream.iterate(1, i -\u003e i);\nvar b \u003d stream. (i -\u003e i \u003e 5);\nSystem.out.println(b);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "anyMatch",
      "allMatch",
      "noneMatch",
      "None of the above"
    ],
    "explanation": "This code generates an infinite stream of the number 1. The Predicate checks if the\nelement is greater than 5 .  This will never be true. With allMatch(), the stream pipeline \nends after checking the first element. It doesn’t match, so the code prints false. Both  \nanyMatch() and noneMatch() keep checking and don’t find any matches. However, \nthey don’t know if a future stream element will be different, so the code executes infinitely \nuntil the process is terminated. Therefore, option D is correct."
  },
  {
    "number": 110,
    "chapter": 6,
    "question": "Given the following class, how many lines contain compilation errors?\n1:  package showtimes;\n2:  import java.util.*;\n3:  import java.util.function.*;\n4:  public class FindMovie {\n5:     private Function\u003cString\u003e printer;\n6:     protected FindMovie() {\n7:        printer \u003d s -\u003e {System.out.println(s); return s;}\n8:     }\n9:     void printMovies(List\u003cString\u003e movies) {\n10:       movies.forEach(printer);\n11:    }\n12:    public static void main(String[] screen) {\n13:       List\u003cString\u003e movies \u003d new ArrayList\u003c\u003e();\n14:       movies.add(\"Stream 3\");\n15:       movies.add(\"Lord of the Recursion\");\n16:       movies.add(\"Silence of the Lambdas\");\n17:       new FindMovie().printMovies(movies);\n18:    }\n19: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "None. The code compiles as is.",
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "Five."
    ],
    "explanation": "To start with, line 5 does not compile because Function takes two generic arguments,\nnot one. Second, the assignment statement on line 7 does not end with a semicolon (;), so \nit also does not compile. Finally, the forEach() method on line 10 requires a Consumer, \nnot a Function, so this line does not compile. For these three reasons, option D is the \ncorrect answer."
  },
  {
    "number": 111,
    "chapter": 6,
    "question": "Which statements about the findFirst() method applied to a stream are correct? \n(Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      4
    ],
    "userAnswers": [],
    "options": [
      "It always returns the first element on an ordered serial stream.",
      "It may return any element on an ordered serial stream.",
      "It always returns the first element on an unordered stream.",
      "It may return any element on an unordered stream.",
      "It always returns the first element on an ordered parallel stream.",
      "It may return any element on an ordered parallel stream."
    ],
    "explanation": "The findFirst() method always returns the first element on an ordered stream,\nregardless if it is serial or parallel, making options A and E correct. Option D is also correct, \nas it is free to return any element if the stream is unordered. Option C is actually invalid, as \nan unordered stream does not have a first element."
  },
  {
    "number": 112,
    "chapter": 6,
    "question": "Which method reference can replace the lambda in the first line of the main() method to \nproduce the same output?\ninterface Marsupial {\n   void carryInPouch(int size);\n}\npublic class Opossum {\n   public static void main(String[] args) {\n      Marsupial mar \u003d x -\u003e System.out.println(\"Carrying \" + x);\n \n      mar.carryInPouch(1);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "System:out:println",
      "System::out:println",
      "System::out::println",
      "System.out::println",
      "None of the above"
    ],
    "explanation": "The only one of these references to compile is option D. However, the original code\nprints Carrying 1 .  The version with a method reference would just print 1 .  Option E is \nthe answer because this is not the same output."
  },
  {
    "number": 113,
    "chapter": 6,
    "question": "What is true of the following code?\n21: Stream\u003cInteger\u003e s1 \u003d Stream.of(8, 2);\n22: Stream\u003cInteger\u003e s2 \u003d Stream.of(10, 20);\n23: s2 \u003d s1.filter(n -\u003e n \u003e 4);\n24: s1 \u003d s2.filter(n -\u003e n \u003c 1);\n25: System.out.println(s1.count());\n26: System.out.println(s2.count());",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "The code runs without error and prints 0.",
      "The code runs without error and prints 1.",
      "The code throws an exception on line 23.",
      "The code throws an exception on line 24.",
      "The code throws an exception on line 25.",
      "The code throws an exception on line 26."
    ],
    "explanation": "A stream cannot be used again once it is executed. Line 21 creates a stream. Line 22\ncreates a second stream; however, the reference is lost on line 23 .  Lines 23 and 24 add \nintermediate operations to the stream that was created on line 21 .  Due to lazy evaluation, \nthey do not run it. Line 25 does execute the stream pipeline and prints 0 .  However, line \n26 attempts to execute the same stream and throws an IllegalStateException. This \nmatches option  F ."
  },
  {
    "number": 114,
    "chapter": 6,
    "question": "Which changes can be independently made to this code and have it still compile? (Choose \nthree.)\nPredicate\u003cStringBuilder\u003e p \u003d \n   (StringBuilder b) -\u003e {return true;};",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      5
    ],
    "userAnswers": [],
    "options": [
      "Change StringBuilder b to var b.",
      "Change StringBuilder b to b.",
      "Remove StringBuilder b.",
      "Remove -\u003e.",
      "Remove { and ;}.",
      "Remove { return and ;}."
    ],
    "explanation": "Options A and B are correct because the type may be var or omitted in a lambda.\nIf there are multiple parameters, all must be handled the same way. Option C is tricky but \nincorrect. While a lambda can have zero parameters, a Predicate cannot. A Predicate \nis defined as a type mapping to a boolean.\nOption D is clearly incorrect as -\u003e separates the parts of a lambda. Options E and F are \nsimilar. Option E is incorrect because return is allowed only when the braces are present. \nOption F is correct."
  },
  {
    "number": 115,
    "chapter": 6,
    "question": "What does this code output?\nvar babies \u003d Arrays.asList(\"chick\", \"cygnet\", \"duckling\");\nbabies.replaceAll(x -\u003e { var newValue \u003d \"baby\";\n   return newValue; });\nSystem.out.println(newValue);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "baby",
      "chick",
      "cygnet",
      "duckling",
      "The code does not compile."
    ],
    "explanation": "The newValue variable is locally scoped to the lambda. It is not available outside the\nlambda, so the println() does not compile, and option E is the answer."
  },
  {
    "number": 116,
    "chapter": 6,
    "question": "Which lambda expression cannot be assigned to a DoubleToLongFunction functional \ninterface?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "a -\u003e null\u003d\u003dnull ? 1 : 2L",
      "e -\u003e (int)(10.0*e)",
      "(double m) -\u003e {long p \u003d (long)m; return p;}",
      "(Double s) -\u003e s.longValue()",
      "All of these can be assigned."
    ],
    "explanation": "The DoubleToLongFunction interface takes a double argument and returns a long\nvalue. Option A is compatible since the int value 1 can be implicitly cast to long, and 2L \nis already a long. Option B is also compatible, since the double value  10 .0*e is explicitly \ncast to int then implicitly cast to long. Next, option C is compatible because an explicit \ncast of the double to a long value is used. Option D cannot be assigned and is the correct \nanswer. Although the Double class does have a longValue() method, the left-hand side \nof the lambda expression must use the primitive double, not the wrapper Double. This \nlambda expression violates the signature of the functional interface, since it allows Double \nvalues to be sent to the interface, including those that could be null."
  },
  {
    "number": 117,
    "chapter": 6,
    "question": "Given the following code snippet, which values of x will allow the call divide(x) to com-\npile and provide predictable results at runtime? (Choose two.)\nimport java.util.stream.*;\npublic class Divide {\n   static float divide(Stream\u003cFloat\u003e s) {\n      return s.reduce(1.0f, (a,b) -\u003e a/b, (a,b) -\u003e a/b);\n   } }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [],
    "options": [
      "Set.of(1f,2f,3f,4f).stream()",
      "List.of(1f,2f,3f,4f).stream()",
      "List.of(1f,2f,3f,4f).parallel()",
      "List.of(1f).parallelStream()",
      "List.of(1f,2f,3f,4f).parallelStream()",
      "List.of(1f).parallel()"
    ],
    "explanation": "Option A is incorrect because sets are unordered. Options C and F are incorrect\nbecause the correct method call is parallelStream(). Option E is incorrect because the \naccumulator and combiner in the divide() method are not well-behaved. In particular, \nthey are not associative and in a parallel stream, could produce various results at runtime. \nOn a serial ordered stream, though, the results will be processed sequentially and in a pre-\ndictable order, making option B correct. Option D is correct because the stream has only \none element, so the identity is the only thing that will be applied."
  },
  {
    "number": 118,
    "chapter": 6,
    "question": "Which of the following produces different output than the others?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n   .collect(partitioningBy(x -\u003e x.charAt(0) \u003d\u003d \u0027e\u0027))\n   .get(false)\n   .stream()\n   .collect(groupingBy(String::length))\n   .get(4)\n  .forEach(System.out::println);",
      "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n   .filter(x -\u003e x.charAt(0) !\u003d \u0027e\u0027)\n   .collect(groupingBy(String::length))\n   .get(4)\n   .forEach(System.out::println);",
      "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n   .collect(groupingBy(x -\u003e x.charAt(0) \u003d\u003d \u0027e\u0027))\n   .get(false)\n   .stream()\n   .collect(partitioningBy(String::length))\n   .get(4)\n  .forEach(System.out::println);",
      "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n   .collect(groupingBy(x -\u003e x.charAt(0) \u003d\u003d \u0027e\u0027))\n   .get(false)\n   .stream()\n   .collect(groupingBy(String::length))\n   .get(4)\n  .forEach(System.out::println);",
      "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n   .collect(partitioningBy(x -\u003e x.charAt(0) \u003d\u003d \u0027e\u0027))\n   .get(false)\n   .stream()\n   .collect(partitioningBy(x -\u003e x.length() \u003d\u003d 4))\n   .get(true)\n  .forEach(System.out::println);",
      "They all produce the same output."
    ],
    "explanation": "Four of the five examples print miny. Option C does not compile. The difference is that\npartitioningBy() requires a Predicate that returns a boolean. When getting a \nquestion like this on the exam, focus on the differences between the provided options."
  },
  {
    "number": 119,
    "chapter": 6,
    "question": "Given an IntStream, which method would you use to obtain an equivalent parallel \nIntStream?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "parallelStream()",
      "parallels()",
      "getParallelStream()",
      "parallel()",
      "getParallel()",
      "None of the above"
    ],
    "explanation": "The correct method to obtain an equivalent parallel stream of an existing stream is\nparallel(), which is inherited by any class that implements BaseStream\u003cT\u003e including \nthe primitive streams. For this reason, option D is correct."
  },
  {
    "number": 120,
    "chapter": 6,
    "question": "Which statement is true?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "All lambdas can be converted to method references, and vice versa.",
      "All lambdas can be converted to method references, but not vice versa.",
      "All method references can be converted to lambdas, but not vice versa.",
      "None of the above."
    ],
    "explanation": "Method references are a shorter way of writing lambdas, and all method references can\nbe expanded to lambdas. However, this does not apply in reverse. Consider the lambda:  \n() -\u003e s.charAt(n). The n variable can only be an effectively final variable in lambdas, \nbut not in method references. Since only method references can always be converted, option \nC is correct."
  },
  {
    "number": 121,
    "chapter": 6,
    "question": "The following diagram shows input arguments being used in three functional interface \nmethods of unknown type. Which three functional interfaces, inserted in order from left to \nright, could be used to complete the diagram?\n",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "DoubleBinaryOperator\nToDoubleBiFunction\u003cInteger,Double\u003e\nUnaryOperator\u003cInteger\u003e",
      "BinaryOperator\u003cDouble\u003e\nBiFunction\u003cInteger,Integer,Double\u003e\nUnaryOperator\u003cInteger\u003e",
      "Function\u003cDouble,Integer\u003e\nBiFunction\u003cInteger,Integer,Double\u003e\nDoubleToIntFunction",
      "BiFunction\u003cInteger,Double,Integer\u003e\nBinaryOperator\u003cInteger\u003e\nIntUnaryOperator",
      "None of the above"
    ],
    "explanation": "First, options A and B are incorrect because the second functions for both return\na double or Double value, respectively. Neither of these values can be sent to a \nUnaryOperator\u003cInteger\u003e without an explicit cast. Next, option C is incorrect. The \nfirst functional interface Function\u003cDouble,Integer\u003e takes only one input, but the dia-\ngram shows two inputs for the first functional interface.\nThat leaves us with option  D . The first functional interface  \nBiFunction\u003cInteger,Double,Integer\u003e takes an int, which can be implicitly auto-\nboxed to Integer, and a Double and returns an Integer. The next functional interface, \nBinaryOperator\u003cInteger\u003e, takes two Integer values and returns an Integer value. \nFinally, this Integer value can be implicitly unboxed and sent to IntUnaryOperator, \nreturning an int. Since these behaviors match our diagram, option D is the correct answer."
  },
  {
    "number": 122,
    "chapter": 6,
    "question": "Which of the following is not a functional interface in the java.util.function \npackage? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "DoublePredicate",
      "LongUnaryOperator",
      "ShortSupplier",
      "ToIntBiFunction",
      "ToStringOperator"
    ],
    "explanation": "The DoublePredicate interface takes a double value and returns a boolean\nvalue. LongUnaryOperator takes a long value and returns a long value.  \nToInt BiFunction takes two generic values and returns an int value. ShortSupplier \nand ToStringOperator are not built-in functional interfaces. Recall that Java only \nincludes primitive functional interfaces that operate on double, int, or long. For this \nreason, Options C and E are correct."
  },
  {
    "number": 123,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage tps;\nimport java.util.*;\n \nclass Boss {\n   private String name;\n   public Boss(String name) {\n      this.name \u003d name;\n   }\n   public String getName() {return name.toUpperCase();}\n   public String toString() {return getName();}\n}\npublic class Initech {\n   public static void main(String[] reports) {\n      final List\u003cBoss\u003e bosses \u003d new ArrayList(8);\n      bosses.add(new Boss(\"Jenny\"));\n      bosses.add(new Boss(\"Ted\"));\n      bosses.add(new Boss(\"Grace\"));\n      bosses.removeIf(s -\u003e s.equalsIgnoreCase(\"ted\"));\n      System.out.print(bosses);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "[JENNY, GRACE]",
      "[ted]",
      "[tps.Boss@4218224c, tps.Boss@815f19a]",
      "The code does not compile because of the lambda expression.",
      "The code does not compile for a different reason."
    ],
    "explanation": "The lambda expression is invalid because the input argument is of type Boss, and Boss\ndoes not define an equalsIgnoreCase() method, making option D the correct answer. If \nthe lambda was corrected to use s.getName() instead of s, the code would compile and \nrun without issue, printing [JENNY, GRACE] at runtime and making option A the correct \nanswer."
  },
  {
    "number": 124,
    "chapter": 6,
    "question": "Which lambda can implement this functional interface?\npublic interface Serval {\n   static void printName(String name) {}\n   boolean cat(String name) { return true; }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "() -\u003e System.out.println()",
      "n -\u003e System.out.println(n)",
      "() -\u003e true",
      "n -\u003e true",
      "None of the above"
    ],
    "explanation": "Serval is not a valid interface let alone a functional interface. The cat() method\nspecifies an implementation, but does not have one of the modifiers that allows a body: \ndefault, private, or static. For this reason, option E is correct. If cat() was made \nan abstract method, then Serval would be a valid functional interface with n -\u003e true \nbeing a valid lambda that matches it."
  },
  {
    "number": 125,
    "chapter": 6,
    "question": "How many of these lines compile?\n17: Comparator\u003cString\u003e c1 \u003d s -\u003e false;\n18: Comparator\u003cString, String\u003e c2 \u003d (s1, s2) -\u003e false;\n19: Predicate\u003cString\u003e p1 \u003d String s -\u003e false;\n20: Predicate\u003cString\u003e p2 \u003d (String s) -\u003e false;\n21: Supplier\u003cString\u003e s1 \u003d String s -\u003e false;\n22: Supplier\u003cString\u003e s2 \u003d (String s) -\u003e false;",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "One",
      "Two",
      "Three",
      "Four",
      "Five",
      "Six"
    ],
    "explanation": "Let’s use the process of elimination here. Comparator returns an int, causing lines 17\nand 18 to not compile. Supplier does not take any parameters further, ruling out lines 21 \nand 22 .\nPredicate at least has the right number of parameters and the correct boolean return \ntype. However, line 19 is not correct because the parentheses are missing around the type \nand variable. The parentheses can be omitted only if no type declaration is present, making \nline 20 correct. Since only one of these lines of code compiles, option A is the answer."
  },
  {
    "number": 126,
    "chapter": 6,
    "question": "Which method is not available on the IntSummaryStatistics class?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "getCountAsLong()",
      "getMax()",
      "toString()",
      "None of these methods is available.",
      "All of these methods are available."
    ],
    "explanation": "Option A is the answer because there is a getCount() method that returns a long\nrather than a method named getCountAsLong(). Option B is incorrect because there is \nin fact a getMax() method. Option C is incorrect because toString() is declared on \nObject, which means it is inherited by all classes."
  },
  {
    "number": 127,
    "chapter": 6,
    "question": "Which functional interface, when filled into the blank, allows the class to compile?\npackage sleep;\nimport java.util.function.*;\n \nclass Sheep {}\npublic class Dream {\n   int MAX_SHEEP \u003d 10;\n   int sheepCount;\n   public void countSheep(  backToSleep) {\n      while(sheepCount\u003cMAX_SHEEP) {\n         // TODO: Apply lambda\n         sheepCount++;\n      }\n   }\n   public static void main(String[] dark) {\n      new Dream().countSheep(System.out::println);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "Consumer\u003cSheep\u003e",
      "Function\u003cSheep,void\u003e",
      "Supplier\u003cSheep\u003e",
      "UnaryOperator\u003cSheep\u003e",
      "None of the above"
    ],
    "explanation": "The method reference System.out::println takes a single input and does not\nreturn any data. Consumer\u003cSheep\u003e is compatible with this behavior, making option A the \ncorrect answer. Note that option B does not even compile because void cannot be used as \na generic argument. Similarly, option C does not take a parameter. Option D is also incor-\nrect, since System.out::println() does not return any data, and UnaryOperator \nrequires a return value."
  },
  {
    "number": 128,
    "chapter": 6,
    "question": "Given an instance of Stream s and Collection c, which of the following are valid \nways of creating a parallel stream? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4,
      5
    ],
    "userAnswers": [],
    "options": [
      "c.parallel()",
      "c.parallel().parallelStream()",
      "c.parallelStream()",
      "s.parallelStream()",
      "c.parallelStream().parallel()",
      "s.parallel()"
    ],
    "explanation": "The correct method to obtain a parallel stream of an arbitrary stream is\nparallel(), while the correct method to obtain a parallel stream that operates on a  \nCollection is parallelStream(). For this reason, options C, E, and F are correct. \nNote that option E retrieves a parallel stream of an already parallel stream, which is \nallowed."
  },
  {
    "number": 129,
    "chapter": 6,
    "question": "What is true of the following code? (Choose two.)\n3:  public static void main(String[] args) {\n4:     var prefix \u003d \"r\";\n5:     var pets \u003d List.of(\"rabbit\", \"snake\", \"turtle\");\n6:\n7:     // prefix \u003d \"t\";\n8:     pets.forEach(p -\u003e { \n9:        if (p.startsWith(prefix)) System.out.println(p); } );\n10: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      5
    ],
    "userAnswers": [],
    "options": [
      "As written, the code prints one line.",
      "As written, the code prints two lines.",
      "As written the code does not compile.",
      "If line 7 is uncommented, the code prints one line.",
      "If line 7 is uncommented, the code prints two lines.",
      "If line 7 is uncommented, the code does not compile."
    ],
    "explanation": "The code, as written, prints rabbit, since it starts with the letter r. This is option A.\nThe prefix variable is effectively final and, therefore safe to use in a lambda. Uncomment-\ning line 7 changes the prefix variable, and it is no longer effectively final. Since this causes \na compiler error, option F is the other answer."
  },
  {
    "number": 130,
    "chapter": 6,
    "question": "What is the output of the following code snippet?\n10: var pears \u003d List.of(1, 2, 3, 4, 5, 6);\n11: final var sum \u003d pears.stream()\n12:    .skip(1)\n13:    .limit(3)\n14:    .flatMapToInt(s -\u003e IntStream.of(s))\n15:    .skip(1)\n16:    .boxed()\n17:    .mapToDouble(s -\u003e s)\n18:    .sum();\n19: System.out.print(sum);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "6",
      "7.0",
      "6.0",
      "7",
      "Exactly one line contains a compiler error.",
      "More than one line contains a compiler error."
    ],
    "explanation": "The code compiles, so options E and F are incorrect. The stream operations on\nlines 12–13 reduce the stream to the values [2, 3, 4]. Line 14 then converts the \nStream\u003cInteger\u003e to an IntStream. On line 15, the first element of the IntStream is \nskipped, so the stream has only two elements [3, 4]. On line 16–17, the IntStream is \nconverted to a Stream\u003cInteger\u003e, then a DoubleStream. Finally, on lines 18–19 the sum \nof the remaining elements is calculated and printed. Since  7 .0 is printed, option B is correct."
  },
  {
    "number": 131,
    "chapter": 6,
    "question": "What is the minimum number of intermediate operations that can fill in each box [M, N, \nO, P] to have the pipeline complete given any intermediate operation?\n",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "[0, 0, 0, 1]",
      "[0, 0, 1, 0]",
      "[0, 0, 1, 1]",
      "[1, 1, 0, 1]",
      "[1, 1 ,1, 0]",
      "[1, 1, 1, 1]"
    ],
    "explanation": "Since the first two rows are already finite streams, boxes M and N do not require an\nintermediate operation to complete, so options D, E, and F are incorrect. Box P does not \nneed an intermediate operation either, since findFirst() will cause the stream to termi-\nnate, making options A and C incorrect. Box O does need to be filled in with code such as \nlimit(1). This allows the code to terminate, and option B is the answer."
  },
  {
    "number": 132,
    "chapter": 6,
    "question": "Given the table in the previous question, how many of the boxes in the Intermediate  \nOperation column will have the pipeline complete regardless of which intermediate  \noperation is placed in the box?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "Since the first two rows are already finite streams, boxes M and N meet this criteria. The\nlast two rows can be filled in with code such as sorted(), which does not terminate for an \ninfinite stream. Therefore, neither allows the code to terminate, and option C is the answer."
  },
  {
    "number": 133,
    "chapter": 6,
    "question": "Which of the following declares a Comparator where all objects are treated as equal?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Comparator\u003cCharacter\u003e comp \u003d (c1) -\u003e 0;",
      "Comparator\u003cCharacter\u003e comp \u003d (c1) -\u003e {0};",
      "Comparator\u003cCharacter\u003e comp \u003d (c1, c2) -\u003e 0;",
      "Comparator\u003cCharacter\u003e comp \u003d (c1, c2) -\u003e {0};",
      "None of the above"
    ],
    "explanation": "A Comparator takes two parameters, so options A and B are incorrect. Option D\ndoesn’t compile. When returning a value using braces, a return keyword and semicolon \nare required. Option C is a correct implementation."
  },
  {
    "number": 134,
    "chapter": 6,
    "question": "Which can fill in the blank so this code outputs true?\nimport java.util.function.*;\nimport java.util.stream.*;\n \npublic class HideAndSeek {\n   public static void main(String[] args) {\n      var hide \u003d Stream.of(true, false, true);\n      var found \u003d hide.filter(b -\u003e b).________();\n      System.out.println(found);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "Only anyMatch",
      "Only allMatch",
      "Both anyMatch and allMatch",
      "Only noneMatch",
      "The code does not compile with any of these options."
    ],
    "explanation": "The methods anyMatch(), allMatch(), and noneMatch() take a Predicate as a\nparameter. This code does not compile because the parameter is missing, making option E \ncorrect."
  },
  {
    "number": 135,
    "chapter": 6,
    "question": "Which method reference can replace the lambda on the second line so the output is the \nsame?\nvar s \u003d \"fish\";\nPredicate\u003cString\u003e pred \u003d (a) -\u003e s.contains(a);\nSystem.out.println(pred.test(\"is\"));",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "s::contains(a)",
      "s::contains",
      "String::contains(a)",
      "String::contains",
      "The supplied code does not compile.",
      "None of the above."
    ],
    "explanation": "Since the lambda references an effectively final variable, the method reference needs to\nas well. Option B is a correct method reference that meets this criteria. Options A and C \nuse syntax that is not supported with method references. Option D is incorrect because the\nPredicate passes only one value at runtime, so one of the instance variable or method \nparameter would need to be supplied."
  },
  {
    "number": 136,
    "chapter": 6,
    "question": "How many of these lines compile?\nPredicate\u003cString\u003e pred1 \u003d (final String s) -\u003e s.isEmpty();\nPredicate\u003cString\u003e pred2 \u003d (final s) -\u003e s.isEmpty();\nPredicate\u003cString\u003e pred3 \u003d (final var s) -\u003e s.isEmpty();\nPredicate\u003cString\u003e pred4 \u003d (String s) -\u003e s.isEmpty();\nPredicate\u003cString\u003e pred5 \u003d (var s) -\u003e s.isEmpty();",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5"
    ],
    "explanation": "Both pred4 and pred5 are valid as they use a type or var without final. Both pred1\nand pred3 are valid because the final modifier can only be used if a type or var is speci-\nfied. Since pred2 is missing a data type and is the only line that does not compile, option E \nis the answer."
  },
  {
    "number": 137,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage pet;\nimport java.util.*;\nimport java.util.function.*;\n \npublic class DogSearch {\n   void reduceList(List\u003cString\u003e names,\n      Predicate\u003cString\u003e tester) {\n \n      names.removeIf(tester);\n   }\n   public static void main(String[] treats) {\n      int MAX_LENGTH \u003d 2;\n      DogSearch search \u003d new DogSearch();\n      List\u003cString\u003e names \u003d new ArrayList\u003c\u003e();\n      names.add(\"Lassie\");\n      names.add(\"Benji\");\n      names.add(\"Brian\");\n      search.reduceList(names, d -\u003e d.length()\u003eMAX_LENGTH);\n      System.out.print(names.size());\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "0",
      "2",
      "3",
      "The code does not compile because of the lambda expression.",
      "The code does not compile for a different reason."
    ],
    "explanation": "This code does compile, making options D and E incorrect. It correctly uses a\nPredicate\u003cString\u003e and removes all the elements from names and prints out 0 .  There-\nfore, option A is the answer."
  },
  {
    "number": 138,
    "chapter": 6,
    "question": "What is the output of the following program?\nvar p \u003d List.of(1,3,5);\nvar q \u003d p.parallelStream().reduce(0f,\n   (w,x) -\u003e w.floatValue() + x.floatValue(),\n   (y,z) -\u003e y.floatValue() + z.floatValue());\nSystem.out.println(q);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "0.0",
      "9.0",
      "11.0",
      "One line does not compile.",
      "Two lines do not compile.",
      "None of the above."
    ],
    "explanation": "Since it’s not a primitive stream, the underlying type is Stream\u003cInteger\u003e, which\nmeans the data type of x is Integer. On the other hand, the data type of w, y, and z is \nFloat. Because Integer and Float both define a floatValue() method, all of the \nlines compile. The code snippet prints  9 .0 at runtime, making option B correct."
  },
  {
    "number": 139,
    "chapter": 6,
    "question": "What does the following output?\nSet\u003cString\u003e set \u003d new HashSet\u003c\u003e();\nset.add(\"tire-\");\nList\u003cString\u003e list \u003d new LinkedList\u003c\u003e();\nDeque\u003cString\u003e queue \u003d new ArrayDeque\u003c\u003e();\nqueue.push(\"wheel-\");\nStream.of(set, list, queue)\n   .flatMap(x -\u003e x.stream())\n   .forEach(System.out::print);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "[tire-][wheel-]",
      "tire-wheel-",
      "None of the above.",
      "The code does not compile."
    ],
    "explanation": "The flatMap() method is used to turn a stream of collections into a one-dimensional\nstream. This means it gets rid of the empty list and flattens the other two. Option A is \nincorrect because this is the output you’d get using the regular map() method. Option B is \ncorrect because it flattens the elements. Notice how it doesn’t matter that all three elements \nare different types of Collection implementations."
  },
  {
    "number": 140,
    "chapter": 6,
    "question": "How many lines does this code output?\n1:  import java.util.*;\n2:\n3:  public class PrintNegative {\n4:     public static void main(String[] args) {\n5:        List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n6:        list.add(\"-5\");\n7:        list.add(\"0\");\n8:        list.add(\"5\");\n9:        list.removeIf(e -\u003e e \u003c 0);\n10:       list.forEach(x -\u003e System.out.println(x));\n11:    }\n12: }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "One.",
      "Two.",
      "Three.",
      "None. The code does not compile.",
      "None. The code throws an exception at runtime."
    ],
    "explanation": "Pay attention to the data types. The forEach() method is looping through a list of\nobjects. This is a good example of using a lambda with list. By contrast, the Predicate \npassed to removeIf() uses an Integer. Since Integer is not compatible with String, \nline 9 does not compile."
  },
  {
    "number": 141,
    "chapter": 6,
    "question": "How many of the following lines compile?\n8:  IntFunction\u003cInteger\u003e f1 \u003d(Integer f) -\u003e f;\n9:  IntFunction\u003cInteger\u003e f2 \u003d (v) -\u003e null;\n10: IntFunction\u003cInteger\u003e f3 \u003d s -\u003e s;\n11: IntFunction\u003cInteger\u003e f4 \u003d () -\u003e 5;\n12: IntFunction\u003cInteger\u003e f5 \u003d () -\u003e Integer.valueOf(9);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "To start with, IntFunction\u003cInteger\u003e takes an int value and returns an Integer.\nLine 8 takes an Integer instead of int as the input argument, and is therefore not com-\npatible. Line 9 is compatible, since the return type null can be used as an Integer return \ntype. Line 10 is also valid. An int can be autoboxed to Integer. Lines 11 and 12 do not \ncompile because they do not take a parameter. Since only two statements compile, option C \nis the correct answer."
  },
  {
    "number": 142,
    "chapter": 6,
    "question": "Which statements about using a parallel stream instead of a serial stream are correct? \n(Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3,
      5
    ],
    "userAnswers": [],
    "options": [
      "The number of threads used is guaranteed to be higher.",
      "It requires a stateful lambda expression.",
      "The stream operation may execute faster.",
      "The stream operation may execute slower.",
      "The result of the stream operation will be the same.",
      "The result of the stream operation may change."
    ],
    "explanation": "Using a parallel stream does not guarantee concurrent execution or a specific\nnumber of threads, making option A incorrect. Option B is also incorrect, as stateful \nlambda expressions should be avoided with all streams, serial or parallel. In fact, if a state-\nful lambda expression is used, the result of the stream may change, making option F correct \nand option E incorrect. Option C is correct, as a parallel stream may improve performance. \nOption D is also correct, though, as a parallel stream may add extra overhead to a stream \nthat is forced into a serial operation, such as when the findFirst() method is called."
  },
  {
    "number": 143,
    "chapter": 6,
    "question": "Which is a possible output of the following code snippet?\nvar landmarks \u003d Set.of(\"Eiffel Tower\", \"Statue of Liberty\",\n   \"Stonehenge\", \"Mount Fuji\");\nvar result \u003d landmarks\n   .stream()\n   .collect(Collectors.partitioningBy(b -\u003e b.contains(\" \")))\n   .entrySet()\n   .stream()\n   .flatMap(t -\u003e t.getValue().stream())\n   .collect(Collectors.groupingBy(s -\u003e !s.startsWith(\"S\")));\nSystem.out.println(result);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "{false\u003d[Stonehenge, Statue of Liberty], true\u003d[Eiffel Tower, Mount Fuji]}",
      "{false\u003d[Stonehenge], true\u003d[Mount Fuji, Eiffel Tower, Statue of Liberty]}",
      "{false\u003d[Mount Fuji, Stonehenge], true\u003d[Eiffel Tower, Statue of Liberty]}",
      "Exactly one line contains a compiler error.",
      "More than one line contains a compiler error.",
      "None of the above."
    ],
    "explanation": "The code compiles, so options D and E are incorrect. The code first splits the stream\ninto a Map\u003cBoolean, List\u003cString\u003e based on whether the landmark contains a space. \nUsing the flatMap() method, it then takes the List\u003cString\u003e values of the Map and \nreforms them as a Stream\u003cString\u003e. This new stream is similar to the original stream, \nalthough with elements in a possibly different order. Finally, the groupingBy() collector \nsplits the stream based on whether it does not start with an \"S\". Since Set and Map were \nused, the order may vary, but option A is one possible output."
  },
  {
    "number": 144,
    "chapter": 6,
    "question": "Which can independently fill in the blank to output No dessert today?\nimport java.util.*;\npublic class Dessert {\n  public static void main(String[] yum) {\n    eatDessert(Optional.of(\"Cupcake\"));\n  }\n  private static void eatDessert(Optional\u003cString\u003e opt) {\n     System.out.println(opt._____________);\n  }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "get(\"No dessert today\")",
      "orElse(\"No dessert today\")",
      "orElseGet(() -\u003e \"No dessert today\")",
      "orElseThrow()",
      "None of the above"
    ],
    "explanation": "Option A doesn’t compile because the get() method on Optional doesn’t take any\nparameters. Options B, C, and D do compile, but print Cupcake since the Optional is not \nempty. Therefore, option E is correct."
  },
  {
    "number": 145,
    "chapter": 6,
    "question": "What is the output of this code?\nList.of(\"one\", \"two\", \"bloat\")\n   .limit(1)\n   .map(String::toUpperCase)       // line x\n   .sorted()\n   .forEach(System.out::println);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [],
    "options": [
      "bloat",
      "BLOAT",
      "one",
      "ONE",
      "The code does not compile due to line x.",
      "None of the above."
    ],
    "explanation": "There is no source in this attempt at a stream pipeline. While a Collection does have\nsome of the same methods as a stream, such as forEach(), the limit() method is not \none of them, so the code as written causes a compile error. Since this error is not on line x, \noption F is the answer. If stream() were inserted before limit(), then ONE would be \nprinted."
  },
  {
    "number": 146,
    "chapter": 6,
    "question": "Which is one of the lines output by this code?\n10: var list \u003d new ArrayList\u003cInteger\u003e();\n11: list.add(10);\n12: list.add(9);\n13: list.add(8);\n14:\n15: var num \u003d 9;\n16: list.removeIf(x -\u003e {int keep \u003d num; return x \u003d\u003d keep;});\n17: System.out.println(list);\n18:\n19: num \u003d 8;\n20: list.removeIf(x -\u003e {int keep \u003d num; return x \u003d\u003d keep;});\n21: System.out.println(list);",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "[]",
      "[8]",
      "[9]",
      "[10]",
      "The code does not compile."
    ],
    "explanation": "The num variable is not effectively final because the value changes. This means it cannot\nbe used in a lambda and the code does not compile, which is option  E ."
  },
  {
    "number": 147,
    "chapter": 6,
    "question": "What is the output of the following?\nimport java.util.Comparator;\nimport java.util.stream.Stream;\n \npublic class Compete {\n   public static void main(String[] args) {\n      Stream\u003cInteger\u003e is \u003d Stream.of(8, 6, 9);\n      Comparator\u003cInteger\u003e c \u003d (a, b) -\u003e a - b;\n      is.sort(c).forEach(System.out::print);\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "689",
      "986",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "There is not a stream pipeline method called sort(). There is one called sorted().\nSince the code does not compile, option C is correct. If this was fixed, option A would be \ncorrect since the Comparator sorts in ascending order."
  },
  {
    "number": 148,
    "chapter": 6,
    "question": "What can a lambda implement?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "All functional interfaces",
      "Any interface",
      "Only functional interfaces in the JDK",
      "None of the above"
    ],
    "explanation": "A lambda can only implement an interface with a single abstract method ruling out\noption B .  Developers can write their own functional interfaces, making option A correct."
  },
  {
    "number": 149,
    "chapter": 6,
    "question": "What is the output of the following application?\npackage lot;\nimport java.util.function.*;\n \npublic class Warehouse {\n   private int quantity \u003d 40;\n   private final BooleanSupplier stock;\n   {\n      stock \u003d () -\u003e quantity\u003e0;\n   }\n   public void checkInventory() {\n      if(stock.get())\n         System.out.print(\"Plenty!\");\n      else {\n         System.out.print(\"On Backorder!\");\n      }\n   }\n   public static void main(String... widget) {\n      final Warehouse w13 \u003d new Warehouse();\n      w13.checkInventory();\n   }\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [],
    "options": [
      "Plenty!",
      "On Backorder!",
      "The code does not compile because of the checkInventory() method.",
      "The code does not compile for a different reason."
    ],
    "explanation": "The primitive Supplier functional interfaces, such as BooleanSupplier and\nLongSupplier, do not have a get() method. Instead, they have methods such as \ngetAsBoolean() and getAsLong(), respectively. For this reason, the first line of the \ncheckInventory() method does not compile, making option C the correct answer. If the \nmethod call was changed to getAsBoolean(), then the rest of the code would compile \nwithout issue, print Plenty! at runtime, and option A would be the correct answer."
  },
  {
    "number": 150,
    "chapter": 6,
    "question": "What is a possible output of the following application?\nimport java.util.*;\nimport java.util.stream.*;\npublic class Thermometer {\n   private String feelsLike;\n   private double temp;\n   @Override public String toString() { return feelsLike; }\n   // Constructor/Getters/Setters Omitted\n   \n   public static void main(String... season) {\n      var readings \u003d List.of(new Thermometer(\"HOT!\",72),\n            new Thermometer(\"Too Cold!\",0),\n            new Thermometer(\"Just right!\",72));\n      readings\n         .parallelStream()               // k1\n         .collect(Collectors.groupingByConcurrent(\n            Thermometer::getTemp))       // k2\n         .forEach(System.out::println);  // k3      \n   } }",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [],
    "options": [
      "{0.0\u003d[Cold!], 72.0\u003d[HOT!, Just right!]}",
      "{0.0\u003d[Cold!], 72.0\u003d[Just right!] , 72.0\u003d[HOT!]}",
      "The code does not compile because of line k1.",
      "The code does not compile because of line k2.",
      "The code does not compile because of line k3.",
      "None of the above."
    ],
    "explanation": "The code does not compile because the collector returns a ConcurrentMap, which\nrequires a BiConsumer in the forEach() method. For this reason, option E is correct."
  },
  {
    "number": 1,
    "chapter": 7,
    "question": "What is the name of a file that declares a module?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "mod.java",
      "mod-data.java",
      "mod-info.java",
      "module.java",
      "module-data.java",
      "module-info.java"
    ],
    "explanation": "The module-info.java file is used to declare a module. You must memorize the name\nof this file."
  },
  {
    "number": 2,
    "chapter": 7,
    "question": "Suppose you have a module that contains a class with a call to  \nexports(ChocolateLab.class). Which part of the module service contains this class?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "The service locator contains a load() method, not an exports() method, making\noption E the answer."
  },
  {
    "number": 3,
    "chapter": 7,
    "question": "Which are considered part of a service? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface"
    ],
    "explanation": "A service is comprised of the interface, any classes the interface references, and a way to\nlook up implementations of the interface. Option B covers the lookup, and option D covers \nthe interface itself."
  },
  {
    "number": 4,
    "chapter": 7,
    "question": "Given the following diagram, how many of the following are named modules?\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "A named module must be on the module path and contain a module-info file. Only\ndog.bark meets this criterion, making option B the answer."
  },
  {
    "number": 5,
    "chapter": 7,
    "question": "Given the diagram, which is an automatic module?",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "dog.bark",
      "dog.fluffy",
      "dog.hair",
      "dog.husky",
      "None of the above"
    ],
    "explanation": "An automatic module must be on the module path but does not contain a module-info\nfile. Option C is correct because dog.hair matches this description."
  },
  {
    "number": 6,
    "chapter": 7,
    "question": "Given the diagram, which is a default module?",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "dog.bark",
      "dog.fluffy",
      "dog.hair",
      "dog.husky",
      "None of the above"
    ],
    "explanation": "You need to know about three types of modules for the exam: automatic, named, and\nunnamed. There is no such thing as a default module. The question was trying to trick you, \nand option E is correct."
  },
  {
    "number": 7,
    "chapter": 7,
    "question": "Given the diagram, how many are unnamed modules?",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "An unnamed module must be on the classpath. It is rare to have a module-info file in\nan unnamed module, but it is allowed. Therefore, both dog.fluffy and dog.husky meet \nthis criterion, making option C correct."
  },
  {
    "number": 8,
    "chapter": 7,
    "question": "Which of the following statements are true? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "It is a good practice to add the --add-exports option to your java command.",
      "It is permitted, but not recommended, to add the --add-exports option to your java command.",
      "There is no --add-exports option on the java command.",
      "It is a good practice to add the --add-requires option to your java command.",
      "It is permitted, but not recommended, to add the --add-requires option to your java command.",
      "There is no --add-requires option on the java command."
    ],
    "explanation": "It is recommended to specify all exports directives in the module-info file. While it\nis legal to use the --add-exports option, it is not recommended, making option B correct. \nYou do not need to know how to use it for the exam, just that it is not a good idea. There is \nno equivalent option for requires, making option F correct."
  },
  {
    "number": 9,
    "chapter": 7,
    "question": "How many of the following are legal module-info.java files?\nmodule com.koala {\n  exports cute;\n}\nmodule com-koala {\n  exports cute;\n}\npublic module com.koala {\n  exports cute;\n}\npublic module com-koala {\n  exports cute;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four"
    ],
    "explanation": "Since Java does not allow dashes in identifier names, the second and fourth declarations\nare invalid. Additionally, access modifiers are not permitted in module declarations, making \nthe third and fourth declarations invalid. The only one that is legal is the first declaration, so \noption B is correct."
  },
  {
    "number": 10,
    "chapter": 7,
    "question": "Which two would be best to combine into a single module?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Consumer and service locator",
      "Consumer and service provider",
      "Consumer and service provider interface",
      "Service locator and service provider interface",
      "Service locator and service provider",
      "Service provider and service provider interface"
    ],
    "explanation": "The consumer is generally separate ruling out options A, B, and C. The service provider is\ndecoupled from the service provider interface ruling out option F .  It is most logical to com-\nbine the service locator and service provider interface because neither has a direct reference \nto the service provider. Therefore, option D is correct."
  },
  {
    "number": 11,
    "chapter": 7,
    "question": "What command could you run to print output like the following?\njava.base@11.0.2\njava.compiler@11.0.2\njava.datatransfer@11.0.2\njava.desktop@11.0.2\n...",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "java --all-modules",
      "java --describe-modules",
      "java --list-modules",
      "java --output-modules",
      "java --show-modules",
      "None of the above"
    ],
    "explanation": "The java command has an option to list all the modules that come with the JDK.\nOption C is correct since that option is called --list-modules. The other options are \nnot supported by the java command. Options B and E are similar to options that exist: \n--describe-module and --show-module-resolution. But neither gives a list of all \nthe modules that come with the JDK."
  },
  {
    "number": 12,
    "chapter": 7,
    "question": "Suppose we have an automatic module on the module path named dog-arthur2.jar and \nno Automatic-Module-Name specified? What module name should named modules use to \nreference it?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "dog-arthur",
      "dog-arthur2",
      "dog.arthur",
      "dog.arthur2",
      "None of the above"
    ],
    "explanation": "The rules for determining the name include removing the extension, removing numbers,\nand changing special characters to periods (.). This leaves us with dog.arthur, which is \noption C . "
  },
  {
    "number": 13,
    "chapter": 7,
    "question": "Given the dependencies in the diagram, which boxes represent the service provider interface \nand service provider, respectively?\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "W and X",
      "W and Z",
      "X and Y",
      "X and Z",
      "Y and Z",
      "None of the above"
    ],
    "explanation": "All parts of a modules service must point to the service provider interface. This tells us th\nservice provider interface must be X, ruling out options A, B, and E .  Now, we have to decide \nif Y or Z are the service provider interface. We can tell because nothing has a direct depen-\ndency on the service provider. Since this makes the service provider Y, the answer is option C ."
  },
  {
    "number": 14,
    "chapter": 7,
    "question": "Using the diagram in the previous question, which boxes represent the consumer and service \nlocator, respectively?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "W and X",
      "W and Z",
      "X and Y",
      "X and Z",
      "Y and Z",
      "None of the above"
    ],
    "explanation": "The consumer depends on the service provider interface and service locator, but not\nthe service provider. Only W has two arrows starting from it so, it must be the consumer. \nThis rules out options C, D, and E .  The service locator references the service provider inter-\nface directly and the service provider indirectly, making the service locator Z and option B \nthe answer."
  },
  {
    "number": 15,
    "chapter": 7,
    "question": "What is the minimum number of JAR files you need for a cyclic dependency?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "A cyclic dependency is when two things directly or indirectly depend on each other. If\nchicken.jar depends on egg.jar, and egg.jar depends on chicken.jar, we have \na cyclic dependency. Since only two JAR files are needed to create this situation, option C is \nthe answer."
  },
  {
    "number": 16,
    "chapter": 7,
    "question": "Fill in the blank with code to look up and call a service.\nString cheese \u003d ServiceLoader.load(Mouse.class)\n   .map(______________)\n   .map(Mouse::favoriteFood)\n   .findFirst()\n   .orElse(\"\");",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Mouse.get()",
      "Mouse::get",
      "Provider.get()",
      "Provider::get",
      "None of the above"
    ],
    "explanation": "The ServiceLoader class has a load() method that returns a Collection of \nProvider, not a stream. Since the call to stream() is missing, option E is the answer. If the \ncall to stream() were added, option D would be the answer."
  },
  {
    "number": 17,
    "chapter": 7,
    "question": "Suppose we want to have two modules: com.ny and com.sf. Which is true about the \nplacement of the module-info.java file(s)?\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One module-info.java file is required in position Z.",
      "Two module-info.java files are required, in positions V and X.",
      "Two module-info.java files are required, in positions W and Y.",
      "Three module-info.java files are required, in positions V, X, and Z.",
      "Three module-info.java files are required, in positions W, Y, and Z.",
      "None of the above."
    ],
    "explanation": "Each module is required to have its own module-info.java file in the root directory\nof the module. For module com.ny, that is location W, and for module com.sf, that is loca-\ntion Y. Therefore, option B is correct."
  },
  {
    "number": 18,
    "chapter": 7,
    "question": "Consider the modules in the previous diagram. Suppose we want the code in module com.sf \nto depend on code in module com.ny. Which of the following directives goes into module \ncom.sf’s module-info file to configure that behavior?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "export com.ny;",
      "exports com.ny;",
      "require com.ny;",
      "require com.ny.city;",
      "requires com.ny;",
      "requires com.ny.city;"
    ],
    "explanation": "Options A, C, and D are incorrect because export and require are not keywords in\nmodules. Option B is incorrect because that directive goes in the com.ny module, not the \ncom.sf one. Option E is correct rather than option F because the requires directive refer-\nences a module name rather than a package."
  },
  {
    "number": 19,
    "chapter": 7,
    "question": "Consider the modules diagram in question 17. Suppose we want the code in module com.sf \nto depend on code in module com.ny. Which of the following directives goes into module \ncom.ny’s module-info file to configure that behavior?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "export com.ny;",
      "export com.ny.city;",
      "exports com.ny;",
      "exports com.ny.city;",
      "requires com.ny;",
      "requires com.ny.city;"
    ],
    "explanation": "Options A and B are incorrect because export is not a keyword in modules. Option\nE belongs in the com.sf module, not the com.ny one. Option F is incorrect because the \nrequires directive references a module name rather than a package. Finally, option D is \nthe answer rather than option C because the exports directive references a package name \nrather than a module."
  },
  {
    "number": 20,
    "chapter": 7,
    "question": "Suppose the consumer, service locator, service provider, and service provider interface are \neach in separate modules. Which of the following best describes the following module-\ninfo file?\nmodule nature.tree {\n  provides nature.sapling.Tree with nature.tree.Maple\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "The Maple class is intended to be an implementation of the Tree interface. However, this\ninterface needs to be accessible. This module is missing a requires nature.sapling; \nstatement, making option E the correct answer."
  },
  {
    "number": 21,
    "chapter": 7,
    "question": "Which options are commonly used when compiling a module?",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "-d and -m",
      "-d and -p",
      "-m and -p",
      "-d, -m, and -p",
      "None of the above"
    ],
    "explanation": "The –d option specifies the directory. The –p option specifies the module path. The –m\noption is not available on the javac command."
  },
  {
    "number": 22,
    "chapter": 7,
    "question": "Which of the following are modules supplied by the JDK? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      4
    ],
    "userAnswers": [
      0,
      4,
      5
    ],
    "options": [
      "java.base",
      "java.basic",
      "java.desktop",
      "java.sdk",
      "java.sql",
      "java.swing"
    ],
    "explanation": "The java.base module is automatically available to any module without specifying\nit, making option A correct. Options C and E are also correct because java.desktop and \njava.sql are modules supplied with the JDK. You do need to be able to identify built-in \nmodules for the exam."
  },
  {
    "number": 23,
    "chapter": 7,
    "question": "Which best describes a top-down migration? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [
      0,
      5
    ],
    "options": [
      "The first step is to move all the modules to the module path.",
      "The first step is to move a single module to the module path.",
      "Most steps consist of changing an automatic module to a named module.",
      "Most steps consist of changing an automatic module to a unnamed module.",
      "Most steps consist of changing an unnamed module to an automatic module.",
      "Most steps consist of changing an unnamed module to a named module"
    ],
    "explanation": "Option A is correct because a top-down migration starts by moving all the modules to\nthe module path as automatic modules. Then, the migration changes each module from an \nautomatic module to a named module, making option C the other correct answer."
  },
  {
    "number": 24,
    "chapter": 7,
    "question": "Suppose the consumer, service locator, service provider, and service provider interface are \neach in separate modules. Which of the following best describes the following  \nmodule-info file?\nmodule nature.tree {\n  requires nature.sapling;\n  requires nature.bush;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "Option A is correct because a consumer has two dependencies. It requires both the ser\nvice provider interface and the service locator."
  },
  {
    "number": 25,
    "chapter": 7,
    "question": "Suppose you have these two JARs from Java 8. Which steps, when taken together, would be \nthe best way to make them modules? (Choose two.)\n",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "Add a module-info.java to each.",
      "Add them to the classpath.",
      "Create a third module to contain the common code.",
      "Merge them into one module to break the cyclic dependency.",
      "Rename the modules to use dashes instead of dots."
    ],
    "explanation": "Option A is correct, and option B is incorrect as we want to create named modules\nwhen possible. We also need to be on the lookout for cyclic dependencies. While option \nD would work, it is better to be more granular and create a third module as in option C . \nOption E is incorrect because dots are used as separators in names."
  },
  {
    "number": 26,
    "chapter": 7,
    "question": "Which command produces output such as the following?\nanimal.puppy -\u003e animal.dog",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "jdeps –d zoo.animal.puppy.jar",
      "jdeps –s zoo.animal.puppy.jar",
      "jmod –d zoo.animal.puppy.jar",
      "jmod –s zoo.animal.puppy.jar",
      "None of the above"
    ],
    "explanation": "The jdeps command lists information about dependencies within a module. The –s\noption provides a summary of output rather than verbose output, making option B the \ncorrect answer. There is no –d option. The jmod command is for working with JMOD files."
  },
  {
    "number": 27,
    "chapter": 7,
    "question": "Suppose the consumer, service locator, service provider, and service provider interface are \neach in separate modules. Which of the following best describes the following module-\ninfo file?\nmodule nature.tree{\n   requires nature.sapling;\n   provides nature.sapling.Tree with nature.tree.Maple\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "Option C is correct because a service provider requires the interface. It also provides\nthe implementation."
  },
  {
    "number": 28,
    "chapter": 7,
    "question": "Suppose we have module com.bird that contains package com.bird.tweet and \nclass Tweety with a main() method. Which of the following can fill in the blank to run \nthis program?\njava --module-path mods –module _____________",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "com.bird.Tweety",
      "com.bird.tweety.Tweety",
      "com.bird/Tweety",
      "com.bird.tweet/Tweety",
      "com.bird/com.bird.tweet.Tweety",
      "com.bird.tweet/com.bird.Tweety"
    ],
    "explanation": "When running a module, the module name is listed before the slash, and the fully qualified\nclass name is after the slash. Option E is the only one that meets this criterion."
  },
  {
    "number": 29,
    "chapter": 7,
    "question": "Which types of modules are required to contain a module-info file?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Automatic only",
      "Named only",
      "Unnamed only",
      "Automatic and named",
      "Automatic and unnamed",
      "Named and unnamed"
    ],
    "explanation": "An unnamed module is on the classpath. While it is permitted to have a module-info\nfile, the file is ignored if present. An automatic module is on the module path and does not \nhave a module-info file. A named module is required to have a module-info file, mak-\ning option B the correct answer."
  },
  {
    "number": 30,
    "chapter": 7,
    "question": "Suppose the consumer, service locator, service provider, and service provider interface are \neach in separate modules. Which of the following best describes the following  \nmodule-info file?\nmodule nature.tree{\n  exports nature.tree.leaf;\n  requires nature.sapling;\n  uses nature.tree.Photosynthesis;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "Option B is correct because a service locator uses the interface. It also requires the\nservice provider interface module and exports the package with the locator."
  },
  {
    "number": 31,
    "chapter": 7,
    "question": "What is a benefit of using modules? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [
      3,
      5
    ],
    "options": [
      "Better access control",
      "Custom Java builds",
      "Elimination of JAR files",
      "Fewer .java files needed in your application",
      "Not necessary to specify types of local variables",
      "Write once, run anywhere"
    ],
    "explanation": "Option A is correct because modules provide a mechanism to export specific packages.\nThis creates module-level access since some packages can be used only in a module. Option \nB is correct because jlink allows creating a distribution with just the parts of the JDK that \nare needed. Option C is not correct because modules are usually distributed as a JAR file. \nOption D is incorrect because modules actually require one extra file: module-info.java. \nOption E is incorrect because var can be used with or without modules. Finally, option \nF is incorrect because “write once, run anywhere” is a core benefit of Java independent \nof modules."
  },
  {
    "number": 32,
    "chapter": 7,
    "question": "Suppose the consumer, service locator, service provider, and service provider interface are \neach in separate modules. Which of the following best describes the following  \nmodule-info file?\nmodule nature.tree{\n  requires nature.sapling;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "A consumer requires both the service locator and service provider interface. A service\nlocator and service provider interface need to have an exports statement. A service provider \nneeds a provides directive. Since none of them matches, option E is the correct answer."
  },
  {
    "number": 33,
    "chapter": 7,
    "question": "Which types of modules are allowed to contain a module-info file?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Automatic only",
      "Named only",
      "Unnamed only",
      "Automatic and named",
      "Automatic and unnamed",
      "Named and unnamed"
    ],
    "explanation": "An unnamed module is permitted to have a module-info file, but the file is ignored\nif present. An automatic module does not have a module-info file. A named module is \nrequired to have a module-info file. Therefore, option F is correct."
  },
  {
    "number": 34,
    "chapter": 7,
    "question": "Which of the following is true of the following module declaration?\n1: class com.mammal {\n2:    exports com.mammal.cat;\n3:    exports cat.mammal.mouse to com.mice;\n4:    uses com.animal;\n5: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The first line that fails to compile is line 1.",
      "The first line that fails to compile is line 2.",
      "The first line that fails to compile is line 3.",
      "The first line that fails to compile is line 4.",
      "The code compiles."
    ],
    "explanation": "A module-info file is required to start with module rather than class. Therefore, the\nfirst line doesn’t compile, and option A is correct."
  },
  {
    "number": 35,
    "chapter": 7,
    "question": "How many of these keywords can be used in a module-info.java file: closes, export, \nimport, require, and uses?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "You need to know these keywords: exports, requires, requires \ntransitive, provides, opens, and uses. Of these, only uses is in the list of candi-\ndates in the question. Note that export and require are invalid because they should be \nexports and requires, respectively."
  },
  {
    "number": 36,
    "chapter": 7,
    "question": "Suppose the consumer, service locator, service provider, and service provider interface are \neach in separate modules. Which of the following best describes the following  \nmodule-info file?\nmodule nature.tree{\n  exports nature.tree.leaf;\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "Option D is correct because a service provider interface exposes the interface without\ndepending on any of the other options."
  },
  {
    "number": 37,
    "chapter": 7,
    "question": "Which of the following are modules supplied by the JDK? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3,
      4,
      5
    ],
    "userAnswers": [
      0,
      1,
      2
    ],
    "options": [
      "jdk.base",
      "jdk.basic",
      "jdk.desktop",
      "jdk.javadoc",
      "jdk.jdeps",
      "jdk.net"
    ],
    "explanation": "The java.base module is automatically available to any module without specifying\nit. However, this question tries to trick you with option A by specifying jdk.base instead. \nSimilarly, java.desktop exists, but not jdk.deskop, making option C wrong. Options D, \nE, and F are correct because jdk.javadoc , jdk.jdeps, and jdk.net are modules sup-\nplied with the JDK. You do need to be able to recognize the names of built-in modules."
  },
  {
    "number": 38,
    "chapter": 7,
    "question": "Which are true statements about types of migration? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      5
    ],
    "userAnswers": [
      0,
      2,
      4
    ],
    "options": [
      "All modules are immediately moved to the module path in a bottom-up migration.",
      "All modules are immediately moved to the module path in a top-down migration.",
      "Modules migrate before the modules that depend on them in a bottom-up migration.",
      "Modules migrate before the modules that depend on them in a top-down migration.",
      "Modules that are not yet named modules are automatic modules in a bottom-up migration.",
      "Modules that are not yet named modules are automatic modules in a top-down migration."
    ],
    "explanation": "A top-down migration starts by moving all the modules to the module path as\nautomatic modules, making options B and F correct. A bottom-up migration moves each \nmodule after all modules it depends on have been migrated, making option C correct."
  },
  {
    "number": 39,
    "chapter": 7,
    "question": "A class in which of the following parts of a module service should include a method call to \nload(ChocolateLab.class) that would allow callers to use it?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "The service locator contains a load() method, making option B correct"
  },
  {
    "number": 40,
    "chapter": 7,
    "question": "How many of these module declarations are valid?\nmodule com.leaf {}\nmodule com.leaf2 {}\nmodule com-leaf { }\nmodule LEAF {}\nmodule leaf2 {}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Zero",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Module names are permitted to be any valid variable name with the addition of dot sep\narators (.). The only one that is problematic is com-leaf because dashes are not allowed, \nmaking option E correct. As a reminder, numbers are permitted as long as they are not the \nfirst character in a segment. Capital letters are discouraged but allowed."
  },
  {
    "number": 41,
    "chapter": 7,
    "question": "Which is a benefit of ServiceLoader?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "It allows you to add functionality without recompiling the application.",
      "It allows you to load a service written in C++.",
      "It is an interface.",
      "When implementing a service, it references the ServiceLoader."
    ],
    "explanation": "Option A is correct because ServiceLoader allows you to make your application\nextensible. A service can be added without recompiling the entire application. It is a class, but \nthe service provider implementation does not reference it, making options C and D incorrect. \nOption B is not a feature of Java."
  },
  {
    "number": 42,
    "chapter": 7,
    "question": "Which are true statements? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      5
    ],
    "userAnswers": [
      2,
      5
    ],
    "options": [
      "Code on the classpath can reference code in automatic, named, and unnamed modules.",
      "Code on the classpath can reference code in named modules, but not automatic and unnamed modules.",
      "Code on the classpath can reference code in automatic and named modules, but not unnamed modules.",
      "Code on the module path can reference code in automatic, named, and unnamed modules.",
      "Code on the module path can reference code in named modules, but not automatic and unnamed modules.",
      "Code on the module path can reference code in automatic and named modules, but not unnamed modules."
    ],
    "explanation": "Code on the classpath has not yet been migrated to modules and can reference any code\nin the application. This is true whether that code is in automatic, named, or unnamed mod-\nules, matching option A .  Code on the module path operates in a stricter world and cannot \nreference code on the classpath. Since unnamed modules cannot be accessed in this situation, \noption F is the second answer."
  },
  {
    "number": 43,
    "chapter": 7,
    "question": "Suppose we have the packages in the diagram. What could we add to the  \nmodule-info.java in com.duck to allow the com.park module to reference the \nDuckling class but not allow the com.bread module to do the same?\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "exports com.duckling;",
      "exports com.duckling from com.park;",
      "exports com.duckling to com.park;",
      "exports com.park from com.duckling;",
      "exports com.park to com.duckling;",
      "None of the above"
    ],
    "explanation": "Option A is incorrect because it exports the package to all modules. Option C is correct\nbecause it limits package sharing to the com.park module. Option E is incorrect because a \npackage must be exported from the module that contains it. Options B and D are incorrect \nbecause from is not valid syntax."
  },
  {
    "number": 44,
    "chapter": 7,
    "question": "Given the diagram in the previous question, what could we add to module-info.java in \ncom.duck to allow the com.park package to reference the Duckling class, but not allow \nthe Egg class to reference the Duckling class?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "exports com.duckling;",
      "exports com.duckling from com.park;",
      "exports com.duckling to com.park;",
      "exports com.park from com.duckling;",
      "exports com.park to com.duckling;",
      "None of the above"
    ],
    "explanation": "It is not possible to provide access outside the module while also limiting access within the\ncom.duck module. Options A and C are tempting because they do provide access in  \ncom.park. However, they do not prevent the Egg class in the com.egg package from access-\ning the com.duckling package. Remember that the com.egg package is in the com.duck \nmodule, so the access cannot be restricted. Therefore, option F is correct. "
  },
  {
    "number": 45,
    "chapter": 7,
    "question": "Given the diagram in question 43 and the correct export statement to share only com.\nduckling, which of the following should be included in the module-info.java file of \ncom.park to specify that com.park should have access to the com.duckling and com.\nbread packages, but not the com.egg package?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "require com.duck, com.bread;",
      "requires com.duck; com.bread;",
      "require com.duckling, com.bread;",
      "requires com.duckling; com.bread;",
      "None of the above"
    ],
    "explanation": "The correct way to specify this is requires com.duck; requires com.bread;.\nThere is no way to combine two module requires statements into one. Additionally, note \nthat the requires statement works with a module name, not a package name."
  },
  {
    "number": 46,
    "chapter": 7,
    "question": "Which is both part of the service and has a provides directive?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Service provider",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "Only the service provider has a provides directive. Since it is not part of the service,\noption E is the correct answer."
  },
  {
    "number": 47,
    "chapter": 7,
    "question": "What command is the simplest way to list suggestions for classes in jdk.unsupported?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "jdeps cookie.jar",
      "jdeps –s cookie.jar",
      "jdeps –jdkinternals cookie.jar",
      "jdeps --jdkinternals cookie.jar",
      "jdeps -jdkunsupported cookie.jar",
      "jdeps --jdkunsupported cookie.jar"
    ],
    "explanation": "Both options A and B note that the JAR depends on the jdk.unsupported module.\nHowever, they do not list suggested replacements. Options C and E are invalid because flags \nof this format need two dashes. Option D is correct and option F is incorrect because the \ndesired flag is --jdkinternals. Note that --jdk-internals is also acceptable."
  },
  {
    "number": 48,
    "chapter": 7,
    "question": "Which modules are on the classpath?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Automatic only",
      "Named only",
      "Unnamed only",
      "Automatic and named",
      "Automatic and unnamed",
      "Named and unnamed"
    ],
    "explanation": "Option C is correct because only unnamed modules are on the classpath."
  },
  {
    "number": 49,
    "chapter": 7,
    "question": "Which line of code belongs in a service locator?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "ServiceLoader loader \u003d ServiceLoader.load();",
      "ServiceLoader loader \u003d ServiceLoader.load(Mouse.class);",
      "ServiceLoader\u003cMouse\u003e loader \u003d ServiceLoader.load();",
      "ServiceLoader\u003cMouse\u003e loader \u003d ServiceLoader.load(Mouse.class);",
      "Mouse loader \u003d ServiceLoader.load();",
      "Mouse loader \u003d ServiceLoader.load(Mouse .class);"
    ],
    "explanation": "The service locator contains a ServiceLoader call to look up the service loader. It takes\nthe type of class it looked up as a parameter and returns a generic, making option D the \ncorrect answer."
  },
  {
    "number": 50,
    "chapter": 7,
    "question": "Which is true about a service? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "Changing the service provider interface always requires recompiling the service provider.",
      "Changing the service provider interface sometimes requires recompiling the service provider.",
      "Changing the service provider interface never requires recompiling the service provider.",
      "If the service provider interface references other classes in the method signatures, they\nare considered part of the service.",
      "If the service provider interface references other classes in the method signatures, they\nare not considered part of the service."
    ],
    "explanation": "Option B is correct because it depends on the change. If a method is added to the ser\nvice provider interface or a public method is changed, the service providers must be recom-\npiled. However, if a change is made that does not affect the service provider, such as a new \nstatic method, recompilation is not needed. Option D is also correct because return types \nand parameter types are considered part of the service."
  },
  {
    "number": 51,
    "chapter": 7,
    "question": "Which modules are on the module path?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Automatic only",
      "Named only",
      "Unnamed only",
      "Automatic and named",
      "Automatic and unnamed",
      "Named and unnamed"
    ],
    "explanation": "Unnamed modules are on the classpath. Option D is correct because automatic and\nnamed modules are on the module path."
  },
  {
    "number": 52,
    "chapter": 7,
    "question": "The service locator and service provider interface share a module. Which boxes represent the \nconsumer and service provider, respectively?\n",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "X and Y",
      "X and Z",
      "Y and Z",
      "Z and Z",
      "Z and Y",
      "None of the above"
    ],
    "explanation": "The consumer needs to depend on the shared module, making it X. The shared module\nthen has to be Z, and the service provider has to be Y. However, the service provider should \nnot know about the consumer, and the dotted line in the diagram does not make sense. This \nmeans none of the options can create a valid scenario, and option F is the correct answer."
  },
  {
    "number": 53,
    "chapter": 7,
    "question": "What command is the simplest way to list what modules a JAR depends on without listing \npackage names?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "jdeps cookie.jar",
      "jdeps –s cookie.jar",
      "jdeps –jdkinternals cookie.jar",
      "jdeps --jdkinternals cookie.jar",
      "jdeps -jdk-unsupported cookie.jar",
      "jdeps --jdk-unsupported cookie.jar"
    ],
    "explanation": "Without any command line flags, jdeps lists packages and module dependencies. The\n-s flag provides a summary omitting the package name, which means option B is the \ncorrect answer."
  },
  {
    "number": 54,
    "chapter": 7,
    "question": "What is a benefit of using modules? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      5
    ],
    "userAnswers": [
      0,
      1,
      4
    ],
    "options": [
      "Ability to reuse code",
      "Clearer dependency management",
      "Improved performance",
      "Multithreading support",
      "Platform independence",
      "Unique package enforcement"
    ],
    "explanation": "Options A, D, and E are incorrect because they are benefits of Java even without\nmodules. Option B is correct because the module-info file clarifies dependencies. Option \nC is correct because a smaller deployment package can be faster. Finally, option F is correct \nbecause the module system prevents the same package from being used from multiple \nJAR files."
  },
  {
    "number": 55,
    "chapter": 7,
    "question": "Fill in the blanks to list a way of getting a lot of information useful in debugging modules:\n_______ -m x –p y --______________",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "jar and –show-modules",
      "jar and –show-module-detail",
      "jar and –show-module-resolution",
      "java and –show-modules",
      "java and –show-module-detail",
      "java and –show-module-resolution"
    ],
    "explanation": "The first clue is that the -m and -p options are on the java command. Beyond that, you\nneed to memorize the name of the --show-module-resolution option."
  },
  {
    "number": 56,
    "chapter": 7,
    "question": "Suppose you have the following interface in a module named animal.insect.api. What \nneeds to be included in the module-info file for it to be a service provider interface?\npackage animal.insect.api.bugs;\n \npublic interface Bug {\n   int crawl();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "exports animal.insect.api;",
      "exports animal.insect.api.bugs;",
      "exports animal.insect.api.bugs.Bug;",
      "requires animal.insect.api;",
      "requires animal.insect.api.bugs;",
      "requires animal.insect.api.bugs.Bug;"
    ],
    "explanation": "This module is a service provider interface. The only requirement is that the module \nneeds to export the package containing the interface. In this case, that is the  \nanimal.insect.api.bugs package, which matches option B ."
  },
  {
    "number": 57,
    "chapter": 7,
    "question": "Suppose you have the following class in a module named animal.insect.impl\n\npackage animal.insect.impl;\n \nimport animal.insect.api.bugs.Bug;\n \npublic class Worm implements Bug {\n   @Override\n   public int crawl() {\n      return 1;\n   }\n} \n\nAnd the following provider interface module: \npackage animal.insect.api.bugs;\n \npublic interface Bug {\n   int crawl();\n}. What needs to be included in the  \nmodule-info for it to be a service provider? (Choose two.)\npackage animal.insect.impl;\n \nimport animal.insect.api.bugs.Bug;\n \npublic class Worm implements Bug {\n   @Override\n   public int crawl() {\n      return 1;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "requires animal.insect.api.bugs;",
      "requires animal.insect.lookup;",
      "requires animal.printer;",
      "provides animal.insect.impl.Worm;",
      "provides animal.insect.api.bugs.Bug with animal.insect.impl.",
      "provides animal.insect.impl.Worm with animal.insect.api.bugs.Worm;"
    ],
    "explanation": "This module is a service provider. It needs a requires directive for the service pro\nvider interface, which is option A .  It also needs a provides directive, which specifies both \nthe interface and implementation. Option E has both in the correct order."
  },
  {
    "number": 58,
    "chapter": 7,
    "question": "Suppose you have the following class in a module named animal.insect.lookup: \npackage animal.insect.lookup;\n \nimport animal.insect.api.bugs.Bug;\nimport java.util.List;\nimport java.util.ServiceLoader;\nimport java.util.stream.Collectors;\n \npublic class InsectFinder {\n   public static List\u003cBug\u003e findAllBugs() {\n      return ServiceLoader.load(Bug.class)\n         .stream()\n         .map(ServiceLoader.Provider::get)\n         .collect(Collectors.toList());\n   }\n}\n\nThis service provider interface: \npackage animal.insect.api.bugs;\n \npublic interface Bug {\n   int crawl();\n}\n\nAnd this service provider: n\npackage animal.insect.impl;\n \nimport animal.insect.api.bugs.Bug;\n \npublic class Worm implements Bug {\n   @Override\n   public int crawl() {\n      return 1;\n   }\n}\n\nWhat needs to be included in the module-info file besides an exports directive for it to be a \nservice locator? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      2,
      5
    ],
    "options": [
      "provides animal.insect.lookup;",
      "provides animal.insect.lookup.InsectFinder;",
      "requires animal.insect.api.bugs;",
      "requires animal.insect.api.Bug;",
      "uses animal.insect.api.bugs;",
      "uses animal.insect.api.bugs.Bug;"
    ],
    "explanation": "This module is a service locator. It needs three directives: exports, requires, and\nuses. The requires directive specifies the module it depends on, which is option C .  The \nuses directive specifies the service provider interface it references, which is option F ."
  },
  {
    "number": 59,
    "chapter": 7,
    "question": "Suppose you have the following class in a module named animal.insect.printer\npackage animal.printer;\n \nimport animal.insect.lookup.InsectFinder;\n \npublic class Print {\n   public static void main(String[] args) {\n      var bugs \u003d InsectFinder.findAllBugs();\n      bugs.forEach(System.out::println);\n   }\n}\n\nThis service provider interface: \npackage animal.insect.api.bugs;\n \npublic interface Bug {\n   int crawl();\n} \n\nThis service provider: \npackage animal.insect.impl;\n \nimport animal.insect.api.bugs.Bug;\n \npublic class Worm implements Bug {\n   @Override\n   public int crawl() {\n      return 1;\n   }\n} \n\nAnd this service locator: \npackage animal.insect.lookup;\n \nimport animal.insect.api.bugs.Bug;\nimport java.util.List;\nimport java.util.ServiceLoader;\nimport java.util.stream.Collectors;\n \npublic class InsectFinder {\n   public static List\u003cBug\u003e findAllBugs() {\n      return ServiceLoader.load(Bug.class)\n         .stream()\n         .map(ServiceLoader.Provider::get)\n         .collect(Collectors.toList());\n   }\n}\n\nWhat needs to be included in the module-info for it to \nbe a consumer? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [
      0,
      1
    ],
    "options": [
      "requires animal.insect.api.bugs;",
      "requires animal.insect.lookup;",
      "requires animal.printer;",
      "uses animal.insect.api.bugs;",
      "uses animal.insect.api.bugs.Bug;",
      "uses animal.insect.lookup.InsectFinder;"
    ],
    "explanation": "This module is a consumer. It needs two requires directives. Option A represents the\nservice provider interface, and option B represents the service locator. The uses directive \nshould be in the service locator, not the consumer."
  },
  {
    "number": 60,
    "chapter": 7,
    "question": "What command is the simplest way to list what modules a JAR depends on including \npackage names?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "jdeps cookie.jar",
      "jdeps –s cookie.jar",
      "jdeps –jdkinternals cookie.jar",
      "jdeps --jdkinternals cookie.jar",
      "jdeps -jdk-unsupported cookie.jar",
      "jdeps --jdk-unsupported cookie.jar"
    ],
    "explanation": "Without any command line flags, jdeps lists packages and module dependencies, making\noption A correct. Option D will also list the packages; however, it is longer than option A ."
  },
  {
    "number": 61,
    "chapter": 7,
    "question": "How many modules are part of the cyclic dependency?\nmodule com.light {\n   exports com.light;\n}\nmodule com.animal {\n   exports com.animal;\n   requires com.light;\n   requires com.plant;\n}\nmodule com.plant {\n   exports com.plant;\n   requires com.light;\n   requires com.animal;\n}\nmodule com.worm {\n   exports com.worm;\n   requires com.light;\n   requires com.animal;\n   requires com.plant;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "The com.light module does not have any dependencies, so it is fine. However, \ncom.animal and com.plant depend on each other giving us a cyclic dependency. Finally, \ncom.worm depends on all the modules but does not introduce any more problems. It will \nnot compile until com.animal or com.plant are fixed, but is not part of the cycle itself. \nOption C is correct, since only two modules are part of the cycle."
  },
  {
    "number": 62,
    "chapter": 7,
    "question": "What is true about the -d option?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "It can be used with the jar command, but not the java command.",
      "It can be used with the java command, but not the jar command.",
      "It can be used with the jar and java commands and serves the same purpose for both.",
      "It can be used with the jar and java commands, but means “directory” for the former and\n“describe module” for the later.",
      "None of the above."
    ],
    "explanation": "The -d option is a shorthand for --describe-module on both the jar and java\ncommands. Therefore, option C is correct."
  },
  {
    "number": 63,
    "chapter": 7,
    "question": "Assuming all referenced files and directories exist and are correct, what does this code do?\njavac –m mods –d mouse mouse/com/mouse/*.java\n   mouse/module-info.java\njar –cvf mods/com.mouse.jar –C mouse/ .",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Creates a JAR file representing the com.mouse module",
      "Creates a JAR file that is not a module",
      "Fails on the javac command",
      "Fails on the jar command"
    ],
    "explanation": "The javac command takes -p for the module path rather than -m. Since there is no –m\non the javac command, option C is the correct answer."
  },
  {
    "number": 64,
    "chapter": 7,
    "question": "What module is always in the jdeps output?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "java.base",
      "java.lang",
      "java.self",
      "jdk.base",
      "jdk.lang",
      "jdk.self"
    ],
    "explanation": "Option B is tempting because the java.lang package is available to all classes. How\never, the question asks about modules. Option A is the correct answer because the  \njava.base module is available to all modules. The other options are incorrect because \nthose modules do not exist."
  },
  {
    "number": 65,
    "chapter": 7,
    "question": "Which are valid modes on the jmod command? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      2
    ],
    "userAnswers": [
      0,
      1,
      3
    ],
    "options": [
      "create",
      "list",
      "hash",
      "show",
      "verbose",
      "version"
    ],
    "explanation": "The jmod command has five possible modes: create, extract, describe,\nlist, and hash."
  },
  {
    "number": 66,
    "chapter": 7,
    "question": "This diagram shows the second step of a migration to modules. What type of  \nmigration is this?\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Bottom-up.",
      "Side-to-side.",
      "Top-down.",
      "There is not enough information to determine which type it is."
    ],
    "explanation": "There is no such thing as a side-to-side migration, ruling out option B. In a top-down\nmigration, all modules are moved to the module path first, making option C incorrect. In a \nbottom-up migration, modules are moved, starting with those without dependencies. There-\nfore, option A is correct."
  },
  {
    "number": 67,
    "chapter": 7,
    "question": "Which are true statements about the diagram and scenario in the previous question? \n(Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      3,
      4
    ],
    "options": [
      "butterfly is an automatic module.",
      "butterfly is a named module.",
      "butterfly is an unnamed module.",
      "caterpillar is an automatic module.",
      "caterpillar is a named module.",
      "caterpillar is an unnamed module."
    ],
    "explanation": "In a bottom-up migration, the lowest-level modules are migrated to named modules on\nthe module path first. This makes option E one of the answers. The modules that remain on \nthe classpath are unnamed modules, making option C the other answer."
  },
  {
    "number": 68,
    "chapter": 7,
    "question": "Suppose we have the two JARs in the diagram on the module path and the module-info  \nin the com.magic jar only exports one package: com.magic.unicorn. There is no \nmodule-info file in the com.science JAR. How many of the four packages in the  \ndiagram can a third module on the module path access?\n",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "The com.magic module exports only one package. This makes the \ncom.magic.unicorn package accessible, but not the com.magic.dragon package.  \nBoth packages in com.science are accessible because it is an automatic module. When a \nmodule on the module path does not contain a module-info file, all packages are exported. \nThis gives us three packages that are accessible and a correct answer of option D ."
  },
  {
    "number": 69,
    "chapter": 7,
    "question": "Suppose the two JARs described in the previous question are on the classpath. How many of \nthe four packages in the diagram can a module on the module path access?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "Modules on the module path cannot access anything from the classpath, making option A\nthe correct answer."
  },
  {
    "number": 70,
    "chapter": 7,
    "question": "What is true about the following module-info.java file?\nmodule Book { }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "It does not compile because it is empty.",
      "It does not compile because the module name is uppercase.",
      "It does not compile because the module name has only one component.",
      "It does not compile for another reason.",
      "It compiles."
    ],
    "explanation": "Option E is correct as this code does compile. While it is uncommon, a module is not\nrequired to have any directives in the body. Similarly, module names are lowercase and have \nmore than one component by convention. None of these problems prevents the file from \ncompiling, though."
  },
  {
    "number": 71,
    "chapter": 7,
    "question": "When adding a new service provider, which of these do you need to recompile?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Consumer",
      "Service locator",
      "Existing service providers",
      "Service provider interface",
      "None of the above"
    ],
    "explanation": "One of the benefits of services is not having to recompile existing code when adding a\nnew implementation. This makes option E the correct answer."
  },
  {
    "number": 72,
    "chapter": 7,
    "question": "When working with modules, what option names are equivalent to -m and -s?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "--module and --short",
      "--module and --statistics",
      "--module and --summary",
      "--module-path and --short",
      "--module-path and --statistics",
      "--module-path and --summary"
    ],
    "explanation": "The java command uses -m and --module to supply the module name. The jdeps\ncommand uses -s and --summary to specify the output should be limited. Option C \nmatches both of these."
  },
  {
    "number": 73,
    "chapter": 7,
    "question": "Which are considered part of a service?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Classes referenced by the implementation, but not the interface",
      "Classes referenced by the interface, but not the implementation",
      "Classes referenced by either the implementation or the interface",
      "None of the above"
    ],
    "explanation": "A service is comprised of the interface, any classes the interface references, and a way to\nlook up implementations of the interface. It does not include the implementation. This makes \noption A the correct answer."
  },
  {
    "number": 74,
    "chapter": 7,
    "question": "Which commands have the options -m and –s to represent modules and summary, \nrespectively?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "javac and jar",
      "javac and jdeps",
      "javac and jmod",
      "java and jar",
      "java and jdeps",
      "java and jmod"
    ],
    "explanation": "Option E is correct because both java and jdeps meet the criteria. The jar command\ndoes as well although the options mean different things than working with modules."
  },
  {
    "number": 75,
    "chapter": 7,
    "question": "Suppose you have the following class in a module named animal.insect.impl. Which \ntwo most likely go in the module-info of the service locator? (Choose two.)\npackage animal.insect.impl;\n \nimport animal.insect.api.bugs.Bug;\n \npublic class Worm implements Bug {\n   @Override\n   public int crawl() {\n      return 1;\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "requires animal.insect.api.bugs;",
      "requires animal.insect.api.bugs.Bug;",
      "requires animal.insect.impl;",
      "uses animal.insect.api.bugs;",
      "uses animal.insect.api.bugs.Bug;",
      "uses animal.insect.api.bugs.Bug with animal.insect.impl.Worm;"
    ],
    "explanation": "This question is tricky because the service provider code is shown, but the question\nasks about the service locator, and you need to infer information about the service provider \ninterface. The requires directive is option A due to process of elimination. Option B is \nincorrect because the requires directive references a module name rather than an interface. \nOption C is incorrect because we need the service provider interface module, and it refers \nto the service provider module. Option E is easier, since the uses directive works with an \ninterface name."
  },
  {
    "number": 76,
    "chapter": 7,
    "question": "Which statements are true? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      5
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "A bottom-up migration has more steps involving the classpath than a top-down migration.",
      "A top-down migration has more steps involving the classpath than a bottom-up migration.",
      "Both types of migration have the same number of steps involving the classpath.",
      "A bottom-up migration has unnamed modules on the module path",
      "A top-down migration has unnamed modules on the module path.",
      "Neither migration type has unnamed modules on the module path."
    ],
    "explanation": "A bottom-up migration leaves unnamed modules on the classpath until they are\nmigrated to the module path, making option A correct and option D incorrect. A top-down \nmigration immediately moves all modules to the module path as automatic modules making \noptions B and E incorrect. Therefore, option F is the other correct answer."
  },
  {
    "number": 77,
    "chapter": 7,
    "question": "Fill in the blank with code to look up and call a service.\nString cheese \u003d ServiceLoader.load(Mouse.class)\n   .stream()\n   .map(______________)\n   .map(Mouse::favoriteFood)\n   .findFirst()\n   .orElse(\"\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Mouse.get()",
      "Mouse::get",
      "Provider.get()",
      "Provider::get",
      "None of the above"
    ],
    "explanation": "The ServiceLoader class has a load() method that returns a Collection of \nProvider. Option D is correct because we need to convert the Provider into a Mouse."
  },
  {
    "number": 78,
    "chapter": 7,
    "question": "Given the diagram, what statements need to be in module-info.java for the mammal \nmodule? (Choose three.)\n",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      4
    ],
    "userAnswers": [
      1,
      2,
      4
    ],
    "options": [
      "exports mammal;",
      "exports mammal.eat;",
      "requires animal;",
      "requires animal.util;",
      "requires milk;",
      "requires milk.store;"
    ],
    "explanation": "The mammal module depends on two other modules. Since requires references\nmodule names, options C and E are correct. The module also has one package, which is \nreferenced in the exports directive. This makes option B correct as well."
  },
  {
    "number": 79,
    "chapter": 7,
    "question": "Given the diagram and the following module-info.java for the panda module, \nwhat change can be made to the requires statement?\nmodule panda {\n   requires mammal;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "exports transitive mammal;",
      "exports transitive mammal.eat;",
      "requires transitive animal;",
      "requires transitive animal.util;",
      "transitive requires animal;",
      "transitive requires animal.util;"
    ],
    "explanation": "The transitive keyword goes after requires, ruling out all but options C and D.\nJust like requires, requires transitive references a module name, narrowing it \ndown to option C ."
  },
  {
    "number": 80,
    "chapter": 7,
    "question": "Given the diagram and the following module-info.java for the panda \nmodule, what is the result of including line m1?\nmodule panda {\n   requires mammal;\n   requires transitive mammal; // line m1\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Any modules that require mammal will automatically get panda as well.",
      "Any modules that require panda will automatically get mammal as well.",
      "There is no change in behavior.",
      "The code does not compile."
    ],
    "explanation": "Any requires directives must reference unique modules. Using the transitive keyword\ndoes not change this requirement, making option D the correct answer."
  },
  {
    "number": 81,
    "chapter": 7,
    "question": "How many service providers are allowed to implement a service provider interface and have \nthe consumer reference the first one?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "Exactly one",
      "Exactly two",
      "One or two",
      "One or more",
      "None of the above"
    ],
    "explanation": "There can be multiple service providers for a single service provider interface, making\noption D the correct answer."
  },
  {
    "number": 82,
    "chapter": 7,
    "question": "Which of the following are modules supplied by the JDK? (Choose three.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      4
    ],
    "userAnswers": [],
    "options": [
      "java.logging",
      "java.javadoc",
      "java.jdk",
      "java.management",
      "java.naming",
      "java.scripts"
    ],
    "explanation": "The java.logging, java.management, and java.naming modules exist, mak\ning options A, D, and E correct. Option B is tempting. However, jdk.javadoc exists, not \njava.javadoc. Options C and F are completely made up."
  },
  {
    "number": 83,
    "chapter": 7,
    "question": "Which are true of a JAR file that has only one module-info.class file, placed in the \nMETA-INF directory? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      4
    ],
    "userAnswers": [],
    "options": [
      "It is an automatic module if on the classpath.",
      "It is an automatic module if on the module path.",
      "It is a named module if on the classpath.",
      "It is a named module if on the module path.",
      "It is an unnamed module if on the classpath.",
      "It is an unnamed module if on the module path."
    ],
    "explanation": "Option E is correct because all modules on the classpath are unnamed modules. On\nthe module path, we can have automatic or named modules. In this case, it is an automatic \nmodule because there is no module-info.class at the root of the JAR. Having that file in \nanother directory is ignored. This makes option B the other answer."
  },
  {
    "number": 84,
    "chapter": 7,
    "question": "The service locator and service provider interface share a module. Which boxes represent the \nconsumer and service provider, respectively?\n",
    "answered": false,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "X and Y",
      "X and Z",
      "Y and Z",
      "Z and Z",
      "Z and Y",
      "None of the above"
    ],
    "explanation": "The consumer needs to depend on the shared module, making it X. The shared module\nthen has to be Z, and the service provider has to be Y. This makes option A correct."
  },
  {
    "number": 85,
    "chapter": 7,
    "question": "What statements are most accurate about the ServiceLoader class? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [],
    "options": [
      "load() does not take any parameters.",
      "load() takes the class type as a parameter.",
      "When looping through the results of load(), you need to call the get() method on Provider.",
      "When using the results of load() in a Stream, you need to call the get() method on Provider."
    ],
    "explanation": "The method call of ServiceLoader.load(Poodle.class), takes a param\neter making option B correct and option A incorrect. When using a Stream, you call \nProvider::get, making option D the other answer. Option C is incorrect because you \ndon’t need to call the get() method when using a loop."
  },
  {
    "number": 86,
    "chapter": 7,
    "question": "Suppose we have an automatic module on the module path named  \nlizard-^-cricket-^-1.0.0-SNAPSHOT.jar and no Automatic-Module-Name \nspecified. What module name should named modules use to reference it?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "lizard-cricket",
      "lizard.cricket",
      "lizard-cricket-SNAPSHOT",
      "lizard-cricket.SNAPSHOT",
      "None of the above"
    ],
    "explanation": "The rules for determining the name include removing the extension, removing num\nbers and changing special characters to periods (.). Additionally, we remove the version \ninformation from the end, which is  1 .0 .0-SNAPSHOT. Finally, we normalize the duplicate \ndots, which gives us option B: lizard.cricket. "
  },
  {
    "number": 87,
    "chapter": 7,
    "question": "What file formats are legal for a module to be distributed?",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [],
    "options": [
      "jar",
      "jmod",
      "zip",
      "jar and jmod",
      "jar and zip",
      "jmod and zip"
    ],
    "explanation": "The jar file format is most common. The JMOD jmod format is used as well. Therefore,\noption D is correct."
  },
  {
    "number": 88,
    "chapter": 7,
    "question": "Why is this module-info incorrect for a service provider?\nmodule plant.flower {\n   exports plant.flower.impl;\n   requires plant.flower.api;\n   provides plant.flower.api.Petal \n      with plant.flower.impl.PetalImpl;\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [],
    "options": [
      "The exports directive should be export.",
      "The exports directive should not be present because all calls to the service provider\nshould use the service locator.",
      "The provides directive should be uses instead.",
      "The provides directive has the implementation and interface in the wrong order.",
      "The requires directive should be exports instead.",
      "The requires directive should not be present because provides implies it."
    ],
    "explanation": "Option B is correct because a service provider should not contain an exports directive.\nThe service locator is used to reference any implementation exposed by provides."
  },
  {
    "number": 89,
    "chapter": 7,
    "question": "How many modules are part of the cyclic dependency?\nmodule.com.light {\n   exports com.light;\n}\nmodule com.plant {\n   exports com.plant;\n   requires com.light;\n   requires com.animal;\n}\nmodule com.animal {\n   exports com.animal;\n   requires com.light;\n}\nmodule com.worm {\n   exports com.worm;\n   requires com.light;\n   requires com.animal;\n   requires com.plant;\n}",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [],
    "options": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "explanation": "The com.light module is a dependency for all the other modules but does not depend\non them. Similarly, the com.animal module is a dependency for the two higher-level mod-\nules but does not depend on them. Finally, the com.plant module is a dependency for the \ncom.worm module but does not depend on it. While the modules are not defined in this \norder, the question is about cyclic dependencies rather than order of compilation. There is no \ncyclic dependency, making option A correct."
  },
  {
    "number": 90,
    "chapter": 7,
    "question": "What statements are true about requires mandated java.base? (Choose two.)",
    "answered": false,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [],
    "options": [
      "This output is expected when running the java --list-modules command.",
      "This output is expected when running the java --show-module-resolution command.",
      "This output is expected when running the jdeps command.",
      "This output is expected when running the jmod command.",
      "All modules will include this in the output.",
      "Some modules will include this in the output."
    ],
    "explanation": "The jdeps command outputs requires mandated java.base except when run\nin summary mode, making option C correct. Since this module is an implicit dependency in \nall modules, option E is also correct."
  },
  {
    "number": 1,
    "chapter": 8,
    "question": "What is the output of the following code snippet?\nCallable c \u003d new Callable() {\n   public Object run() {\n      System.out.print(\"X\");\n      return 10;\n   }\n};\nvar s \u003d Executors.newScheduledThreadPool(1);\nfor(int i\u003d0; i\u003c10; i++) {\n   Future f \u003d s.submit(c);\n   f.get();\n}\ns.shutdown();\nSystem.out.print(\"Done!\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "XXXXXXXXXXDone!",
      "Done!XXXXXXXXXX",
      "The code does not compile.",
      "The code hangs indefinitely at runtime.",
      "The code throws an exception at runtime.",
      "The output cannot be determined ahead of time."
    ],
    "explanation": "The code does not compile because Callable must define a call() method, not a\nrun() method, so option C is the correct answer. If the code was fixed to use the correct \nmethod name, then it would complete without issue, printing XXXXXXXXXXDone! at run-\ntime. The f.get() call will block and wait for the results before moving on to the next iter-\nation of the for loop."
  },
  {
    "number": 2,
    "chapter": 8,
    "question": "Which of the following methods is not available on an ExecutorService instance? \n(Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [
      0,
      3,
      0,
      3
    ],
    "options": [
      "execute(Callable)",
      "shutdownNow()",
      "submit(Runnable)",
      "exit()",
      "submit(Callable)",
      "execute(Runnable)"
    ],
    "explanation": "Option A is correct, as ExecutorService does not define nor inherit an overloaded\nmethod execute() that takes a Callable parameter. ExecutorService defines \ntwo shutdown methods, shutdown() and shutdownNow(), one of which is shown \nin option B .  Option D is correct, as exit() does not exist and is not one of shutdown \nmethods. The ExecutorService interface defines the two submit() methods shown \nin options C and E .  Because ExecutorService extends Executor, it also inherits the \nexecute(Runnable) method presented in option F ."
  },
  {
    "number": 3,
    "chapter": 8,
    "question": "The following program simulates flipping a coin an even number of times. Assuming five \nseconds is enough time for all of the tasks to finish, what is the output of the following \napplication?\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\npublic class Luck {\n   private AtomicBoolean coin \u003d new AtomicBoolean(false);\n   void flip() {\n      coin.getAndSet(!coin.get());\n   }\n   public static void main(String[] gamble) throws Exception {\n      var luck \u003d new Luck();\n      ExecutorService s \u003d Executors.newCachedThreadPool();\n      for(int i\u003d0; i\u003c1000; i++) {\n         s.execute(() -\u003e luck.flip());\n      }\n      s.shutdown();\n      Thread.sleep(5000);\n      System.out.println(luck.coin.get());\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "false",
      "true",
      "The code does not compile.",
      "The code hangs indefinitely at runtime.",
      "The code throws an exception at runtime.",
      "The output cannot be determined ahead of time."
    ],
    "explanation": "The code compiles and runs without issue. Even though the thread-safe Atomic Boolean\nis used, it is not used in a thread-safe manner. The flip() method first retrieves the \nvalue and then sets a new value. These two calls are not executed together in an atomic or \nsynchronized manner. For this reason, the output could be true or false, with one or more \nof the flips possibly being lost, and making option F correct."
  },
  {
    "number": 4,
    "chapter": 8,
    "question": "Which of the following is a recommended way to define an asynchronous task?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Create a Callable expression and pass it to an instance of an Executor.",
      "Create a class that extends Thread and override the start() method.",
      "Create a Runnable lambda expression and pass it to a Thread constructor.",
      "Create an anonymous Runnable class that overrides the begin() method.",
      "All of the above."
    ],
    "explanation": "Option A is incorrect, although it would be correct if Executor were replaced with\nExecutorService. Option B is also incorrect, but it would be correct if start() were \nreplaced with run(). Option C is correct and is a common way to define an asynchronous \ntask using a lambda expression. Option D is incorrect, as Runnable does not inherit a \nbegin() method."
  },
  {
    "number": 5,
    "chapter": 8,
    "question": "Given the following program, how many times is Locked! expected to be printed? Assume \n100 milliseconds is enough time for each task created by the program to complete.\nimport java.util.concurrent.locks.*;\npublic class Padlock {\n   private Lock lock \u003d new ReentrantLock();\n   public void lockUp() {\n      if (lock.tryLock()) {\n         lock.lock();\n         System.out.println(\"Locked!\");\n         lock.unlock();\n      }\n   }\n   public static void main(String... unused) throws Exception {\n      var gate \u003d new Padlock();\n      for(int i\u003d0; i\u003c5; i++) {\n         new Thread(() -\u003e gate.lockUp()).start();\n         Thread.sleep(100);\n      }\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One time.",
      "Five times.",
      "The code does not compile.",
      "The code hangs indefinitely at runtime.",
      "The code throws an exception at runtime.",
      "The output cannot be determined ahead of time."
    ],
    "explanation": "If the tryLock() method returns true, then a lock is acquired that must be released.\nThat means the lockUp() method actually contains two calls to lock the object and only \none call to unlock it. For this reason, the first thread to reach tryLock() obtains a lock that \nis never released. For this reason, Locked! is printed only once, and option A is correct. If \nthe call to lock() inside the if statement was removed, then the expected output would be \nto print the statement five times."
  },
  {
    "number": 6,
    "chapter": 8,
    "question": "Given the original array, how many of the following for statements result in an exception at \nruntime, assuming each is executed independently?\nvar original \u003d List.of(1,2,3,4,5);\n \nvar copy1 \u003d new CopyOnWriteArrayList\u003cInteger\u003e(original);\nfor(Integer w : copy1)\n   copy1.remove(w);\n \nvar copy2 \u003d Collections.synchronizedList(original);\nfor(Integer w : copy2)\n   copy2.remove(w);\n \nvar copy3 \u003d new ArrayList\u003cInteger\u003e(original);\nfor(Integer w : copy3)\n   copy3.remove(w);\n \nvar copy4 \u003d new ConcurrentLinkedQueue\u003cInteger\u003e(original);\nfor(Integer w : copy4)\n   copy4.remove(w);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Zero.",
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "The code does not compile."
    ],
    "explanation": "CopyOnWriteArrayList makes a copy of the array every time it is modified, \npreserving the original list of values the iterator is using, even as the array is modified.  \nFor this reason, the for loop using copy1 does not throw an exception at runtime.  \nOn the other hand, the for loops using copy2 and copy3 both throw  \nConcurrent ModificationException at runtime since neither allows modification \nwhile they are being iterated upon. Finally, the ConcurrentLinkedQueue used in copy4 \ncompletes without throwing an exception at runtime. For the exam, remember that the\nConcurrent classes order read/write access such that access to the class is consistent across \nall threads and processes, while the synchronized classes do not. Because exactly two of the \nfor statements produce exceptions at runtime, option C is the correct answer."
  },
  {
    "number": 7,
    "chapter": 8,
    "question": "Fill in the blanks: ______________ is a special case of ______________, in which two or more \nactive threads try to acquire the same set of locks and are repeatedly unsuccessful.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Deadlock, livelock",
      "Deadlock, resource starvation",
      "Livelock, resource starvation",
      "Resource starvation, race conditions",
      "Resource starvation, livelock",
      "None of the above"
    ],
    "explanation": "Resource starvation is when a single active thread is perpetually unable to gain access to a\nshared resource. Livelock is a special case of resource starvation, in which two or more active \nthreads are unable to gain access to shared resources, repeating the process over and over \nagain. For these reasons, option C is the correct answer. Deadlock and livelock are similar, \nalthough in a deadlock situation the threads are stuck waiting, rather than being active or \nperforming any work. Finally, a race condition is an undesirable result when two tasks that \nshould be completed sequentially are completed at the same time."
  },
  {
    "number": 8,
    "chapter": 8,
    "question": "What is the output of the following application?\n3:  public class TpsReport {\n4:     public void submitReports() {\n5:        var s \u003d Executors.newCachedThreadPool();\n6:        Future bosses \u003d s.submit(() -\u003e System.out.print(\"1\"));\n7:        s.shutdown();\n8:        System.out.print(bosses.get());\n9:     }\n10:    public static void main(String[] memo) {\n11:       new TpsReport().submitReports();\n12:    }\n13: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "null",
      "1null",
      "1",
      "Line 6 does not compile.",
      "Line 8 does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The class does not compile because the Future.get() on line 8 throws a checked\nInterruptedException and a checked ExecutionException, neither of which is \nhandled nor declared by the submitReports() method. If the submitReports() and \naccompanying main() methods were both updated to declare these exceptions, then the \napplication would print 1null at runtime. For the exam, remember that Future can be \nused with Runnable lambda expressions that do not have a return value but that the return \nvalue is always null when completed."
  },
  {
    "number": 9,
    "chapter": 8,
    "question": "Which of the following static methods does not exist in the Executors class? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "newFixedScheduledThreadPool()",
      "newThreadPool()",
      "newFixedThreadPool(int)",
      "newSingleThreadExecutor()",
      "newScheduledThreadPool(int)",
      "newSingleThreadScheduledExecutor()"
    ],
    "explanation": "Options C, D, E, and F are all proper ways to obtain instances of \nExecutor Service. Remember that newSingleThreadExecutor() is equivalent  \nto calling newFixedThreadPool(int) with a value of 1 . The correct answers are  \noptions A and B, as neither of these methods exist."
  },
  {
    "number": 10,
    "chapter": 8,
    "question": "How many times does the following application print Ready at runtime?\npackage parade;\nimport java.util.concurrent.*;\npublic class CartoonCat {\n   private void await(CyclicBarrier c) {\n      try {\n         c.await();\n      } catch (Exception e) {}\n   }\n   public void march(CyclicBarrier c) {\n      var s \u003d Executors.newSingleThreadExecutor();\n      for(int i\u003d0; i\u003c12; i++)\n         s.execute(() -\u003e await(c));\n      s.shutdown();\n   }\n   public static void main(String... strings) {\n      new CartoonCat().march(new CyclicBarrier(4,\n            () -\u003e System.out.println(\"Ready\")));\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Zero.",
      "One.",
      "Three.",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The code compiles without issue but hangs indefinitely at runtime. The application defines\na thread executor with a single thread and 12 submitted tasks. Because only one thread is \navailable to work at a time, the first thread will wait endlessly on the call to await(). Since \nthe CyclicBarrier requires four threads to release it, the application waits endlessly in a \nfrozen condition. Since the barrier is never reached and the code hangs, the application will \nnever output Ready, making option A the correct answer. If newCachedThreadPool() \nhad been used instead of newSingleThreadExecutor(), then the barrier would be \nreached three times, and option C would be the correct answer."
  },
  {
    "number": 11,
    "chapter": 8,
    "question": "Let’s say you needed a thread executor to create tasks for a CyclicBarrier that has a barrier \nlimit of five threads. Which static method in ExecutorService should you use to obtain it?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "newSingleThreadExecutor()",
      "newSingleThreadScheduledExecutor()",
      "newCachedThreadPool()",
      "newFixedThreadPool(2)",
      "None of the above"
    ],
    "explanation": "Trick question! ExecutorService does not contain any of these methods. To obtain an\ninstance of a thread executor, you need to use the Executors factory class. For this reason, \noption E is the correct answer. If the question had instead asked which Executors method \nto use, then the correct answer would be option C .  Options A, B, and D do not create \nenough threads for a CyclicBarrier expecting to reach a limit of five concurrent threads. \nOption C, on the other hand, will create threads as needed and is appropriate for use with a \nCyclicBarrier."
  },
  {
    "number": 12,
    "chapter": 8,
    "question": "The following diagrams represent the order of read/write operations of two threads sharing \na common variable. Each thread first reads the value of the variable from memory and then \nwrites a new value of the variable back to memory. Which diagram demonstrates proper  \nsynchronization?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": true,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "",
      "",
      "",
      ""
    ],
    "explanation": "Part of synchronizing access to a variable is ensuring that read/write operations are\natomic or happen without interruption. For example, an increment operation requires \nreading a value and then immediately writing it. If any thread interrupts this process, then \ndata could be lost. In this regard, option C shows proper synchronized access. Thread 2 \nreads a value and then writes it without interruption. Thread 1 then reads the new value and \nwrites it. The rest of the answers are incorrect because one thread writes data to the variable\nin-between another thread reading and writing to the same variable. Because a thread is \nwriting data to a variable that has already been written to by another thread, it may set \ninvalid data. For example, two increment operations running at the same time could result in \none of the increment operations being lost."
  },
  {
    "number": 13,
    "chapter": 8,
    "question": "What is the output of the following application?\nimport java.util.*;\nimport java.util.concurrent.*;\npublic class Race {\n   ExecutorService service \u003d Executors.newFixedThreadPool(8);\n   public static int sleep() {\n      try { Thread.sleep(1000); } catch (Exception e) {}\n      return 1;\n   }\n   public void hare() {\n      try {\n         Callable\u003cInteger\u003e c \u003d () -\u003e sleep();\n         final var r \u003d List.of(c,c,c);\n         var results \u003d service.invokeAll(r);\n         System.out.println(\"Hare won the race!\");\n      } catch (Exception e) {e.printStackTrace();}\n   }\n   public void tortoise() {\n      try {\n         Callable\u003cInteger\u003e c \u003d () -\u003e sleep();\n         final var r \u003d List.of(c,c,c);\n         Integer result \u003d service.invokeAny(r);\n         System.out.println(\"Tortoise won the race!\");\n      } catch (Exception e) {e.printStackTrace();}\n   }\n   public static void main(String[] p) throws Exception {\n      var race \u003d new Race();\n      race.service.execute(() -\u003e race.hare());\n      race.service.execute(() -\u003e race.tortoise());\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Hare won the race! is printed first.",
      "Tortoise won the race! is printed first.",
      "The code does not compile.",
      "The code hangs indefinitely at runtime.",
      "The code throws an exception at runtime.",
      "The output cannot be determined ahead of time."
    ],
    "explanation": "The code compiles and runs without issue. The two methods hare() and tortoise()\nare nearly identical, with one calling invokeAll() and the other calling invokeAny(). \nCalling the invokeAll() method causes the current thread to wait until all tasks are fin-\nished, while calling the invokeAny() method will cause the current thread to wait until \nat least one task is complete. Both ExecutorService methods operate synchronously, \nwaiting for a result from one or more tasks, but each method call has been submitted to the \nthread executor as an asynchronous task. For this reason, both methods will take about one \nsecond to complete, and since either can finish first, the output will vary at runtime, making \noption F correct. Note that this program does not terminate, since the ExecutorService is \nnot shut down."
  },
  {
    "number": 14,
    "chapter": 8,
    "question": "Which of the following concurrent collections is sorted? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "ConcurrentSkipList",
      "ConcurrentSkipListSet",
      "CopyOnWriteArrayList",
      "ConcurrentSkipListMap",
      "ConcurrentLinkedQueue",
      "LinkedBlockingQueue"
    ],
    "explanation": "ConcurrentSkipList does not exist as a concurrent collection, making option A\nincorrect. ConcurrentSkipListSet implements the SortedSet interface, in which the \nelements are kept sorted, making option B correct. ConcurrentSkipListMap implements \nthe SortedMap interface, in which the keys are kept sorted, making option D correct. The \nother options define structures that are ordered, but not sorted. Remember, if you see  \nSkipList as part of a concurrent class name, it means it is sorted in some way."
  },
  {
    "number": 15,
    "chapter": 8,
    "question": "What is the output of the following application?\npackage taxes;\nimport java.util.concurrent.*;\npublic class Accountant {\n   public static void completePaperwork() {\n      System.out.print(\"[Filing]\");\n   }\n   public static double getPi() {\n      return 3.14159;\n   }\n   public static void main(String[] args) throws Exception {\n      ExecutorService x \u003d Executors.newSingleThreadExecutor();\n      Future\u003c?\u003e f1 \u003d x.submit(() -\u003e completePaperwork());\n      Future\u003cObject\u003e f2 \u003d x.submit(() -\u003e getPi());\n      System.out.print(f1.get()+\" \"+f2.get());\n      x.shutdown();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "[Filing]",
      "[Filing]3.14159",
      "[Filing]null 3.14159",
      "The declaration of f1 does not compile.",
      "The declaration of f2 does not compile.",
      "The output cannot be determined ahead of time."
    ],
    "explanation": "The code compiles without issue, so options D and E are incorrect. The f1 declaration\nuses the version of submit() in ExecutorService, which takes a Runnable and returns \na Future\u003c?\u003e, while the f2 declaration uses an overloaded version of submit(), which \ntakes a Callable expression and returns a generic Future object. The call  f1 .get() \nwaits until the task is finished and always returns null, since Runnable expressions have \na void return type, so [Filing]null is printed first. The call to  f2 .get() returns then \nprints  3 .14159 .  For these reasons, option C is the correct answer."
  },
  {
    "number": 16,
    "chapter": 8,
    "question": "Assuming 10 seconds is enough time for all of the tasks to finish, what statements about the \nfollowing program are correct? (Choose two.)\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\npublic class Clock {\n   private AtomicLong bigHand \u003d new AtomicLong(0);\n   void incrementBy10() {\n      bigHand.getAndSet(bigHand.get() + 10);\n   }\n   public static void main(String[] c) throws Exception {\n      var smartWatch \u003d new Clock();\n      ExecutorService s \u003d Executors.newCachedThreadPool();\n      for(int i\u003d0; i\u003c100; i++) {\n         s.submit(() -\u003e smartWatch.incrementBy10()).get();\n      }\n      s.shutdown();\n      s.awaitTermination(10, TimeUnit.SECONDS);\n      System.out.println(smartWatch.bigHand.get());\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "The code does not compile.",
      "The incrementBy10() method is thread-safe.",
      "The incrementBy10() method is not thread-safe.",
      "The output is 1000 on every execution.",
      "The output cannot be determined ahead of time.",
      "The code hangs indefinitely at runtime."
    ],
    "explanation": "The code compiles and runs without issue. While an AtomicLong is used, there are\ntwo calls on this variable, the first to retrieve the value and the second to set the new value. \nThese two calls are not executed together in an atomic or synchronized manner. For this \nreason, the incrementBy10() method is not thread-safe, and option C is correct. That \nsaid, the code performs in single-threaded manner at runtime because the call to get() in \nthe main() method waits for each thread to finish. For this reason, the output is consistently \n1000, making option D correct."
  },
  {
    "number": 17,
    "chapter": 8,
    "question": "What is the most likely result of executing the following application?\npackage jokes;\nimport java.util.concurrent.*;\npublic class Riddle {\n   public void sleep() {\n      try { Thread.sleep(5000); } catch (Exception e) {}\n   }\n   public String getQuestion(Riddle r) {\n      synchronized {\n         sleep();\n         if(r !\u003d null) r.getAnswer(null);\n         return \"How many programmers does it take \"\n               + \"to change a light bulb?\";\n      }\n   }\n   public synchronized String getAnswer(Riddle r) {\n      sleep();\n      if(r !\u003d null) r.getAnswer(null);\n      return \"None, that\u0027s a hardware problem\";\n   }\n \n   public static void main(String... ununused) {\n      var r1 \u003d new Riddle();\n      var r2 \u003d new Riddle();\n      var s \u003d Executors.newFixedThreadPool(2);\n      s.submit(() -\u003e r1.getQuestion(r2));\n      s.execute(() -\u003e r2.getAnswer(r1));\n      s.shutdown();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "A deadlock is produced at runtime.",
      "A livelock is produced at runtime.",
      "The application completes successfully.",
      "The code does not compile.",
      "The code hangs indefinitely at runtime.",
      "The output cannot be determined ahead of time."
    ],
    "explanation": "The synchronized block used in the getQuestion() method requires an object\nto synchronize on. Without it, the code does not compile, and option D is the correct \nanswer. What if the command was fixed to synchronize on the current object, such as using \nsynchronized(this)? Each task would obtain a lock for its respective object and then \nwait a couple of seconds before requesting the lock for the other object. Since the locks are \nalready held, both wait indefinitely, likely resulting in a deadlock. We say most likely because \neven with corrected code, a deadlock is not guaranteed. It is possible, albeit very unlikely, for \nthe JVM to wait five seconds before starting the second task, allowing enough time for the \nfirst task to finish and avoiding the deadlock completely."
  },
  {
    "number": 18,
    "chapter": 8,
    "question": "Which ScheduledExecutorService method can result in the same action being executed by two \nthreads at the same time?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "scheduleAtFixedDelay()",
      "scheduleAtFixedRate()",
      "scheduleWithFixedDelay()",
      "scheduleAtSameRate()",
      "scheduleWithRate()",
      "None of the above"
    ],
    "explanation": "Options A, D, and E include method names that do not exist in \nScheduled ExecutorService. The scheduleAtFixedRate() method creates a  \nnew task for the associated action at a set time interval, even if previous tasks for the same \naction are still active. In this manner, it is possible multiple threads working on the same \naction could be executing at the same time, making option B the correct answer. On the \nother hand, scheduleWithFixedDelay() waits until each task is completed before \nscheduling the next task, guaranteeing at most one thread working on the action is active \nin the thread pool."
  },
  {
    "number": 19,
    "chapter": 8,
    "question": "What is the output of the following application?\npackage olympics;\nimport java.util.concurrent.*;\npublic class Athlete {\n   int stroke \u003d 0;\n   public synchronized void swimming() {\n      stroke++;\n   }\n   private int getStroke() {\n      synchronized(this) { return stroke; }\n   }\n   public static void main(String... laps) {\n      ExecutorService s \u003d Executors.newFixedThreadPool(10);\n      Athlete a \u003d new Athlete();\n      for(int i\u003d0; i\u003c1000; i++) {\n         s.execute(() -\u003e a.swimming());\n      }\n      s.shutdown();\n      System.out.print(a.getStroke());\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "A deadlock is produced at runtime.",
      "A livelock is produced at runtime.",
      "1000",
      "The code does not compile.",
      "The result is unknown until runtime because stroke is not written in a thread-safe\nmanner and a write may be lost.",
      "None of the above."
    ],
    "explanation": "The application compiles, so option D is incorrect. The stroke variable is thread-safe\nin the sense that no write is lost, since all writes are wrapped in a synchronized method, \nmaking option E incorrect. The issue here is that the main() method reads the value of \ngetStroke() while tasks may still be executing within the ExecutorService. The \nshutdown() method stops new tasks from being submitted but does not wait for previously \nsubmitted tasks to complete. Therefore, the result may output 0, 1000, or anything in  \nbetween, making option F the correct answer. If the ExecutorService method  \nawait Termination() is called before the value of stroke is printed and enough time \nelapses, then the result would be 1000 every time."
  },
  {
    "number": 20,
    "chapter": 8,
    "question": "Which of the following is most likely to be caused by a race condition?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "A thread perpetually denied access to a resource",
      "A program hanging indefinitely",
      "An int variable incorrectly reporting the number of times an operation was performed",
      "Two threads actively trying to restart a blocked process that is guaranteed to always end the same way",
      "Two threads endlessly waiting on each other to release shared locks"
    ],
    "explanation": "A race condition is an undesirable result when two tasks that should be completed\nsequentially are completed at the same time. The result is often corruption of data in some \nway. If two threads are both modifying the same int variable and there is no synchroniza-\ntion, then a race condition can occur with one of the writes being lost. For this reason, option \nC is the correct answer. Option A is the description of resource starvation. Options D and \nE are describing livelock and deadlock, respectively, while option B is the potential result of \neither of those events occurring."
  },
  {
    "number": 21,
    "chapter": 8,
    "question": "Which statement about the following class is correct?\npackage my;\nimport java.util.*;\npublic class ThreadSafeList {\n   private List\u003cInteger\u003e data \u003d new ArrayList\u003c\u003e();\n   public synchronized void addValue(int value) {\n      data.add(value);\n   }\n   public int getValue(int index) {\n      return data.get(index);\n   }\n   public int size() {\n      synchronized(ThreadSafeList.class) {\n         return data.size();\n      }\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "The code compiles and is thread-safe.",
      "The code compiles and is not thread-safe.",
      "The code does not compile because of the size() method.",
      "The code does not compile because of the getValue() method.",
      "The code does not compile for another reason.",
      "None of the above."
    ],
    "explanation": "The class compiles without issue. The class attempts to create a synchronized version\nof a List\u003cInteger\u003e. The size() and addValue() help synchronize the read/write \noperations. Unfortunately, the getValue() method is not synchronized so the class is \nnot thread-safe, and option B is the correct answer. It is possible that one thread could add \nto the data object while another thread is reading from the object, leading to an unex-\npected result."
  },
  {
    "number": 22,
    "chapter": 8,
    "question": "Which two method names, when filled into the print2() method, produce the same output \nas the print1() method? Assume the input arguments for each represent the same non-null \nnumeric value.\npublic static synchronized void print1(int counter) {\n   System.out.println(counter--);\n   System.out.println(++counter);\n}\n \npublic static synchronized void print2(AtomicInteger counter) {\n   System.out.println(counter. );\n   System.out.println(counter. );\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "decrementAndGet() and getAndIncrement()",
      "decrementAndGet() and incrementAndGet()",
      "getAndDecrement() and getAndIncrement()",
      "getAndDecrement() and incrementAndGet()",
      "None of the above"
    ],
    "explanation": "The post-decrement operator (––) decrements a value but returns the original value. \nIt is equivalent to the atomic getAndDecrement() method. The pre-increment  \noperator (++) increments a value and then returns the new value. It is equivalent to the  \nincrement AndGet() atomic operation. For these reasons, option D is the  \ncorrect answer."
  },
  {
    "number": 23,
    "chapter": 8,
    "question": "How many lines of the following code snippet contain compilation errors?\n11: ScheduledExecutorService t \u003d Executors\n12:    .newSingleThreadScheduledExecutor();\n13: Future result \u003d t.execute(System.out::println);\n14: t.invokeAll(null);\n15: t.scheduleAtFixedRate(() -\u003e {return;},5,TimeUnit.MINUTES);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "None of the above"
    ],
    "explanation": "Line 13 does not compile because the execute() method has a return type of void, not\nFuture. Line 15 does not compile because scheduleAtFixedRate() requires four argu-\nments that include an initial delay and period value. For these two reasons, option C is the \ncorrect answer."
  },
  {
    "number": 24,
    "chapter": 8,
    "question": "How many times does the following application print W at runtime?\npackage crew;\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class Boat {\n   private void waitTillFinished(CyclicBarrier c) {\n      try {\n         c.await();\n         System.out.print(\"W\");\n      } catch (Exception e) {}\n   }\n   public void row(ExecutorService s) {\n      var cb \u003d new CyclicBarrier(5);\n      IntStream.iterate(1, i-\u003e i+1)\n         .limit(12)\n         .forEach(i -\u003e s.submit(() -\u003e waitTillFinished(cb)));\n   }\n   public static void main(String[] oars) {\n      ExecutorService service \u003d null;\n      try {\n         service \u003d Executors.newCachedThreadPool();\n         new Boat().row(service);\n      } finally {\n         service.isShutdown();\n      } } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "0",
      "10",
      "12",
      "The code does not compile.",
      "The output cannot be determined ahead of time.",
      "None of the above."
    ],
    "explanation": "When a CyclicBarrier goes over its limit, the barrier count is reset to zero. The appli\ncation defines a CyclicBarrier with a barrier limit of 5 threads. The application then sub-\nmits 12 tasks to a cached executor service. In this scenario, a cached thread executor will use \nbetween 5 and 12 threads, reusing existing threads as they become available. In this manner,\nthere is no worry about running out of available threads. The barrier will then trigger twice, \nprinting five values for each of the sets of threads, for a total of ten W characters. For this \nreason, option B is the correct answer."
  },
  {
    "number": 25,
    "chapter": 8,
    "question": "Using the Boat class, what is the final state of the application?\npackage crew;\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class Boat {\n   private void waitTillFinished(CyclicBarrier c) {\n      try {\n         c.await();\n         System.out.print(\"W\");\n      } catch (Exception e) {}\n   }\n   public void row(ExecutorService s) {\n      var cb \u003d new CyclicBarrier(5);\n      IntStream.iterate(1, i-\u003e i+1)\n         .limit(12)\n         .forEach(i -\u003e s.submit(() -\u003e waitTillFinished(cb)));\n   }\n   public static void main(String[] oars) {\n      ExecutorService service \u003d null;\n      try {\n         service \u003d Executors.newCachedThreadPool();\n         new Boat().row(service);\n      } finally {\n         service.isShutdown();\n      } } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "The application produces an exception at runtime.",
      "The application terminates successfully.",
      "The application hangs indefinitely because the ExecutorService is never shut down.",
      "The application produces a deadlock at runtime.",
      "None of the above."
    ],
    "explanation": "The application does not terminate successfully nor produce an exception at runtime,\nmaking options A and B incorrect. It hangs at runtime because the CyclicBarrier limit is \n5, while the number of tasks submitted and awaiting activation is 12 .  This means that two \nof the tasks will be left over, stuck in a deadlocked state, waiting for the barrier limit to be \nreached but with no more tasks available to trigger it. For this reason, option D is the correct \nanswer. If the number of tasks was a multiple of the barrier limit, such as 15 instead of 12, \nthen the application will still hang because the ExecutorService is never shut down, and \noption C would be correct. The isShutdown() call in the application finally block does \nnot trigger a shutdown. Instead, shutdown() should have been used."
  },
  {
    "number": 26,
    "chapter": 8,
    "question": "Given the following program, how many times is TV Time expected to be printed? Assume \n10 seconds is enough time for each task created by the program to complete.\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\npublic class Television {\n   private static Lock myTurn \u003d new ReentrantLock();\n   public void watch() {\n      try {\n         if (myTurn.lock(5, TimeUnit.SECONDS)) {\n            System.out.println(\"TV Time\");\n            myTurn.unlock();\n         }\n      } catch (InterruptedException e) {}\n   }\n   public static void main(String[] t) throws Exception {\n      var newTv \u003d new Television();\n      for (int i \u003d 0; i \u003c 3; i++) {\n         new Thread(() -\u003e newTv.watch()).start();\n         Thread.sleep(10*1000);\n      }\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "One time.",
      "Three times.",
      "The code does not compile.",
      "The code hangs indefinitely at runtime.",
      "The code throws an exception at runtime.",
      "The output cannot be determined ahead of time."
    ],
    "explanation": "The Lock interface does not include an overloaded version of lock() that takes a time\nout value and returns a boolean. For this reason, the code does not compile, and option \nC is correct. If tryLock(long,TimeUnit) had been used instead of lock(), then the \nprogram would have been expected to print TV Time three times at runtime."
  },
  {
    "number": 27,
    "chapter": 8,
    "question": "Given the original array, how many of the following for statements enter an infinite loop at \nruntime, assuming each is executed independently?\nvar original \u003d new ArrayList\u003cInteger\u003e(List.of(1,2,3));\n \nvar copy1 \u003d new ArrayList\u003cInteger\u003e(original);\nfor(Integer q : copy1)\n   copy1.add(1);\n \nvar copy2 \u003d new CopyOnWriteArrayList\u003cInteger\u003e(original);\nfor(Integer q : copy2)\n   copy2.add(2);\n \nvar copy3 \u003d new LinkedBlockingQueue\u003cInteger\u003e(original);\nfor(Integer q : copy3)\n   copy3.offer(3);\n \nvar copy4 \u003d Collections.synchronizedList(original);\nfor(Integer q : copy4)\n   copy4.add(4);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Zero.",
      "One.",
      "Two.",
      "Three.",
      "Four.",
      "The code does not compile."
    ],
    "explanation": "The for loops using copy1 and copy4 both throw a \nConcurrentModification Exception at runtime, since neither allows  \nmodification while they are being iterated upon. Next, CopyOnWriteArrayList makes \na copy of the collection every time it is modified, preserving the original list of values the \niterator is using. For this reason, the for loop using copy2 completes without throwing \nan exception or creating an infinite loop. On the other hand, the loop with copy3 enters \nan infinite loop at runtime. Each time a new value is inserted, the iterator is updated, and \nthe process repeats. Since this is the only statement that produces an infinite loop, option B \nis correct."
  },
  {
    "number": 28,
    "chapter": 8,
    "question": "Which ExecutorService method guarantees all running tasks are stopped in an \norderly fashion?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "shutdown()",
      "shutdownNow()",
      "halt()",
      "shutdownAndTerminate()",
      "None of the above"
    ],
    "explanation": "The shutdown() method prevents new tasks from being added but allows existing\ntasks to finish. In addition to preventing new tasks from being added, the shutdownNow() \nmethod also attempts to stop all running tasks. Neither of these methods guarantees any task \nwill be stopped, making option E the correct answer. Options C and D are incorrect because \nthey name methods that do not exist in ExecutorService."
  },
  {
    "number": 29,
    "chapter": 8,
    "question": "Assuming 10 seconds is enough time for all of the tasks to finish, what is the output of the \nfollowing application?\nimport java.util.concurrent.*;\npublic class Bank {\n   static int cookies \u003d 0;\n   public synchronized void deposit(int amount) {\n      cookies +\u003d amount;\n   }\n   public static synchronized void withdrawal(int amount) {\n      cookies -\u003d amount;\n   }\n   public static void main(String[] amount) throws Exception {\n      var teller \u003d Executors.newScheduledThreadPool(50);\n      Bank bank \u003d new Bank();\n      for(int i\u003d0; i\u003c25; i++) {\n         teller.submit(() -\u003e bank.deposit(5));\n         teller.submit(() -\u003e bank.withdrawal(5));\n      }\n      teller.shutdown();\n      teller.awaitTermination(10, TimeUnit.SECONDS);\n      System.out.print(bank.cookies);\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "0",
      "125",
      "-125",
      "The code does not compile.",
      "The result is unknown until runtime.",
      "An exception is thrown."
    ],
    "explanation": "The program compiles and does not throw an exception at runtime. The class attempts\nto add and remove values from a single cookie variable in a thread-safe manner but fails \nto do so because the methods deposit() and withdrawal() synchronize on differ-\nent objects. The instance method deposit() synchronizes on the bank object, while the \nstatic method withdrawal() synchronizes on the static Bank.class object. Since the \ncompound assignment operators (+\u003d) and (-\u003d) are not thread-safe, it is possible for one call \nto modify the value of cookies while the other is already operating on it, resulting in a loss \nof information. For this reason, the output cannot be predicted, and option E is the correct \nanswer. If the two methods were synchronized on the same object, then the cookies vari-\nable would be protected from concurrent modifications, printing 0 at runtime."
  },
  {
    "number": 30,
    "chapter": 8,
    "question": "What is the output of the following application?\nimport java.util.*;\npublic class SearchList\u003cT\u003e {\n   private List\u003cT\u003e data;\n   private boolean foundMatch \u003d false;\n   public SearchList(List\u003cT\u003e list) {\n      this.data \u003d list;\n   }\n   public void exists(T v,int start, int end) {\n      if(end-start\u003d\u003d0) {}\n      else if(end-start\u003d\u003d1) {\n         foundMatch \u003d foundMatch || v.equals(data.get(start));\n      } else {\n         final int middle \u003d start + (end-start)/2;\n         new Thread(() -\u003e exists(v,start,middle)).run();\n         new Thread(() -\u003e exists(v,middle,end)).run();\n      }\n   }\n   public static void main(String[] a) throws Exception {\n      List\u003cInteger\u003e data \u003d List.of(1,2,3,4,5,6);\n      SearchList\u003cInteger\u003e t \u003d new SearchList\u003cInteger\u003e(data);\n      t.exists(5, 0, data.size());\n      System.out.print(t.foundMatch);\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "true",
      "false",
      "The code does not compile.",
      "The result is unknown until runtime.",
      "An exception is thrown.",
      "None of the above."
    ],
    "explanation": "The code attempts to search for a matching element in an array using multiple threads.\nWhile it does not contain any compilation problems, it does contain an error. Despite cre-\nating Thread instances, it is not a multithreaded program. Calling run() on a Thread runs\nthe process as part of the current thread. To be a multithreaded execution, it would need to \ninstead call the start() method. For this reason, the code completes synchronously, waiting \nfor each method call to return before moving on to the next and printing true at the end of \nthe execution, making option A the correct answer. On the other hand, if start() had been \nused, then the application would be multithreaded but not thread-safe. The calls to update \nfoundMatch are not synchronized, and even if they were, the result might not be available \nby the time print() in the main() method was called. For this reason, the result would \nnot be known until runtime."
  },
  {
    "number": 1,
    "chapter": 9,
    "question": "The following code snippet results in an exception at runtime. Which of the following is the \nmost likely type of exception to be thrown?\nvar oldHardDrivePath \u003d Path.get(\"c://rodent/mouse.txt\");\nvar newHardDrivePath \u003d Path.get(\"d://rodent/rat.txt\");\nFiles.move(oldHardDrivePath,newHardDrivePath,\n   StandardCopyOption.REPLACE_EXISTING);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "AtomicMoveNotSupportedException",
      "DirectoryNotEmptyException",
      "FileAlreadyExistsException",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The code does not compile because Path.get() is not a valid NIO.2 method, making\noption D correct. Either Paths.get() or Path.of() should be used instead. If the  \ncorrect method was used, then DirectoryNotEmptyException would be the correct \nanswer. The AtomicMoveNotSupportedException in option A is possible only  \nwhen the ATOMIC_MOVE option is passed to the move() method. Similarly, the  \nFileAlreadyExists Exception in option C is possible only when the  \nREPLACE_EXISTING option is not passed to the move() method."
  },
  {
    "number": 2,
    "chapter": 9,
    "question": "What is the result of compiling and executing the following program?\npackage vacation;\nimport java.io.*;\nimport java.util.*;\npublic class Itinerary {\n   private List\u003cString\u003e activities \u003d new ArrayList\u003c\u003e();\n   private static Itinerary getItinerary(String name) {\n      return null;\n   }\n   public static void printItinerary() throws Exception {\n      Console c \u003d new Console();\n      final String name \u003d c.readLine(\"What is your name?\");\n      final var stuff \u003d getItinerary(name);\n      stuff.activities.forEach(s -\u003e c.printf(s));\n   }\n   public static void main(String[] h) throws Exception {\n      printItinerary();\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "The code does not compile.",
      "The code compiles and prints a NullPointerException at runtime.",
      "The code compiles but does not print anything at runtime.",
      "The code compiles and prints the value the user enters at runtime.",
      "The behavior cannot be determined until runtime.",
      "None of the above."
    ],
    "explanation": "The constructor for Console is private. Therefore, attempting to call new\nConsole() outside the class results in a compilation error, making option A the correct \nanswer. The correct way to obtain a Console instance is to call System.console(). Even \nif the correct way of obtaining a Console had been used, and the Console was available at \nruntime, stuff is null in the printItinerary() method. Referencing stuff \n.activities results in a NullPointerException."
  },
  {
    "number": 3,
    "chapter": 9,
    "question": "Assuming the file path referenced in the following class is accessible and writable, what is the \noutput of the following program? (Choose two.)\nString fn \u003d \"icecream.txt\";\ntry (var w \u003d new BufferedWriter(new FileOutputStream(fn));\n     var s \u003d System.out) {\n   w.write(\"ALERT!\");\n   w.flush();\n   w.write(\u0027!\u0027);\n   System.out.print(\"1\");\n} catch (IOException e) {\n   System.out.print(\"2\");\n} finally {\n   System.out.print(\"3\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3,
      5
    ],
    "userAnswers": [
      3,
      5
    ],
    "options": [
      "1",
      "23",
      "13",
      "The code does not compile.",
      "If the code compiles or the lines that do not compile are fixed, then the last value output is 3.",
      "If the code compiles or the lines that do not compile are fixed, then the last value output is not 3."
    ],
    "explanation": "BufferedWriter is a wrapper class that requires an instance of Writer to operate\non. Since FileOutputStream does not inherit Writer, the code does not compile, and \noption D is correct. If FileWriter was used instead of FileOutputStream, then the \ncode would compile without issue and print 1 .  The try-with-resources statement closes \nSystem.out before the catch or finally blocks are called. When the finally block is \nexecuted, the output has nowhere to go, which means the last value of 3 is not printed, mak-\ning option F correct."
  },
  {
    "number": 4,
    "chapter": 9,
    "question": "What is the expected output of the following application? Assume the directories referenced \nin the class do not exist prior to the execution and that the file system is available and able to \nbe written.\npackage job;\nimport java.nio.file.*;\npublic class Resume {\n   public void writeResume() throws Exception {\n      var f1 \u003d Path.of(\"/templates/proofs\");\n      f1.createDirectories();\n      var f2 \u003d Path.of(\"/templates\");\n      f2.createDirectory(); // k1\n      try(var w \u003d Files.newBufferedWriter(\n            Path.of(f2.toString(), \"draft.txt\"))) {\n         w.append(\"My dream job\");\n         w.flush();\n      }\n      f1.delete(f1);\n      f2.delete(f2);        // k2\n   }\n \n   public static void main(String... leads) {\n      try {\n         new Resume().writeResume();\n      } catch (Exception e) {\n         e.printStackTrace();\n      } } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "One line of this application does not compile.",
      "Two lines of this application do not compile.",
      "The code compiles, but line k1 triggers an exception at runtime.",
      "The code compiles, but line k2 triggers an exception at runtime.",
      "The code compiles and runs without printing an exception.",
      "None of the above."
    ],
    "explanation": "The code does not compile. There are no createDirectory(), createDirectories(), \nand delete() methods defined on the Path interface. Instead, the NIO.2 Files class should \nbe used. Since four lines of code do not compile, option F is the correct answer. If the lines were \ncorrected to use the Files class, then the application would print an exception at line k1, as the \ndirectory already exists."
  },
  {
    "number": 5,
    "chapter": 9,
    "question": "Which classes are least likely to be marked Serializable. (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [
      0,
      2
    ],
    "options": [
      "A class that monitors the state of every thread in the application",
      "A class that holds data about the amount of rain that has fallen in a given year",
      "A class that manages the memory of running processes in an application",
      "A class that stores information about apples in an orchard",
      "A class that tracks the amount of candy in a gumball machine",
      "A class that tracks which users have logged in"
    ],
    "explanation": "Generally speaking, classes should be marked with the Serializable interface if they\ncontain data that we might want to save and retrieve later. Options B, D, E, and F describe \nthe type of data that we would want to store over a long period of time. Options A and C, \nthough, define classes that manage transient or short-lived data. Application processes change \nquite frequently, and trying to reconstruct a process is often considered a bad idea."
  },
  {
    "number": 6,
    "chapter": 9,
    "question": "What is the output of the following code snippet? Assume that the current directory is the \nroot path.\nPath p1 \u003d Path.of(\"./found/../keys\");\nPath p2 \u003d Paths.get(\"/lost/blue.txt\");\nSystem.out.println(p1.resolve(p2));\nSystem.out.println(p2.resolve(p1));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "/lost/blue.txt and /lost/blue.txt/keys",
      "/found/../keys/./lost/blue.txt and /lost/blue.txt/keys",
      "/found/../keys/./lost/blue.txt and keys",
      "/lost/blue.txt and /lost/blue.txt/./found/../keys",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "First, p2 is an absolute path, which means that p1.resolve(p2) just returns p2. \nFor this reason, options B and C are incorrect. Since p1 is a relative path, it is appended  \nonto p2, making option D correct and option A incorrect. Option A would be correct if \nnormalize() was applied."
  },
  {
    "number": 7,
    "chapter": 9,
    "question": "Fill in the blanks: Writer is a(n) ______________ that related stream classes ______________.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "concrete class, extend",
      "abstract class, extend",
      "abstract class, implement",
      "interface, extend",
      "interface, implement",
      "None of the above"
    ],
    "explanation": "Writer is an abstract class, so options A, D, and E are incorrect. Classes extend abstract\nclasses; they do not implement them, making option B correct. Note that InputStream, \nOutputStream, and Reader are also abstract classes."
  },
  {
    "number": 8,
    "chapter": 9,
    "question": "Assuming /away/baseball.txt exists and is accessible, what is the expected result of \nexecuting the following code snippet?\nvar p1 \u003d Path.of(\"baseball.txt\");\nvar p2 \u003d Path.of(\"/home\");\nvar p3 \u003d Path.of(\"/away\");\nFiles.createDirectories(p2);\nFiles.copy(p3.resolve(p1),p2);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "A new file /home/baseball.txt is created.",
      "A new file /home/away/baseball.txt is created.",
      "The code does not compile.",
      "The code compiles, but an exception is printed at runtime.",
      "The output cannot be determined until runtime.",
      "None of the above."
    ],
    "explanation": "After calling createDirectories(), the directory /home is guaranteed to exist if it\ndoes not already. The second argument of the copy() command should be the location of \nthe new file, not the folder the new file is placed in. Therefore, the program attempts to  \nwrite the file to the path /home. Since there is already a directory at that location, a  \nFileAlreadyExistsException is thrown at runtime, making option D correct."
  },
  {
    "number": 9,
    "chapter": 9,
    "question": "Assuming the file referenced in the following snippet exists and contains five lines with the \nword eggs in them, what is the expected output?\nvar p \u003d Path.of(\"breakfast.menu\");\nFiles.readAllLines(p)\n   .filter(s -\u003e s.contains(\"eggs\"))\n   .collect(Collectors.toList())\n   .forEach(System.out::println);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "No lines will be printed.",
      "One line will be printed.",
      "Five lines will be printed.",
      "More than five lines will be printed.",
      "The code does not compile.",
      "None of the above."
    ],
    "explanation": "The code does not compile because readAllLines() returns a List\u003cString\u003e, not a\nstream, making option E the answer. If the correct method lines() was used instead, then \nfive lines would be printed at runtime."
  },
  {
    "number": 10,
    "chapter": 9,
    "question": "What is the output of the following program? Assume the file paths referenced in the class \nexist and are able to be written to and read from.\nimport java.io.*;\npublic class Vegetable implements Serializable {\n   private Integer size \u003d 1;\n   private transient String name \u003d \"Red\";\n   { size \u003d 3; name \u003d \"Purple\"; }\n   public Vegetable() { this.size \u003d 2; name \u003d \"Green\"; }\n   public static void main(String[] love) throws Throwable {\n      try (var o \u003d new ObjectOutputStream(\n            new FileOutputStream(\"healthy.txt\"))) {\n         final var v \u003d new Vegetable();\n         v.size \u003d 4;\n         o.writeObject(v);\n      }\n      \n      try (var o \u003d new ObjectInputStream(\n            new FileInputStream(\"healthy.txt\"))) {\n         var v \u003d (Vegetable) o.readObject();\n         System.out.print(v.size + \",\" + v.name);\n      } } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "1,Red",
      "2,Green",
      "2,null",
      "3,Purple",
      "4,null",
      "null,null"
    ],
    "explanation": "The size variable is properly serialized with a value of 4. Upon deserialization, none of\nthe class elements that assign a value to an instance variable are run, leading to size being \ndeserialized as 4 .  Since the name variable is marked transient, this value is deserialized as \nnull. For these reasons, option E is correct."
  },
  {
    "number": 11,
    "chapter": 9,
    "question": "Why does Console readPassword() return a char array rather than a String?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It improves performance.",
      "It improves security.",
      "Passwords must be stored as a char array.",
      "String cannot hold the individual password characters.",
      "It adds encryption.",
      "None of the above."
    ],
    "explanation": "The readPassword() returns a char array for security reasons. If the data was stored\nas a String, it would enter the shared JVM string pool, potentially allowing a malicious \nuser to access it, especially if there is a memory dump. By using a char array, the data can be \nimmediately cleared after it is written and removed from memory. For this reason, option B is \nthe correct answer."
  },
  {
    "number": 12,
    "chapter": 9,
    "question": "Given the following class inheritance diagram, which two classes can be placed in the \nblank boxes?\n",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "BufferedOutputStream and PrintStream",
      "BufferedOutputStream and PrintOutputStream",
      "ByteArrayOutputStream and Stream",
      "FileOutputStream and OutputStream",
      "ObjectOutputStream and PrintOutputStream",
      "None of the above"
    ],
    "explanation": "While you might not be familiar with FilterOutputStream, the diagram shows that\nthe two classes must inherit from OutputStream. Options B, C, and E can be eliminated as \nchoices since PrintOutputStream and Stream are not the name of any java.io classes. \nOption D can also be eliminated because OutputStream is already in the diagram, and you \ncannot have a circular class dependency. That leaves us with the correct answer, option A, \nwith BufferedOutputStream and PrintStream both extend FilterOutputStream. \nNote that ByteArrayOutputStream and FileOutputStream referenced in Options C \nand D, respectively, do not extend FilterOutputStream, although knowing this fact was \nnot required to solve the problem."
  },
  {
    "number": 13,
    "chapter": 9,
    "question": "How many lines of the following code contain compiler errors?\n12: var path \u003d Paths.get(new URI(\"ice.cool\"));\n13: var view \u003d Files.readAttributes(path, \n14:    BasicFileAttributes.class);\n15: Files.createDirectories(Path.relativize(\".backup\"));\n16: if(view.length() \u003e 0 \u0026\u0026 view.isDirectory())\n17:    view.setTimes(null,null,null);\n18: System.out.println(Files.deleteIfExists(path));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "All of the lines compile",
      "One",
      "Two",
      "Three",
      "Four or more"
    ],
    "explanation": "Line 15 is the first line to not compile, as relativize() is an instance method, not a\nstatic method. Line 16 also does not compile, as size(), not length(), should be used \nto retrieve a file size. Finally, line 17 does not compile because view is an attribute class, not  \nan attribute view. For line 17 to compile, line 13–14 would have to use  \nFiles.getFileAttributeView() with BasicFileAttributeView.class as the \nclass. The rest of the lines do not contain any compiler errors, making option D correct."
  },
  {
    "number": 14,
    "chapter": 9,
    "question": "What is the output of the following application?\nimport java.io.*;\npublic class TaffyFactory {\n   public int getPrize(byte[] luck) throws Exception {\n      try (InputStream is \u003d new ByteArrayInputStream(luck)) {\n         is.read(new byte[2]);\n         if (!is.markSupported()) return -1;\n         is.mark(5);\n         is.read(); is.read();\n         is.skip(3);\n         is.reset();\n         return is.read();\n      }\n   }\n   public static void main(String[] x) throws Exception {\n      final TaffyFactory p \u003d new TaffyFactory();\n      final var luck \u003d new byte[] { 1, 2, 3, 4, 5, 6, 7 };\n      System.out.print(p.getPrize(luck));\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "-2",
      "2",
      "3",
      "5",
      "7",
      "An exception is thrown at runtime."
    ],
    "explanation": "The code compiles and runs without issue. The first two values of the \nByteArray InputStream are read. Next, the markSupported() value is tested. Since -1 \nis not one of the possible options, we assume that ByteArrayInputStream does support\nmarks. Two values are read and three are skipped, but then reset() is called, putting the \nstream back in the state before mark() was called. In other words, everything between mark() \nand reset() can be ignored. The last value read is 3, making option C the correct answer."
  },
  {
    "number": 15,
    "chapter": 9,
    "question": "What is the output of the following program? Assume the file paths referenced in the class \nexist and are able to be written to and read from.\npackage heart;\nimport java.io.*;\npublic class Valve implements Serializable {\n   private int chambers \u003d -1;\n   private transient Double size \u003d null;\n   private static String color;\n   public Valve() {\n      this.chambers \u003d 3;\n      color \u003d \"BLUE\";\n   }\n   public static void main(String[] love) throws Throwable {\n      try (var o \u003d new ObjectOutputStream(\n            new FileOutputStream(\"scan.txt\"))) {\n         final Valve v \u003d new Valve();\n         v.chambers \u003d 2;\n         v.size \u003d 10.0;\n         v.color \u003d \"RED\";\n         o.writeObject(v);\n      }\n      new Valve();\n      try (var o \u003d new ObjectInputStream(\n            new FileInputStream(\"scan.txt\"))) {\n         Valve v \u003d (Valve)o.readObject();\n         System.out.print(v.chambers+\",\"+v.size+\",\"+v.color);\n      }\n   }\n   { chambers \u003d 4; }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "2,null,RED",
      "2,null,BLUE",
      "3,10.0,RED",
      "3,10.0,BLUE",
      "0,null,null",
      "None of the above"
    ],
    "explanation": "The class compiles and runs without issue, so option F is incorrect. The class defines three\nvariables, only one of which is serializable. The first variable, chambers, is serializable, \nwith the value 2 being written to disk and then read from disk. Note that constructors and \ninstance initializers are not executed when a class is deserialized. The next variable, size, \nis transient. It is discarded when it is written to disk, so it has the default object value of \nnull when read from disk. Finally, the variable color is static, which means it is shared \nby all instances of the class. Even though the value was RED when the instance was serialized, \nthis value was not written to disk, since it was not part of the instance. The constructor call \nnew Valve() between the two try-with-resources blocks sets this value to BLUE, which is \nthe value printed later in the application. For these reasons, the class prints 2,null,BLUE, \nmaking option B the correct answer."
  },
  {
    "number": 16,
    "chapter": 9,
    "question": "Given the following file system diagram, in which forward is a symbolic link to the java \ndirectory, which values if inserted into the following code do not print /java/Sort.java \nat runtime? (Choose two.)\nPath p \u003d Path.of(\"/\", \"objC\", \"bin\");\nSystem.out.print(p.resolve(\" \").toRealPath());",
    "answered": true,
    "correct": false,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "objC/forward/Sort.java",
      "../backwards/../forward/Sort.java",
      "../forward/./Sort.java",
      "../java/./forward/Sort.java",
      "../../java/Sort.java",
      ".././forward/Sort.java"
    ],
    "explanation": "Simplifying the path symbols, options B, C, and F become \n/objC/forward/Sort.java, which applying the symbol link becomes  \n/java/Sort.java. Option E just becomes /java/Sort.java, without any path  \nsymbols involved. Option A is correct, as the resolve() method concatenates the path to \nbe /objC/bin/objC/forward/Sort.java. Option D is also correct, as the simplified \npath is /objC/java/forward/Sort.java. In both of these cases, the symbolic link  \n/objC/forward cannot be applied."
  },
  {
    "number": 17,
    "chapter": 9,
    "question": "Which method defined in Reader can be used in place of calling skip(1)?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "jump()",
      "mark()",
      "markSupported()",
      "read()",
      "reset()",
      "None of the above"
    ],
    "explanation": "The skip(1) method just reads a single byte and discards the value. The read() method\ncan be used for a similar purpose, making option D the correct answer. Option A is incorrect \nbecause there is no jump() method defined in Reader. Options B, C, and E are incorrect \nbecause they cannot be used to skip data, only to mark a location and return to it later."
  },
  {
    "number": 18,
    "chapter": 9,
    "question": "The Rose application is run with an input argument of /flower. The /flower directory \ncontains five subdirectories, each of which contains five files. What is the result of executing \nthe following program?\nimport java.nio.file.*;\npublic class Rose {\n   public void tendGarden(Path p) throws Exception {\n      Files.walk(p,1)\n         .map(q -\u003e q.toRealPath())\n         .forEach(System.out::println);\n   }\n   public static void main(String... thorns) throws Exception {\n      new Rose().tendGarden(Paths.get(thorns[0]));\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "The program completes without outputting anything.",
      "One Path value is printed.",
      "Six Path values are printed.",
      "Twenty-five Path values are printed.",
      "Twenty-six Path values are printed.",
      "None of the above."
    ],
    "explanation": "Trick question! The code does not compile; therefore, option F is correct. The \ntoRealPath() interacts with the file system, and therefore throws a checked  \nIOException. Since this checked exception is not handled inside the lambda expression, \nthe class does not compile. If the lambda expression was fixed to handle the IOException, \nthen the expected number of Path values printed would be six, and option C would be the \ncorrect answer. A maxDepth value of 1 causes the walk() method to visit two total levels, \nthe original /flower, and the files it contains."
  },
  {
    "number": 19,
    "chapter": 9,
    "question": "What may be the result of executing the following program?\npackage test;\nimport java.io.*;\npublic class Turing {\n   public static void main(String... robots) {\n      Console c \u003d System.console();\n      final String response \u003d c.readLine(\"Are you human?\");\n      System.err.print(response);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The program asks the user a question and prints the results to the error stream.",
      "The program throws a NullPointerException at runtime.",
      "The program does not terminate.",
      "All of the above.",
      "The class does not compile."
    ],
    "explanation": "The statements in options A, B, and C are each correct, making option D correct. If\nSystem.console() is available, then the program will ask the user a question and then \nprint the response to the error stream. On the other hand, if System.console() is not \navailable, then the program will exit with a NullPointerException. It is strongly recom-\nmended to always check whether System.console() is null after requesting it. Finally, \nthe user may choose not to respond to the program’s request for input, resulting in the \nprogram hanging indefinitely."
  },
  {
    "number": 20,
    "chapter": 9,
    "question": "What is the output of the following method applied to an InputStream that contains the first \nfour prime numbers, stored as bytes: 2, 3, 5, 7?\nprivate void jumpAround(InputStream is) throws IOException {\n   try (is) {\n      is.skip(1);\n      is.read();\n      is.skip(1);\n      is.mark(4);\n      is.skip(1);\n      is.reset();\n      System.out.print(is.read());\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "5",
      "7",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime.",
      "The result cannot be determined until runtime.",
      "None of the above."
    ],
    "explanation": "The code compiles, so option C is incorrect. Not all InputStream classes support the\nmark() operation. If mark() is supported, then 7 is printed at runtime. Alternatively, if \nmark() is not supported, then an IOException will be printed at runtime. For this reason, \noption E is correct. Always remember to call markSupported() before using a mark() \noperation on an InputStream."
  },
  {
    "number": 21,
    "chapter": 9,
    "question": "Which statement about the following method is correct? Assume the directory /tea/ \nearlGrey/hot exists and is able to be read.\nvoid order() throws Exception {\n   var s \u003d Path.of(\"/tea\",\"earlGrey\",\"hot\");\n   Files.find(s, (p,a) -\u003e a.isDirectory());\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It does not compile.",
      "It compiles but does not print anything at runtime.",
      "It compiles and prints true exactly once at runtime.",
      "It compiles and prints true at least once.",
      "The answer cannot be determined without knowing the contents of the directory.",
      "None of the above."
    ],
    "explanation": "The Files.find() method requires a maxDepth value as the second parameter. \nSince this parameter is missing, the method does not compile, and option A is correct. If a \nmaxDepth parameter was added, then the method would compile but not print anything at \nruntime since the stream does not include a terminal operation."
  },
  {
    "number": 22,
    "chapter": 9,
    "question": "Which method are classes that implement java.io.Serializable required to \nimplement?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "cereal()",
      "deserialize()",
      "serial()",
      "serialize()",
      "clone()",
      "None of the above"
    ],
    "explanation": "Serializable is a marker interface, which means it does not contain any abstract\nmethods that require implementation, making option F correct. The interface is only meant \nto indicate the object is capable of serialization."
  },
  {
    "number": 23,
    "chapter": 9,
    "question": "What is the result of compiling and executing the following program? Assume the current \ndirectory is /stock and the path /stock/sneakers does not exist prior to execution.\npackage shoe;\nimport java.io.*;\nimport java.nio.file.*;\npublic class Sneaker {\n   public void setupInventory(Path d) throws Exception {\n      Path suggestedPath \u003d Paths.get(\"sneakers\");\n      if(Files.isSameFile(suggestedPath, d)           // j1\n            \u0026\u0026 !Files.exists(suggestedPath))\n         Files.createDirectories(d);                  // j2\n   }\n   public static void main(String[] socks) throws Exception {\n      Path w \u003d new File(\"/stock/sneakers\").toPath();  // j3\n      new Sneaker().setupInventory(w);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The directory /stock/sneakers is created.",
      "Line j1 does not compile or produces an exception at runtime.",
      "Line j2 does not compile or produces an exception at runtime.",
      "Line j3 does not compile or produces an exception at runtime.",
      "None of the above."
    ],
    "explanation": "First, the class compiles without issue. It is not without problems, though. The \nFiles.isSameFile() method call on line j1 first checks if the Path values are \nequivalent in terms of equals(). One is absolute, and the other is relative, so this test will \nfail. The isSameFile() method then moves on to verify that the two Path values reference \nthe same file system object. Since we know the directory does not exist, the call to  \nisSameFile() on line j1 will produce a NoSuchFileException at runtime, making \noption B the correct answer. "
  },
  {
    "number": 24,
    "chapter": 9,
    "question": "Assuming the absolute path referenced in the code exists and its contents are accessible, \nwhich statement about the following code snippet is correct?\nPath p \u003d Paths.get(\"/glasses/lens\");\n \nFiles.walk(p)\n   .map(z -\u003e z.toAbsolutePath().toString())\n   .filter(s -\u003e s.endsWith(\".java\"))\n   .collect(Collectors.toList()).forEach(System.out::println);\nFiles.find(p,Integer.MAX_VALUE,\n      (w,a) -\u003e w.toAbsolutePath().toString().endsWith(\".java\"))\n   .collect(Collectors.toList()).forEach(System.out::println);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "The first stream statement does not compile.",
      "The second stream statement does not compile.",
      "Neither statement compiles.",
      "Both statements compile and produce the same result at runtime.",
      "None of the above."
    ],
    "explanation": "Both stream statements compile without issue, making options A, B, and C incorrect.\nThe two statements are equivalent to one another and print the same values at runtime. For \nthis reason, option D is correct. There are some subtle differences between the two methods \ncalls. The walk() call does not include a depth limit, but since Integer.MAX_VALUE is \nthe default value, the two calls are equivalent. Furthermore, the walk() statement prints \na stream of absolute paths stored as String values, while the find() statement prints a \nstream of Path values. If the input p was a relative path, then these two calls would have \nvery different results, but since we are told p is an absolute path, the application of  \ntoAbsolutePath() does not change the results."
  },
  {
    "number": 25,
    "chapter": 9,
    "question": "When reading file information, what is an advantage of using an NIO.2 attribute interface \nrather than reading the values individually using Files methods? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4
    ],
    "userAnswers": [
      1,
      2
    ],
    "options": [
      "Costs fewer round-trips to the file system",
      "Guarantees performance improvement",
      "Has support for symbolic links",
      "Reduces memory leaks",
      "Supports file-system dependent attributes",
      "Reduces resource leaks"
    ],
    "explanation": "An attribute view has the advantage of reading all of the file information on a single\ntrip, rather than multiple trips to the file system making option A correct. Option B is incor-\nrect because nothing guarantees it will perform faster, especially if the Files method is only \nbeing used to read a single attribute. Option C is also incorrect because both sets of methods \nhave built-in support for symbolic links. Options D and F are incorrect because memory and \nresource leaks are not related to reading file attribute views. Finally, option E is correct, as \nNIO.2 supports file-system dependent attribute view classes."
  },
  {
    "number": 26,
    "chapter": 9,
    "question": "Suppose that you need to read data that consists of serialized int, double, boolean, \nand String values from a file. You also want the program to be performant on large files. \nWhich three java.io stream classes can be chained together to best achieve this result? \n(Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      5
    ],
    "userAnswers": [
      2,
      3,
      5
    ],
    "options": [
      "BufferedInputStream",
      "FileReader",
      "ObjectInputStream",
      "BufferedReader",
      "BufferedStream",
      "FileInputStream"
    ],
    "explanation": "Since you need to read primitives and String values, the InputStream classes are\nappropriate. Therefore, you can eliminate options B and D since they use Reader classes. \nOption E is incorrect, as this is not a java.io class. The data should be read from the file \nusing an FileInputStream class, buffered with a BufferedInputStream class for \nperformance, and deserialized into Java-accessible data types with an ObjectInputStream \nclass, making options A, C, and F correct."
  },
  {
    "number": 27,
    "chapter": 9,
    "question": "Which statement about the following method is correct? Assume the directory coffee exists \nand is able to be read.\nvoid brew() throws Exception {\n   final var m \u003d Path.of(\"coffee\");\n   Files.walk(m)\n      .filter(Files::isDirectory)\n      .forEach(Files::isDirectory);\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It does not compile.",
      "It compiles but does not print anything at runtime.",
      "It compiles and prints true exactly once at runtime.",
      "It compiles and prints true at least once.",
      "The answer cannot be determined without knowing the contents of the directory.",
      "None of the above."
    ],
    "explanation": "The method compiles, so option A is incorrect. The method reads all of the elements of\na directory tree, keeping only directories. The forEach() method does not print anything, \nthough, making option B correct. If the lambda in the forEach() method was modified to \nprint something, such as s -\u003e System.out.println(Files.isDirectory(s)), then \nit would print true at least once for the coffee directory. It would then print true for each \ndirectory within the directory tree."
  },
  {
    "number": 28,
    "chapter": 9,
    "question": "Assuming the file referenced in the StudentManager class exists and contains data, which \nstatement about the following class is correct? (Choose two.)\npackage school;\nimport java.io.*;\nclass Student implements Serializable {\n   transient int score \u003d -1;\n   String name;\n   public String toString() { return name + \":\" + score; }\n}\npublic class StudentManager {\n   public static void main(String[] grades) {\n      try(var ios \u003d new ObjectInputStream(\n            new FileInputStream(new File(\"s.data\")))) {\n         Student record;\n         while((record \u003d (Student)ios.readObject()) !\u003d null)\n            System.out.print(record);\n      } catch (EOFException e) {\n      } catch (Exception e) {\n         throw new RuntimeException(e);\n      }\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3,
      5
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "The code does not compile.",
      "The code compiles but prints an exception at runtime.",
      "The program runs and prints all students in the file.",
      "The program runs but may only print some students in the files.",
      "For any instance of Student that is correctly deserialized, the value of score will be -1.",
      "For any instance of Student that is correctly deserialized, the value of score will not be "
    ],
    "explanation": "The code compiles and runs without issue, so options A and B are incorrect. The\nproblem with the implementation is that checking if ios.readObject() is null is not the \nrecommended way of iterating over an entire file. For example, the file could have been writ-\nten with writeObject(null) in between two non-null records. In this case, the reading \nof the file would stop on this null value, before the end of the file has been reached. For this \nreason, option D is the correct answer. Note that the valid way to iterate over all elements  \nof a file using ObjectInputStream is to continue to call readObject() until an  \nEOFException is thrown. Finally, score is marked transient, which means the default \nint value of 0 will be set when the class is deserialized, making option F correct."
  },
  {
    "number": 29,
    "chapter": 9,
    "question": "Given an instance of Console c, which of the following two method calls are invalid ways \nof retrieving input from the user? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [
      1,
      2
    ],
    "options": [
      "c.read()",
      "c.reader().read()",
      "c.reader().readLine()",
      "c.readLine()",
      "c.readPassword()"
    ],
    "explanation": "The Console class contains readLine() and readPassword() methods, but not\na read() method, making option A one of the correct answers, and options D and E incor-\nrect. It also contains a reader() method that returns a Reader object. The Reader class \ndefines a read() method, but not a readLine() method. For this reason, option C is the \nother correct answer, and option B is incorrect. Recall that a BufferedReader is required \nto call the readLine() method."
  },
  {
    "number": 30,
    "chapter": 9,
    "question": "What is the output of the following code snippet? Assume that the current directory is the \nroot path /.\nPath p1 \u003d Paths.get(\"./locks\");\nPath p2 \u003d Paths.get(\"/found/red.zip\");\nSystem.out.println(p1.relativize(p2));\nSystem.out.println(p2.relativize(p1));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "../found/red.zip and ../../locks",
      "/found/red.zip and /found/red.zip/./locks",
      "locks/../found/red.zip and ../found/locks",
      "../../locks and ../found/red.zip",
      "/found/red.zip and /found/red.zip/locks",
      "None of the above"
    ],
    "explanation": "The relativize() method requires that both path values be absolute or relative. Based\non the details provided, p1 is a relative path, while p2 is an absolute path. For this reason, \nthe code snippet produces an exception at runtime, making option F the correct answer. If the \nfirst path was modified to be absolute by dropping the leading dot (.) in the path expression, \nthen the output would match the values in option A ."
  },
  {
    "number": 31,
    "chapter": 9,
    "question": "Assuming the current working directory is /home, then what is the output of the follow-\ning program?\n1:  package magic;\n2:  import java.nio.file.*;\n3:  public class Magician {\n4:     public String doTrick(Path path) {\n5:        return path.subpath(2,3)\n6:           .getName(1)\n7:           .toAbsolutePath()\n8:           .toString();\n9:     }\n10:    public static void main(String... cards) {\n11:       final Magician m \u003d new Magician();\n12:       System.out.print(m.doTrick(\n13:          Paths.get(\"/bag/of/tricks/.././disappear.txt\")));\n14:    } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "/home/tricks",
      "/home",
      "tricks",
      "The code does not compile.",
      "The code compiles but prints an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The code compiles without issue. Even though tricks would be dropped in the \nnormalized path /bag/of/disappear.txt, there is no normalize() call, so  \npath.subpath(2,3) returns tricks on line 5 .  On line 6, the call to getName() throws \nan IllegalArgumentException at runtime. Since getName() is zero-indexed and con-\ntains only one element, the call on line 6 throws an IllegalArgumentException, mak-\ning option E the correct answer. If getName(0) had been used instead of getName(1), \nthen the program would run without issue and print /home/tricks."
  },
  {
    "number": 32,
    "chapter": 9,
    "question": "Which statements about the Files methods lines() and readAllLines() are correct? \n(Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      5
    ],
    "userAnswers": [
      3,
      4
    ],
    "options": [
      "They have different return types.",
      "The readAllLines() method is always faster.",
      "The lines() may require more memory.",
      "They have the same return type.",
      "The lines() method is always faster.",
      "The readAllLines() method may require more memory."
    ],
    "explanation": "The lines() method returns Stream\u003cString\u003e, while the readAllLines()\nmethod returns List\u003cString\u003e, making option A correct and option D incorrect. Neither \nmethod is guaranteed to be faster or slower than the other, making options B and E  \nincorrect. The lines() method lazily reads the file as the stream is processed, while the \nreadAllLines() method reads the entire file into memory at once. For this reason, the \nreadAllLines() method may require more memory to hold a large file, making option F \ncorrect and option C incorrect."
  },
  {
    "number": 33,
    "chapter": 9,
    "question": "Given the following application, in which a user enters bone twice, what is the \nexpected result?\nlong start \u003d System.currentTimeMillis();\nvar retriever \u003d new BufferedReader(new \n   InputStreamReader(System.in));\ntry(retriever; var husky \u003d System.err) {\n   var fetch \u003d retriever.readLine();\n   System.out.printf(\"%s fetched in %5.1f seconds\",fetch, // v1\n      (System.currentTimeMillis()-start)/1000.0);\n}\nvar fetchAgain \u003d retriever.readLine();\nSystem.out.println(fetchAgain + \" fetched again!\");",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "The program completes after printing a message once.",
      "The program completes after printing a message twice.",
      "An IOException is thrown.",
      "The program prints an exception because the format of the String on line v1 is invalid.",
      "A NullPointerException is thrown since System.in may be unavailable.",
      "None of the above as the code does not compile."
    ],
    "explanation": "First, the code compiles. The format of the String on line v1 is valid, making option D\nincorrect. While System.console() throws a NullPointerException if it is not avail-\nable, System.in does not, making option E incorrect.\nThe first part of the code runs without issue, printing a message such as  \nbone fetched in  1 .8 seconds. The I/O stream System.in is closed at the end of the \ntry-with-resources block. That means calling readLine() again results in an operation on a \nclosed stream, which would print an exception at runtime and make option C correct, except \nSystem.err is already closed due to the try-with-resources block! Therefore, only one mes-\nsage is printed, and option A is correct."
  },
  {
    "number": 34,
    "chapter": 9,
    "question": "What is the expected result of calling deleteTree() on a directory? Assume the directory \nexists and is able to be modified.\nimport java.nio.file.*;\npublic class Exterminate {\n   public void deleteTree(Path q) {\n      if (!Files.isDirectory(q))\n         Files.delete(q);\n      else {\n         Files.list(q).forEach(this::deleteTree);\n         Files.delete(q);\n      } } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It will delete the directory itself only.",
      "It will delete the directory and its file contents only.",
      "It will delete the entire directory tree.",
      "The code does not compile.",
      "The code compiles but produces an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The Files.delete() and Files.list() declare a checked IOException that must\nbe handled or declared. For this reason, the code does not compile, and option D is correct."
  },
  {
    "number": 35,
    "chapter": 9,
    "question": "Which code, if inserted into the method, will cause it to correctly copy any file passed to it \nthat is accessible? (Choose two.)\nvoid copyFile(String source, String target) throws Exception {\n   try (var is \u003d new FileInputStream(source);\n         OutputStream os \u003d new FileOutputStream(target)) {\n      byte[] data \u003d new byte[123];\n      int chirps;\n \n      // INSERT CODE HERE\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      4
    ],
    "options": [
      "while (is.read(data) \u003e 0)\n    os.write(data);",
      "while ((chirps \u003d is.read(data)) \u003e 0)\n    os.write(data, 0, chirps);;",
      "while ((chirps \u003d is.read(data)) \u003e 0)\n    os.write(data);",
      "String line;\nwhile (is.read(data) \u003e 0)\n    os.write(data);",
      "while ((line \u003d is.readLine()) !\u003d null)\n    os.write(line + \"\n\");",
      "while ((chirps \u003d is.read()) \u003e 0)\n    os.write(chirps);"
    ],
    "explanation": "All of the options compile except option E, since FileInputStream does not have\na readLine() method. A BufferedReader should be used instead. Options A and C \nsuffer from the same problem. If the file is not exactly a multiple of 123 bytes, then extra \ninformation will be written to the file from the end of the data array. Option D is incor-\nrect because the second argument should be an offset, and the third argument should be the \nnumber of bytes to read from the data array.\nOption B is correct and uses an array to read a fixed number of bytes and then writes that \nexact number of bytes to the output file. Option F is also correct, although it does not use an \narray. Instead, a single byte is read and written on each iteration of the loop."
  },
  {
    "number": 36,
    "chapter": 9,
    "question": "Let’s say we want to write an instance of Cereal to disk, having a name value of  \nCornLoops and sugar value of 5. What is the value of name and sugar after this object \nhas been read from disk using the ObjectInputStream’s readObject() method?\npackage breakfast;\nimport java.io.Serializable;\nclass Bowl {\n   boolean spoon \u003d true;\n   // Getters/Setters Omitted\n}\npublic class Cereal implements Serializable {\n   private String name \u003d \"CocoaCookies\";\n   private transient int sugar \u003d 10;\n   private Bowl bowl;\n   public Cereal() {\n      super();\n      this.name \u003d \"CaptainPebbles\";\n      this.bowl \u003d new Bowl();\n      sugar \u003d 2;\n   }\n   { name \u003d \"SugarPops\"; }\n   // Getters/Setters Omitted\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "CaptainPebbles and 10",
      "CornLoops and 0",
      "SugarPops and 10",
      "SugarPops and 2",
      "CornLoops and -1",
      "None of the above"
    ],
    "explanation": "The Bowl class does not implement the Serializable interface; therefore, attempting\nto write the instance to disk, or calling readObject() using ObjectInputStream, will \nresult in a NotSerializableException at runtime. Remember, all instance members of \na class must be serializable or marked transient for the class to properly implement the \nSerializable interface and be used with Java serialization. For this reason, option F is the \ncorrect answer. If the Bowl class did implement Serializable, then the value of name and \nsugar would be CornLoops and 0, respectively, since none of the constructors, initializers, \nor setters methods are used on deserialization, making option B the correct answer."
  },
  {
    "number": 37,
    "chapter": 9,
    "question": "What is the output of the following code snippet?\n11: var halleysComet \u003d Path.of(\"stars/./rocks/../m1.meteor\")\n12:    .subpath(1, 5).normalize();\n13:\n14: var lexellsComet \u003d Paths.get(\"./stars/../solar/\");\n15: lexellsComet.subpath(1, 3)\n16:    .resolve(\"m1.meteor\").normalize();\n17:\n18: System.out.print(halleysComet.equals(lexellsComet) ? \n19:    \"Same!\" : \"Different!\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Same!",
      "Different!",
      "The code does not compile.",
      "The class compiles but throws an exception at runtime.",
      "None of the above."
    ],
    "explanation": "The program compiles and runs without issue, making options C and D incorrect. The\nfirst variable, halleysComet, is created with subpath(1,5) and normalize() being \napplied right away, leading to halleysComet being assigned a value of   m1 .meteor. The \nsecond variable, lexellsComet is assigned a value on line 14, but lines 15–16 do not \ninclude an assignment operation. Since Path instances are immutable, the changes are lost. \nFor this reason, the two objects are not equivalent on lines 18–19, and option B is correct. If \nlexellsComet was assigned the value created on line 15–16, though, then the path value \nof lexellsComet would be   m1 .meteor and option A would be correct."
  },
  {
    "number": 38,
    "chapter": 9,
    "question": "During deserialization from an I/O stream, which element of the class can be used to assign a \nvalue to the deserialized object?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Variable initializer",
      "Instance initializer",
      "Static initializer",
      "Constructor",
      "The restoreObject() method",
      "None of the above"
    ],
    "explanation": "When data is deserialized, none of variable initializers, instance initializers, or constructors\nis called. The class can have static initializers, but they are not called as part of deserializa-\ntion. Finally, there is no restoreObject() method that is used in standard deserialization. \nFor these reasons, option F is correct."
  },
  {
    "number": 39,
    "chapter": 9,
    "question": "Assuming there are no symbolic links involved and file /nursery/sapling.seed exists, \nwhich statements about the following code snippet are correct? (Choose three.)\nFiles.move(\n   Paths.get(\"/nursery/sapling.seed\"),\n   Paths.get(\"/forest\"),\n   StandardCopyOption.ATOMIC_MOVE);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      4
    ],
    "userAnswers": [
      0,
      3,
      4
    ],
    "options": [
      "The code may throw an exception at runtime.",
      "The code may complete without throwing an exception at runtime.",
      "After it runs, the new location of the file would be /nursery/sapling.seed",
      "After it runs, the new location of the file would be /forest/sapling.seed",
      "If a process is monitoring the move, it will not see an incomplete file.",
      "If a process is monitoring the move, it could see an incomplete file."
    ],
    "explanation": "The code moves a file from /nursery/sapling.seed to the new location of \n/forest, not /forest/sapling.seed. For this reason, options C and D are both incor-\nrect. If there is no file or directory at /forest, then the program completes successfully.  \nIf a file already exists at that location, then an exception is thrown since the  \nREPLACE_EXISTING flag is not set. For these reasons, options A and B are both correct. \nSince the ATOMIC_MOVE flag is set, option E is correct, and option F is incorrect."
  },
  {
    "number": 40,
    "chapter": 9,
    "question": "What is the output of the following application? Assume /all-data exists and is accessible \nwithin the file system.\n1:  package sesame;\n2:  import java.nio.file.*;\n3:  import java.util.stream.*;\n4:  public class TheCount {\n5:     public static Stream\u003cString\u003e readLines(Path p) {\n6:        try { return Files.lines(p); } catch (Exception e) {\n7:           throw new RuntimeException(e);\n8:        }\n9:     }\n10:    public static long count(Path p) throws Exception {\n11:       return Files.list(p)\n12:             .filter(w -\u003e Files.isRegularFile(w))\n13:             .flatMap(s -\u003e readLines(s))\n14:             .count();\n15:    }\n16:    public static void main(String[] d) throws Exception {\n17:       System.out.print(count(Paths.get(\"/all-data\")));\n18:    } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "The code does not compile.",
      "The number of lines in all files in a directory tree.",
      "The number of lines in all files in a single directory.",
      "The code hangs indefinitely at runtime.",
      "An exception is printed at runtime.",
      "None of the above."
    ],
    "explanation": "The program compiles and runs without issue, making options A, D, and E incorrect. \nThe program uses Files.list() to iterate over all files within a single directory.  \nFor each file, it then iterates over the lines of the file and sums them. For this reason, option \nC is the correct answer. If the count() method had used Files.walk() instead of  \nFiles.lines(), then the class would still compile and run, and option B would be the \ncorrect answer. Note that we had to wrap Files.lines() in a try/catch block, because \nusing this method directly within a lambda expression without one leads to a compila-\ntion error."
  },
  {
    "number": 1,
    "chapter": 10,
    "question": "Which statement best describes this class?\nimport java.util.*;\npublic final class Forest {\n   private final int flora;\n   private final List\u003cString\u003e fauna;\n \n   public Forest() {\n      this.flora \u003d 5;\n      this.fauna \u003d new ArrayList\u003c\u003e();\n   }\n   \n   public int getFlora() {\n      return flora;\n   }\n   public List\u003cString\u003e getFauna() {\n      return fauna;\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It can be serialized.",
      "It is well encapsulated.",
      "It is immutable.",
      "It is both well encapsulated and immutable.",
      "None of the above as the code does not compile."
    ],
    "explanation": "This class does not implement Serializable, so option A is incorrect. This code is well\nencapsulated because the instance variables are private. While the instance variable refer-\nences do not change after the object is created, the contents fauna can be modified, so it is \nnot immutable. For these reasons, option B is correct."
  },
  {
    "number": 2,
    "chapter": 10,
    "question": "Fill in the blanks: The ___________ class variable defines a whitelist of fields that should be \nserialized, while the ___________ modifier is used to construct a blacklist of fields that should \nnot be serialized. (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "serialVersionUID in the first blank",
      "serialFields in the first blank",
      "serialPersistentFields in the first blank",
      "ignore in the second blank",
      "transient in the second blank",
      "skip in the second blank"
    ],
    "explanation": "Options B, D, and F are not supported options in Java. The serialVersionUID class\nvariable can be used in serialization, but it relates to the version of the class stored, not the \nchoice in fields serialized, making option A incorrect. That leaves options C and E as the \ncorrect answers. The serialPersistentFields class variable defines a whitelist of fields \nto serialize, while the transient modifier constructs a blacklist of fields to skip."
  },
  {
    "number": 3,
    "chapter": 10,
    "question": "Which statement best describes the following method?\npublic String findNewLego(String url, String type) \n      throws SQLException {\n   var query \u003d \"SELECT name FROM sets WHERE \"\n      + \"type \u003d \" + type + \" ORDER BY date DESC\";\n   var con \u003d DriverManager.getConnection(url);\n   try(con; \n      var ps \u003d con.createStatement(); \n      var rs \u003d ps.executeQuery(query)) {\n \n      if(rs.next()) return rs.getString(1);\n   }\n   throw new RuntimeException(\"None available, try  later\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It is not susceptible to any common attacks.",
      "It is at risk of SQL injection attack only.",
      "It is at risk of a denial of service attack only.",
      "It is at risk of both SQL injection and denial of service attacks.",
      "The method does not compile.",
      "None of the above."
    ],
    "explanation": "The method compiles, so option E is incorrect. It is recommended to use a \nPreparedStatement with bind variables, over a Statement, to avoid SQL injection. \nSince the data type of the variable is String, it needs to be escaped making this method at \nrisk for SQL injection.\nFurther, there is no risk of a resource leak that could be exploited in a denial of service \nattack. The Connection object is declared immediately before the try-with-resources block \nand closed by it, so it cannot be left open. For these reasons, option B is correct."
  },
  {
    "number": 4,
    "chapter": 10,
    "question": "Fill in the blanks: ____________ means the state of an object cannot be changed, while \n_____________ means that it can.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Encapsulation, factory method",
      "Immutability, mutability",
      "Rigidity, flexibility",
      "Static, instance",
      "Tightly coupled, loosely coupled",
      "None of the above"
    ],
    "explanation": "Option B is correct because mutability means the state can change, and immutability\nmeans it cannot. The other options are invalid. In option C, rigidity is not a common \nprogramming term."
  },
  {
    "number": 5,
    "chapter": 10,
    "question": "Which of the following best protect against denial of service attacks? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3,
      4
    ],
    "userAnswers": [
      2,
      3,
      4
    ],
    "options": [
      "Close resources with catch blocks.",
      "Use PreparedStatement instead of Statement.",
      "Close resources with try-with-resources statements.",
      "Set a limit of the size of a file upload.",
      "Set a limit on the size of a numeric input value.",
      "Use immutable objects."
    ],
    "explanation": "A denial of service attack is about overloading the system with too much data or too\nmany requests to process legitimate incoming requests. Option A is incorrect, and option C \nis correct because a try-with-resources or finally block should be used to close resources \nto prevent a resource leak. Option B is incorrect because SQL injection is a form of injection \nattack, not one based on volume or resources. Option D is correct because a malicious attack could\nsend a lot of bad requests with huge files. Option E is also correct as numeric overflow can be \nused to overwhelm a system. Option F is incorrect because immutability does not usually play a part \nin DoS attacks."
  },
  {
    "number": 6,
    "chapter": 10,
    "question": "You ask to borrow one of your friend’s recipe cards. Which statements about these cards, \nrepresented as Java policy file grants, are correct? (Choose two.)\ngrant {\n   permission java.io.FilePermission \n      \"/dessert/icecream/rockyroad.yum\", \"read,write\";\n   permission java.io.FilePermission\n      \"/dessert/icecream/mintchip.yum\", \"read\";\n};",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "The policy syntax of the policy file is correct.",
      "The policy syntax of the policy file is incorrect.",
      "The policy is incorrect because read should not be included in the first permission.",
      "The policy is incorrect because write should not be included in the first permission.",
      "The policy is incorrect because read should not be included in the second permission.",
      "The policy is incorrect because file permissions cannot be granted this way."
    ],
    "explanation": "The policy compiles and uses correct syntax, making option A correct. However, it gives\npermissions that are too broad. The user needs to be able to read a recipe, so write permis-\nsions should not be granted, making option D also correct."
  },
  {
    "number": 7,
    "chapter": 10,
    "question": "Which of the following best protect against inclusion attacks? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      5
    ],
    "userAnswers": [
      2,
      5
    ],
    "options": [
      "Encrypt user passwords.",
      "Use immutable objects.",
      "Limit the recursive depth of ZIP files.",
      "Apply a blacklist to the input data.",
      "Turn the computer off when not in use.",
      "Restrict the number of parse levels of XML files."
    ],
    "explanation": "Inclusion attacks occur when multiple files or components are embedded within a single\nentity, such as a zip bomb or the billion laughs attack. Both can be thwarted with depth limits, \nmaking option C and F correct. The rest of the options are not related to inclusion attacks."
  },
  {
    "number": 8,
    "chapter": 10,
    "question": "What changes, taken together, would make the Tree class immutable? (Choose three.)\n1:  public class Tree {\n2:     String species;\n3:     public Tree(String species) {\n4:        this.species \u003d species;\n5:     }\n6:     public String getSpecies() {\n7:        return species;\n8:     }\n9:     private final void setSpecies(String newSpecies) {\n10:       species \u003d newSpecies;\n11:    }\n12: }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      4
    ],
    "userAnswers": [
      1,
      3,
      4
    ],
    "options": [
      "Make all constructors private.",
      "Change the access level of species to private.",
      "Change the access level of species to protected.",
      "Remove the setSpecies() method.",
      "Mark the Tree class final.",
      "Make a defensive copy of species in the Tree constructor."
    ],
    "explanation": "Immutable objects are ones that are not modified after they are created. Immutable\nobjects can have public constructors. There is no need to change the access modifier to\nprivate, making option A incorrect. All instance variables should be private in an immu-\ntable class to prevent subclasses and classes within the package from modifying them outside \nthe class, making option B correct and option C incorrect. They should not have any setter \nmethods, making option D correct. The class should also either be marked final or con-\ntain final methods to prevent subclasses from altering the behavior of the class, making \noption E correct. Finally, option F is incorrect as String is immutable, so a defensive copy is \nnot required. Note that if species were a mutable type, like List, a defensive copy would \nbe required."
  },
  {
    "number": 9,
    "chapter": 10,
    "question": "Which techniques best prevent sensitive objects from being manipulated by an attacker who \nwants to create a malicious subclass? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2,
      5
    ],
    "userAnswers": [
      0,
      2,
      3
    ],
    "options": [
      "Add final to the class declaration.",
      "Set protected as the access level for all method declarations.",
      "Add final to all method declarations.",
      "Add final to all instance variable declarations.",
      "Add final to all constructors.",
      "Set private as the access level for all constructors."
    ],
    "explanation": "The best way to protect a sensitive class is to prevent the class from being extended or\nprevent any of its methods from being overridden. Options A and C accomplish this. Option \nF also is appropriate. By marking all constructors private, only static methods that the \nclass controls can be used to obtain instances of the object. Options B and D are incorrect \nbecause they do not prevent methods from being overridden that could change the behavior \nof the class. Option E is incorrect because constructors cannot be marked final."
  },
  {
    "number": 10,
    "chapter": 10,
    "question": "Which statement best describes the following method?\npublic String findNewLego(String url, int type) \n      throws SQLException {\n   var query \u003d \"SELECT name FROM sets WHERE \"\n      + \"type \u003d \" + type + \" ORDER BY date DESC\";\n   var con \u003d DriverManager.getConnection(url);\n   var ps \u003d con.createStatement();\n   try(con; ps; var rs \u003d ps.executeQuery(query)) {\n      if(rs.next()) return rs.getString(1);\n   }\n   throw new RuntimeException(\"None available, try  later\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "It is not susceptible to any common attacks.",
      "It is at risk of SQL injection attack only.",
      "It is at risk of a denial of service attack only.",
      "It is at risk of both SQL injection and denial of service attacks.",
      "The method does not compile.",
      "None of the above."
    ],
    "explanation": "The class compiles, so option E is incorrect. It is recommended to use a \nPreparedStatement over a Statement to avoid SQL injection although it is not strictly \nnecessary. In this case, because the data type of the variable is int, Java already prevents a \nmalicious String from being entered into the query. Therefore, this method is not at risk for \nSQL injection, making option B incorrect.\nOn the other hand, the code is a risk of a resource leak that could be exploited in a denial \nof service attack. While the Connection object doesn’t need to be declared in the try-with-\nresources block, it should be declared right before it. In this case, there’s a line in between, \ncon.createStatement(), that could throw an exception, thereby preventing the  \nConnection from ever being closed. For these reasons, option C is correct."
  },
  {
    "number": 11,
    "chapter": 10,
    "question": "Which statements about executing the following program are correct? (Choose two.)\nimport java.security.*;\nimport java.util.*;\n \npublic class MagicTrick {\n   private static final String WORD \u003d \"abracadabra\";\n   private static List\u003cString\u003e trick \u003d new ArrayList\u003c\u003e();\n   public static List\u003cString\u003e castSpell(String magic) {\n      return AccessController.doPrivileged(\n            new PrivilegedAction\u003cList\u003cString\u003e\u003e() {\n         public List\u003cString\u003e run() {\n            if (magic.equalsIgnoreCase(WORD)) {         // p1\n               if(trick.isEmpty())\n                  trick.add(System.getProperty(magic)); // p2\n               return trick;                            // p3\n            }\n            throw new SecurityException(\"Incorrect code\");\n         }\n      });\n   }\n   public static void main(String[] args) {\n      if(args !\u003d null \u0026\u0026 args.length\u003e0)\n         System.out.print(MagicTrick.castSpell(args[0]));\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "Line p1 makes the code susceptible to tainted inputs from the user.",
      "Line p2 makes the code susceptible to tainted inputs from the user.",
      "Line p3 makes the code susceptible to tainted inputs from the user.",
      "The code is not susceptible to tainted inputs from the user.",
      "Line p1 exposes sensitive information.",
      "Line p3 exposes sensitive information."
    ],
    "explanation": "Line p1 only partially validates the input from the user, since it performs a case insensi\ntive match. Therefore, the code executed on line p2 could be any variant of the magic word \nsuch as Abracadabra, aBraCadAbra, abracaDABRA, etc. In this manner, the user has \naccess to many system properties to read from on line p2, making option B correct. The code \nalso does not protect its input because trick is returned to the user, who is free to modify \nthe List. Instead, an immutable collection should be returned on line p3, making option \nG correct."
  },
  {
    "number": 12,
    "chapter": 10,
    "question": "How do you change the value of an instance variable in an immutable class?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Call the setter method.",
      "Remove the final modifier and set the instance variable directly.",
      "Create a new instance with an inner class.",
      "Use a method other than Option A, B, or C.",
      "You can’t."
    ],
    "explanation": "By definition, you cannot change the value of an instance variable in an immutable class.\nThere are no setter methods, making option A incorrect. While option B would allow you \nto set the value, the class would no longer be immutable. Option C is incorrect because that \nwould not modify the original instance. Option E is correct. If you are an advanced devel-\noper, you might know that you can use reflection to change the value. Don’t read into ques-\ntions like this on the exam. Reflection isn’t on the exam, so you can pretend it doesn’t exist."
  },
  {
    "number": 13,
    "chapter": 10,
    "question": "Let’s say you want to serialize the following class, but only want the flour quantity saved. \nWhat changes, if any, are required to the following class for this to occur?\nimport java.io.*;\npublic class Muffin {\n   private Double flour;\n   private Integer eggs;\n   private Float sugar;\n   private final ObjectStreamField[] serialPersistentFields \u003d \n      { new ObjectStreamField(\"flour\", Double.class) };\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "No changes are required.",
      "Mark eggs and sugar as transient.",
      "Remove the serialPersistentFields variable.",
      "Remove the final modifier from the serialPersistentFields variable.",
      "Add a missing modifier to the serialPersistentFields variable.",
      "None of the above."
    ],
    "explanation": "The class is not marked Serializable, meaning none of the changes will work and\nmaking option F correct. If it was corrected to implement Serializable, then it  \nwould serialize all of the fields, not just flour as written. This is because  \nserial PersistentFields is declared without the static modifier. Alternatively, all of \nthe other fields besides flour could be marked transient to achieve the desired result."
  },
  {
    "number": 14,
    "chapter": 10,
    "question": "Which are true about closing resources to guard against a denial of service attack? \n(Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "The NIO.2 Files.lines() method does not require closing a resource when it is used\nin a stream pipeline.",
      "The NIO.2 Files.lines() method requires closing a resource when it is used in a\nstream pipeline.",
      "When locking a resource using an instance of the concurrent Lock interface, the unlock()\nstatement should be immediately before the finally block.",
      "When locking a resource using an instance of the concurrent Lock interface, the unlock()\nstatement should be in a finally block.",
      "When locking a resource using an instance of the concurrent Lock interface, the unlock()\nstatement should be immediately after the finally block."
    ],
    "explanation": "Ensuring resources are released helps prevent a denial of service attack. Stream\nmethods, such as Files.lines(), do not automatically close the file. Option B is correct \nsince the programmer needs to do it. Without this, the system could run out of file resource \nhandles as part of a denial of service attack.\nWhen a resource is locked using an instance of the concurrent Lock interface, it should be \nunlocked in a finally block to ensure this step is not missed. Therefore, option D is the \nother correct answer. Without this, it’s possible an acquired lock is kept indefinitely, and a \ndeadlock ensues as part of a denial of service attack."
  },
  {
    "number": 15,
    "chapter": 10,
    "question": "Which type of attack requires more than one source to initiate?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Billion laughs attack",
      "Million frowns attack",
      "Distributed denial of service attack",
      "SQL injection",
      "Inclusion attack",
      "Denial of service attack"
    ],
    "explanation": "A distributed denial of service attack is a denial of service attack that comes from multiple\nsources, making option C correct. There is no such thing as a million frowns attack. The rest \nof the answers are real attacks but can be executed from a single source."
  },
  {
    "number": 16,
    "chapter": 10,
    "question": "What is this class an example of?\nimport java.util.*;\npublic class Nightclub {\n   private List\u003cString\u003e approved \u003d // IMPLEMENTATION OMITTED\n   private List\u003cString\u003e rejected \u003d // IMPLEMENTATION OMITTED\n   public boolean checkAccess(String name) {\n      var grantAccess \u003d approved.contains(name) \n         || rejected.contains(name);\n      return grantAccess;\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Turquoiselist",
      "Whitelist",
      "Orangelist",
      "Blacklist",
      "Both blacklist and whitelist",
      "None of the above"
    ],
    "explanation": "The method only grants someone access if they appear in either the approved or\nrejected list. The combined data set forms a conceptual whitelist, making option B correct. \nThe variable names chosen were meant to be tricky. If the code was checked to block people \nfrom the rejected list as well, then it would be both a whitelist and blacklist implementation."
  },
  {
    "number": 17,
    "chapter": 10,
    "question": "Which statements about the clone() method are correct? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5,
      1,
      5
    ],
    "options": [
      "Calling clone() on a class that does not implement Cloneable results in a compiler error.",
      "Calling clone() on a class that does not implement Cloneable results in an exception at runtime.",
      "If a class implements Cloneable and does not override the clone() method, then the code\ndoes not compile.",
      "If a class implements Cloneable and does not override the clone() method, then an\nexception is thrown at runtime.",
      "Overriding the clone() method in a class that implements Cloneable guarantees at least a\nshallow copy will be performed.",
      "Overriding the clone() method in a class that implements Cloneable may result in a deep copy."
    ],
    "explanation": "The clone() method is inherited from the Object class. For this reason, it can be\ncalled on any Object without resulting in a compiler error, making options A and C incor-\nrect. Option B is correct and defines the default behavior of clone() if the class does not \nimplement Cloneable. On the other hand, if a class implements Cloneable but does not \noverride clone(), then Java will perform a shallow copy by default, making option D incor-\nrect. Finally, if the class implements Cloneable and overrides clone(), then the behavior \nof the clone() method is entirely dependent on the implementation. For this reason, option \nF is correct, and option E is incorrect."
  },
  {
    "number": 18,
    "chapter": 10,
    "question": "Which statements about securing confidential information are correct? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      5
    ],
    "userAnswers": [
      0,
      3,
      5
    ],
    "options": [
      "When writing to System.out, you should not include sensitive information.",
      "When reading sensitive data from a Console, you should use readLine().",
      "When throwing an exception, it is acceptable to include sensitive information in the message.",
      "A String is not a good object type for sensitive data.",
      "A Java policy should only grant the permission lock to prevent a user from modifying the file.",
      "A Java policy should only grant the permission read to prevent a user from modifying the file."
    ],
    "explanation": "Sensitive information should not be written to System.out, System.err, or a\nstack trace. For this reason, option A is correct, and option C is incorrect. It is preferable \nto use char[] instead of String for sensitive data so that it does not enter the String \npool and become available as part of a memory dump. For this reason, option D is correct, \nand option B is incorrect. Note that Console does have a readPassword() method that \nreturns char[]. Finally, the correct Java policy permission to prevent write access is to only \ngrant read access, making option F correct and option E incorrect."
  },
  {
    "number": 19,
    "chapter": 10,
    "question": "What are the best scenarios for customizing the serialization process? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4,
      5
    ],
    "userAnswers": [
      4,
      5
    ],
    "options": [
      "To prevent SQL injection.",
      "To shuffle data among users.",
      "It is the only way to prevent a sensitive field like birthdate from being written to disk.",
      "To improve performance by applying advanced optimization techniques.",
      "To encrypt a password before it is saved to disk.",
      "To customize the handling of certain user sensitive data like a Social Security number."
    ],
    "explanation": "Encrypting or customizing the handling of certain sensitive fields are good reasons to\ncustomize the serialization process via methods, making options E and F correct. Options \nA, B, and D are invalid and are not reasons to customize the process. Option C is incorrect \nas the transient modifier or serialPersistentFields can be used to exclude fields \nfrom serialization without the need to add any serialization methods."
  },
  {
    "number": 20,
    "chapter": 10,
    "question": "Select a good strategy for handling input validation failures?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Use the assert statement.",
      "Throw an Error.",
      "Log an error but allow the user to continue.",
      "Throw an Exception.",
      "Shut down the computer.",
      "None of the above."
    ],
    "explanation": "A good solution when input validation fails is to stop processing a request and throw\nan Exception to the calling method to deal with the problem, making option D correct. \nOptions A and B are incorrect because throwing Error should be avoided for situations \nwhere the application can recover. Also, assertions are often disabled at runtime. Option C is \nincorrect as the user should not be allowed to continue if they have provided invalid input. \nFinally, option E is incorrect for obvious reasons."
  },
  {
    "number": 21,
    "chapter": 10,
    "question": "Which statements about executing the following program are correct? (Choose two.)\nimport java.security.*;\n \npublic class PrintScores {\n   private static final String CODE \u003d \"12345\";\n   private static final String SCORES \u003d \"test.scores\";\n   public static String getScores(String accessCode) {\n      return AccessController.doPrivileged(\n            new PrivilegedAction\u003cString\u003e() {\n         public String run() {\n            if(accessCode.equals(CODE))           // m1\n               return System.getProperty(SCORES); // m2\n            throw new SecurityException(\"Incorrect code\");\n         }\n      });\n   }\n \n   public static void main(String[] args) {\n      if(args !\u003d null \u0026\u0026 args.length\u003e0)\n         System.out.print(PrintScores.getScores(args[0]));\n   } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "Line m1 makes the code susceptible to tainted inputs from the user.",
      "Line m2 makes the code susceptible to tainted inputs from the user.",
      "The code is not susceptible to tainted inputs from the user.",
      "The code is susceptible to an injection attack.",
      "The code is not susceptible to an injection attack.",
      "The code is susceptible to an injection only if executed with a number as input."
    ],
    "explanation": "When invoking doPrivileged(), make sure there is no chance for a user to pass\ntheir own, unprotected values into the request. Since a constant SCORES is used to read the \nsystem property on line m2, rather than user provided input, the code is safe from tainted \ninputs from the user. The code validates its inputs enough that an injection attack is not pos-\nsible, making option E correct."
  },
  {
    "number": 22,
    "chapter": 10,
    "question": "Which can fill in the blank to make this code compile?\nimport java.io.*;\npublic class Pony implements Serializable {\n   private static final ObjectStreamField[] \n      serialPersistentFields \u003d { new ObjectStreamField(\"name\", \n         String.class) };\n   private String name;\n   private Integer age;\n   private void readObject(ObjectInputStream s)\n         throws Exception {\n      ObjectInputStream.  fields \u003d s.readFields();\n      this.name \u003d (String) fields.get(\"name\", null);\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "GetObject",
      "ReadField",
      "FetchItem",
      "ReadItem",
      "GetField",
      "None of the above"
    ],
    "explanation": "The GetField class is used with the readObject() method, making option E correct.\nThere is also a PutField class used with the writeObject() method that you should be \nfamiliar with for the exam."
  },
  {
    "number": 23,
    "chapter": 10,
    "question": "Which statement about the following classes is correct?\nimport java.util.*;\npublic class Flower {\n   private final String name;\n   private final List\u003cInteger\u003e counts;\n   public Flower(String name, List\u003cInteger\u003e counts) {\n      this.name \u003d name;\n      this.counts \u003d new ArrayList\u003c\u003e(counts);\n   }\n   public final String getName() { return name; }\n   public final List\u003cInteger\u003e getCounts() {\n      return new ArrayList\u003c\u003e(counts);\n   } }\n \nclass Plant {\n   private final String name;\n   private final List\u003cInteger\u003e counts;\n   public Plant(String name, List\u003cInteger\u003e counts) {\n      this.name \u003d name;\n      this.counts \u003d new ArrayList\u003c\u003e(counts);\n   }\n   public String getName() { return name; }\n   public List\u003cInteger\u003e getCounts() {\n      return new ArrayList\u003c\u003e(counts);\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Only Flower is immutable.",
      "Only Plant is immutable.",
      "Both classes are immutable.",
      "Neither class is immutable.",
      "None of the above as one of the classes does not compile."
    ],
    "explanation": "An immutable class must not allow the state to change. The Flower class does this\ncorrectly. While the class isn’t final, the getters are, so subclasses can’t change the value \nreturned. The Plant class lacks this protection, which makes it mutable. Option A is correct."
  },
  {
    "number": 24,
    "chapter": 10,
    "question": "Which of the following can cause an injection attack? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      0,
      1
    ],
    "options": [
      "Access control",
      "Command line input",
      "Constants in the program",
      "Mutable code",
      "Serialization",
      "XML parsing"
    ],
    "explanation": "Option A is incorrect because access control restricts who can do something rather\nthan preventing an injection attack. Option B is correct because unsanitized input from the \ncommand line can do something undesirable like delete a file. Option C is incorrect because \nthe programmer typed those constants rather than a hostile party.\nOption D is incorrect because changing the values of an object is not an injection  \nattack. Option E is incorrect because serialization is writing data to disk rather than  \nexecuting. Option F is correct because XML parsing can load hostile values into your \nprogram."
  },
  {
    "number": 25,
    "chapter": 10,
    "question": "Assuming this class is passed a valid non-negative integer, which statements best describe the \nfollowing class? (Choose two.)\npublic class Charity {\n   private int numberRequests \u003d 0;\n   public synchronized int getNumberOfRequests() {\n      return numberRequests;\n   }\n \n   private void callDatabaseToDonateADollar() {\n      // IMPLEMENTATION OMITTED\n   }\n \n   public synchronized void donateDollar(int numDollars) {\n      numberRequests++;\n      for(int i\u003d0; i\u003cnumDollars; i++) {\n         callDatabaseToDonateADollar();\n      }\n   }\n   \n   public static void main(String[] args) {\n      final var humanFund \u003d new Charity();\n      humanFund.donateDollar(Integer.valueOf(args[0]));\n      System.out.print(humanFund.getNumberOfRequests());\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "It is well encapsulated.",
      "It is susceptible to a denial of service attack.",
      "It creates an immutable object.",
      "It is susceptible to an inclusion attack.",
      "It is not thread-safe.",
      "It is susceptible to an exploit attack."
    ],
    "explanation": "The code is well encapsulated because all instance variables are private, making\noption A correct. It is susceptible to a denial of service attack since there is no input vali-\ndation. For example, if the maximum integer value of 2,147,483,647 is passed, then it will \nmake a huge number of calls to the database, potentially tying up the system and blocking \nvalid requests. For this reason, option B is correct. To fix this code, a limit on the inputted \nvalue should be used. Option E is incorrect because the class is thread-safe since the instance \nmethods are all synchronized. The rest of the options do not apply to this class."
  },
  {
    "number": 26,
    "chapter": 10,
    "question": "In which scenario is it appropriate for confidential information to be used?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Writing to a log file",
      "Printing a stack trace",
      "Outputting to System.err",
      "Storing in a String",
      "Writing an unsecure email",
      "None of the above"
    ],
    "explanation": "Confidential information includes things like credit card numbers and passwords. Options\nA, B, and C are incorrect because they expose confidential information to the environment in \nwhich the application is running. Option D is incorrect because it allows the data to enter the \nString pool, where it can get printed if a memory dump occurs. Option E is incorrect, as \npasswords should not be sent over email. For these reasons, option F is correct."
  },
  {
    "number": 27,
    "chapter": 10,
    "question": "What statements about the following method are correct? (Choose three.)\npublic String checkAlarm(String connectionStr, boolean alarmed)\n      throws SQLException {\n   var query \u003d \"SELECT * FROM office WHERE alarmed \u003d true\";\n   var con \u003d DriverManager.getConnection(connectionStr);\n   var stmt \u003d con.createStatement();\n   try (con; \n         stmt;\n         var rs \u003d stmt.executeQuery(query)) {\n      return rs.next() ? rs.getString(\"address\") : null;\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      5
    ],
    "userAnswers": [
      1,
      2,
      4
    ],
    "options": [
      "It protects against a denial of service attack.",
      "It does not protect against denial of service attacks.",
      "It protects against SQL injection.",
      "It does not protect against SQL injection because it does not use a PreparedStatement.",
      "Even if the method completes without throwing an exception, a resource leak might occur.",
      "If the method completes without throwing an exception, then no resource leak can occur."
    ],
    "explanation": "While it is permitted to declare a resource outside a try-with-resources statement an\nstill have it be protected, declaring two is not recommended. In particular, if  \ncon.create Statement() fails, then the Connection is not closed. For this reason, the \ncode is susceptible to denial of service attacks, making option B correct.\nWhile it does not use a PreparedStatement, the code is safe from SQL injection because \nthe query does not take any parameters, making option C correct. Finally, if the method com-\npletes without throwing an exception, then that means the try-with-resources block was suc-\ncessfully entered. In this case, all resources would have been closed properly making option F \ncorrect."
  },
  {
    "number": 28,
    "chapter": 10,
    "question": "Which statement best describes this class?\nimport java.util.*;\npublic final class Ocean {\n   private final List\u003cString\u003e algae;\n   private final double wave;\n   private int sun;\n   \n   public Ocean(double wave) {\n      this.wave \u003d wave;\n      this.algae \u003d new ArrayList\u003c\u003e();\n   }\n   public int getSun() {\n      return sun;\n   }\n   public void setSun(int sun) {\n      sun \u003d sun;\n   }\n   public double getWave() {\n      return wave;\n   }\n   public List\u003cString\u003e getAlgae() {\n      return new ArrayList\u003cString\u003e(algae);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It can be serialized.",
      "It is well encapsulated.",
      "It is immutable.",
      "It is both well encapsulated and immutable.",
      "None of the above as the code does not compile."
    ],
    "explanation": "This class does not implement Serializable, so option A is incorrect. This code is wel\nencapsulated because the instance variables are private. The algae and wave variables \nare immutable because they are marked final, and there are no methods that can change \nthem. The getAlgae() method creates a defensive copy, preventing direct access to the \nalgae object. Finally, the sun variable is initialized to 0 and is not able to be changed after \nits creation. The setSun() method is missing a this reference, so the assignment sun \u003d \nsun assigns the method parameter sun to itself. For these reasons, the class is immutable, \nand option D is correct."
  },
  {
    "number": 29,
    "chapter": 10,
    "question": "Which are true about this class? (Choose three.)\nimport java.io.*;\nimport java.util.*;\npublic final class Forest implements Serializable {\n   public final int flora;\n   public final List\u003cString\u003e fauna;\n \n   public Forest() {\n      this.flora \u003d 5;\n      this.fauna \u003d new ArrayList\u003c\u003e();\n   }\n   \n   public int getFlora() {\n      return flora;\n   }\n   public List\u003cString\u003e getFauna() {\n      return new ArrayList\u003c\u003e(fauna);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3,
      5
    ],
    "userAnswers": [
      0,
      3,
      4
    ],
    "options": [
      "It is able to be serialized.",
      "It is not able to be serialized.",
      "It is well encapsulated.",
      "It is not well encapsulated.",
      "It is immutable.",
      "It is not immutable."
    ],
    "explanation": "This class implements Serializable and contains serializable instance variables\nmaking option A correct. This code is not well encapsulated because the instance variables \nare public, which matches option D .  While a defensive copy of fauna is made in the getter, \nthe instance variable is public, and elements can be added or removed directly. Therefore, \nthe object is not immutable, and option F is correct."
  },
  {
    "number": 30,
    "chapter": 10,
    "question": "You’ve been hired by Charlie Sweets to perform a security audit of their login system. After \nreviewing the following code, what recommendations would best improve the security of \ntheir system? (Choose three.)\n1:  public class CandyFactory {\n2:     boolean check(String username, String password) {\n3:        // IMPLEMENTATION OMITTED\n4:     }\n5:     public void login() {\n6:        var c \u003d System.console();\n7:        if(c !\u003d null) {\n8:           var username \u003d c.readLine(\"Username: \");\n9:           var password \u003d c.readLine(\"Password: \");\n10:          System.out.println(\"[\"+username+\",\"+password+\"]\");\n11:          System.out.println(check(username,password)\n12:             ? \"Here is your candy\"\n13:             : \"No candy for you\");\n14:       } } }",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4,
      5
    ],
    "userAnswers": [
      0,
      4,
      5
    ],
    "options": [
      "Mark the check() method final on line 2.",
      "Remove the null check on line 7.",
      "Rewrite to not use var on lines 6, 8, and 9, as it is inherently unsafe.",
      "Rewrite to use readPassword() on line 8.",
      "Rewrite to use readPassword() on line 9.",
      "Change or remove line 10."
    ],
    "explanation": "A malicious attacker could extend this class and override the security check()\nmethod, so marking it final is a good idea, making option A correct. Next, the Console \nclass offers a readPassword() method that does not echo what the user types and uses \nchar[] instead of String to avoid a password entering the String pool. For these rea-\nsons, option E is correct. Finally, line 10 prints the user’s password to the System.out \nlog file, which is a terrible security idea. It should be changed or removed, making option F \ncorrect. The rest of the options are incorrect and do not improve the security of this class."
  },
  {
    "number": 31,
    "chapter": 10,
    "question": "Fill in the blanks with the proper method names to serialize an object. (Choose two.)\nimport java.io.*;\npublic class DeliSandwich implements Serializable {\n   public Object () throws ObjectStreamException {\n      // IMPLEMENTATION OMITTED\n   }\n \n   private void (ObjectOutputStream out)\n         throws IOException {\n      // IMPLEMENTATION OMITTED\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "readResolve in the first blank",
      "writeReplace in the first blank",
      "writeObject in the first blank",
      "writeObject in the second blank",
      "readObject in the second blank",
      "writeReplace in the second blank"
    ],
    "explanation": "The read methods are used as part of deserialization, not serialization, making options\nA and E incorrect. Option B and D are correct because they use the correct method parame-\nters and return types for writeReplace() and writeObject()."
  },
  {
    "number": 32,
    "chapter": 10,
    "question": "Your co-worker has called you in the middle of the night to report all the servers have \nbeen compromised and have run out of memory. After some debugging, it seems like the \nattacker exploited a file upload resource, but you aren’t sure how since the endpoint has \na small maximum file size limit. What is the most likely type of attack perpetrated against \nthe system?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Denial of service attack",
      "Inclusion attack",
      "Distributed denial of service attack",
      "Exploit attack",
      "SQL injection",
      "Injection attack"
    ],
    "explanation": "An inclusion attack is one in which multiple components are embedded within a single\nfile, such as zip bomb or XML exploit (billion laughs attack). Since the maximum file size is \ngiven to be small, this would be the most likely type of attack used, making option B correct. \nNote that if the file size was not limited, then this could be a regular denial of service attack \nin which a large file is sent repeatedly to overwhelm the system."
  },
  {
    "number": 33,
    "chapter": 10,
    "question": "Which statements about the following class are correct? (Choose three.)\nimport java.security.*;\nimport java.util.*;\n \npublic class UserProfile {\n   private static class UserEntry {\n      private final UserProfile value;\n      private final Permission permission;\n      // Constructors/Getters Omitted\n   }\n   \n   public static Permission getPermission(String check) {\n      // Implementation Omitted\n   }\n   \n   private static Map\u003cString,UserEntry\u003e data \u003d new HashMap\u003c\u003e();\n   public static UserProfile getProfile(String check) {\n      var securityRecord \u003d data.get(check);\n      if (securityRecord !\u003d null)\n         return securityRecord.getValue();              // h1\n      var permission \u003d getPermission(check);\n      var permCol \u003d permission.newPermissionCollection();\n      permCol.add(permission);\n      var prof \u003d AccessController.doPrivileged(         // h2\n         new PrivilegedAction\u003cUserProfile\u003e() {\n            public UserProfile run() {\n               return new UserProfile();\n         }},\n         new AccessControlContext(\n            new ProtectionDomain[] {\n               new ProtectionDomain(null, permCol)\n            }));\n      data.put(check, new UserEntry(prof, permission)); // h3\n      return prof;\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      5
    ],
    "userAnswers": [
      0,
      2,
      5
    ],
    "options": [
      "Line h1 properly validates security.",
      "Line h1 presents an unacceptable security risk.",
      "Line h2 elevates security privileges.",
      "Line h2 does not elevate security privileges.",
      "Line h3 violates security guidelines by allowing security information to be cached.",
      "Line h3 does not violate security guidelines."
    ],
    "explanation": "Caching permissions for a user is allowed, so option F is correct. That said, the \nsecurity on using the cached data must be checked. The class is missing calls to  \nAccessController.checkPermission() before lines h1 and h2 .  On line h1, this can \nresult in a user reading a cached permission they do not have access to, making option B \ncorrect. On line h2, security permissions could be elevated since access is not checked,  \nmaking option C correct."
  },
  {
    "number": 34,
    "chapter": 10,
    "question": "For which value of name will this code result in a successful SQL injection attack?\npublic Integer getScore(String connectionStr, String name)\n      throws SQLException {\n   var query \u003d \"SELECT score FROM records WHERE name \u003d ?\";\n   var con \u003d DriverManager.getConnection(connectionStr);\n   try (con; var stmt \u003d con.prepareStatement(query)) {\n      stmt.setString(1, name);\n      try(var rs \u003d stmt.executeQuery()) {\n         if(rs.next()) return rs.getInt(\"score\");\n      }\n   }\n   return null;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "DELETE TABLE records;",
      "\u0027Olivia\u0027; DELETE TABLE records",
      "\u0027Sophia; DELETE TABLE records",
      "\u0027Elysia\u0027; DELETE TABLE records",
      "?; DELETE TABLE records;",
      "None of the above"
    ],
    "explanation": "The query uses a PreparedStatement so that the name is properly escaped. For this\nreason, SQL injection is not possible, and option F is correct. For the exam, you don’t need to \nknow how to write a query to cause SQL injection, just how to prevent it."
  },
  {
    "number": 35,
    "chapter": 10,
    "question": "Which are requirements for a class to be immutable? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      4
    ],
    "userAnswers": [
      1,
      2,
      5
    ],
    "options": [
      "A private constructor is provided.",
      "Any instance variables are private.",
      "Any instance variables are initialized in a constructor.",
      "Methods cannot be overridden.",
      "There are no setter methods.",
      "Any instance variables are marked final."
    ],
    "explanation": "An immutable class can have public constructors, so option A is incorrect. Options\nB, D, and E make up the requirements for an immutable class. Option D can be fulfilled by \nmaking the class final or marking the methods final. Option C is incorrect because in-\nstance variables can still be declared with a value or set by an instance initializer. Option F is\nalso incorrect. While it is common to mark instance variables final, as long as there is no \nway for them to be changed after the constructor is executed, the class can still be considered \nimmutable."
  },
  {
    "number": 36,
    "chapter": 10,
    "question": "Which of the following are not typically considered denial of service attacks? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      2
    ],
    "userAnswers": [
      0,
      2
    ],
    "options": [
      "Downloading confidential information from a log file",
      "Uploading a very large file",
      "Performing SQL injection",
      "Passing invalid numbers to trigger overflow or underflow",
      "Exploiting a database resource leak",
      "Uploading a zip bomb"
    ],
    "explanation": "A denial of service attack is one in which one or more requests attempt to overwhelm\nthe system and disrupt legitimate requests. Option A is an access or confidentiality problem. \nOption C is about gaining access or changing data that the user should not be permitted \nto. Options B, D, E, and F are all denial of service attacks because they increase load in an \nattempt to bring a system down. Remember, a zip bomb is when a small file is expanded to \nbecome a much larger file."
  },
  {
    "number": 37,
    "chapter": 10,
    "question": "The following code prints false. Which statements best describe the Fruit class? \n(Choose three.)\nvar original \u003d new Fruit();\noriginal.sweet \u003d new ArrayList\u003c\u003e();\nvar cloned \u003d (Fruit) original.clone();\nSystem.out.print(original.sweet \u003d\u003d cloned.sweet);",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      4
    ],
    "userAnswers": [
      0,
      1,
      5
    ],
    "options": [
      "It does not implement Cloneable.",
      "It performs a deep copy.",
      "It performs a shallow copy.",
      "It overrides clone().",
      "It implements Cloneable.",
      "It does not override clone()."
    ],
    "explanation": "The Fruit class must implement Cloneable; otherwise, an exception would\nbe thrown at runtime, making option E correct. The Fruit class must also override the \nclone() method. If it did not, then a shallow copy would be performed on the sweet \nobject, resulting in the code printing true at runtime. Since this is not the case, option D is \ncorrect. Finally, we’ve already ruled out a shallow copy, so by process of elimination it must \nperform a deep copy. For this reason, option B is correct."
  },
  {
    "number": 38,
    "chapter": 10,
    "question": "What are the best ways to prevent SQL injection? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "Avoid SQL statements that take query parameters.",
      "Log an error anytime a SQL injection attack is successful.",
      "Avoid concatenating user input into a query string.",
      "Ensure database resources are closed.",
      "Always use a PreparedStatement instead of a Statement.",
      "Do not use a relational database."
    ],
    "explanation": "The primary way SQL injection occurs is from concatenating SQL queries without\nproperly escaping the values. Avoiding concatenation and using a PreparedStatement \nwith bind variables are the commonly accepted ways to prevent this. For these reasons, \noptions C and E are correct.\nOption A is incorrect because a database that takes no query parameters of any kind would \nbe pretty limited in its capabilities. For example, it would be challenging to log a user in if \nyou couldn’t search for that user. Option B is also incorrect, as you can’t prevent a SQL injec-\ntion after it is already successful. Option D is incorrect, as a resource leak is more susceptible \nto a denial of service attack in which resources are exploited, rather than SQL injection in \nwhich data is manipulated. Finally, option F is incorrect, as avoiding using a relational data-\nbase is not a commonly accepted practice for avoiding SQL injection."
  },
  {
    "number": 39,
    "chapter": 10,
    "question": "Given the following two classes, what change to the StealSecret class would allow it to read \nand email the password to a hacker?\npublic class Secret {\n   private String mySecret;\n   public void setSecret(String secret) {\n      mySecret \u003d secret;\n   }\n   public void printSecret() {\n      throw new UnsupportedOperationException(\"Nope!\");\n   }\n   private void saveToDisk() {\n      // IMPLEMENTATION OMITTED\n   }\n}\n \npublic class StealSecret extends Secret {\n   // DO BAD STUFF\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "There are no changes, as the Secret class is secure.",
      "Override the mySecret variable.",
      "Override the setSecret() method.",
      "Override the printSecret() method.",
      "Override the saveToDisk() method.",
      "Add a constructor."
    ],
    "explanation": "Option C is the correct answer. A hacker could override the setSecret() method\nto first steal the inputted secret value and email it herself and then pass the data along \nto the parent by calling super.setSecret() without anyone noticing any difference. \nOne fix would be to mark this method final in the Secret class or make the Secret \nclass final.\nOption B is incorrect because variables can only be hidden, not overridden, so declaring a \nnew mySecret variable would not grant access to the parent variable. Option D is incorrect \nas overriding this method won’t allow the attacker to access the mySecret variable directly. \nOption E is trivially incorrect, as private methods cannot be overridden. Finally, option \nF is incorrect as adding a constructor does not grant access to private members in the \nparent class."
  },
  {
    "number": 40,
    "chapter": 10,
    "question": "Which statement about the following classes is correct?\nimport java.util.*;\nfinal class Faucet {\n   private final String water;\n   private final List\u003cDouble\u003e pipes;\n   public Faucet(String water, List\u003cDouble\u003e pipes) {\n      this.water \u003d water;\n      this.pipes \u003d pipes;\n   }\n   public String getWater() { return water; }\n   public List\u003cDouble\u003e getPipes() { return pipes; } }\n \npublic final class Spout {\n   private final String well;\n   private final List\u003cBoolean\u003e buckets;\n   public Spout(String well, List\u003cBoolean\u003e buckets) {\n      this.well \u003d well;\n      this.buckets \u003d new ArrayList\u003c\u003e(buckets);\n   }\n   public String getWell() { return well; }\n \n   public List\u003cBoolean\u003e getBuckets() {\n      return new ArrayList\u003c\u003e(buckets);\n   } }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Only Faucet is immutable.",
      "Only Spout is immutable.",
      "Both classes are immutable.",
      "Neither class is immutable.",
      "None of the above as one of the classes does not compile."
    ],
    "explanation": "An immutable class must not allow the state to change. In the Faucet class, the caller has\na reference to the List being passed in and can change the size or elements in it. Similarly, \nany class with a reference to the object can get the List by calling get() and make these \nchanges. The Faucet class is not immutable. The Spout class shows how to fix these prob-\nlems and is immutable, making option B correct."
  },
  {
    "number": 1,
    "chapter": 11,
    "question": "How many of Connection, Driver, DriverManager, PreparedStatement, and \nResultSet are JDBC interfaces included with the JDK?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Connection is a JDK interface for communicating with the database. \nPreparedStatement and ResultSet are typically used to write queries and are also in \nthe JDK. Driver is tricky because you don’t write code that references it directly. However, \nyou are still required to know it is a JDBC interface. DriverManager is used in JDBC code \nto get a Connection. However, it is a concrete class rather than an interface. Since only four \nout of the five are JDBC interfaces, option E is correct."
  },
  {
    "number": 2,
    "chapter": 11,
    "question": "Which is found in the java.sql package that come with the standard JDK?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Only DerbyDriver",
      "Only MySqlDriver",
      "Only OracleDriver",
      "DerbyDriver, MySqlDriver, OracleDriver",
      "Only DerbyDriver and MySqlDriver",
      "None of these"
    ],
    "explanation": "Database-specific implementation classes are not in the java.sql package. The imple\nmentation classes are in database drivers and have package names that are specific to the \ndatabase. Therefore, option F is correct. The Driver interface is in the java.sql package. \nNote that these classes may or may not exist. You are not required to know the names of any \ndatabase-specific classes, so the creators of the exam are free to make up names."
  },
  {
    "number": 3,
    "chapter": 11,
    "question": "What must be the first characters of a database URL?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "db,",
      "db:",
      "jdbc,",
      "jdbc:",
      "None of the above"
    ],
    "explanation": "All JDBC URLs begin with the protocol jdbc followed by a colon as a delimiter. Option\nD is the only one that does both of these, making it the correct answer."
  },
  {
    "number": 4,
    "chapter": 11,
    "question": "Which is responsible for getting a connection to the database?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Driver",
      "Connection",
      "PreparedStatement",
      "Statement",
      "ResultSet"
    ],
    "explanation": "The Driver interface is responsible for getting a connection to the database, making\noption A the answer. The Connection interface is responsible for communication with the \ndatabase but not making the initial connection. The Statement interface knows how to run \nthe SQL query, and the ResultSet interface knows what was returned by a SELECT query."
  },
  {
    "number": 5,
    "chapter": 11,
    "question": "Which of these obtains a Connection?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Connection.getConnection(url)",
      "Driver.getConnection(url)",
      "DriverManager.getConnection(url)",
      "new Connection(url)",
      "None of the above"
    ],
    "explanation": "Connection is an interface. Since interfaces do not have constructors, option D is incor\nrect. The Connection class doesn’t have a static method to get a Connection either, \nmaking option A incorrect. The Driver class is also an interface without static methods, \nmaking option B incorrect. Option C is the answer because DriverManager is the class \nused in JDBC to get a Connection."
  },
  {
    "number": 6,
    "chapter": 11,
    "question": "Which method in DriverManager is overloaded to allow passing a username \nand password?",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "conn()",
      "connect()",
      "forName()",
      "getStatement()",
      "open()",
      "None of the above"
    ],
    "explanation": "The DriverManager.getConnection() method can be called with just a URL. It\nis also overloaded to take the URL, username, and password. Since this is not one of the \noptions, the answer is option F ."
  },
  {
    "number": 7,
    "chapter": 11,
    "question": "What is the output if the clowns database exists and contains an empty clowns table?\nvar url \u003d \"jdbc:derby:clowns;create\u003dtrue\";\nvar sql \u003d \"SELECT count(*) FROM clowns\";\ntry (var conn \u003d DriverManager.getConnection(url);\n   var stmt \u003d conn.prepareStatement(sql);\n   var rs \u003d stmt.executeQuery()) {\n \n   System.out.println(rs.getInt(1));\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "0",
      "1",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime."
    ],
    "explanation": "This code is missing a call to rs.next(). As a result, rs.getInt(1) throws a \nSQLException with the message Invalid cursor state – no current row. \nTherefore, option D is the answer."
  },
  {
    "number": 8,
    "chapter": 11,
    "question": "Consider the three methods execute(), executeQuery(), and executeUpdate().  \nFill in the blanks: _______ of these methods is/are allowed to run a DELETE SQL statement \nwhile ________ of these methods is/are allowed to run an UPDATE SQL statement.",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "None, one",
      "One, none",
      "One, one",
      "One, two",
      "Two, two",
      "Three, three"
    ],
    "explanation": "The execute() method is allowed to run any type of SQL statements. The \nexecuteUpdate() method is allowed to run any type of the SQL statement that returns \na row count rather than a ResultSet. Both DELETE and UPDATE SQL statements are \nallowed to be run with either execute() or executeUpdate(). They are not allowed to \nbe run with executeQuery() because they do not return a ResultSet. Therefore,  \noption E is the answer."
  },
  {
    "number": 9,
    "chapter": 11,
    "question": "Suppose the pandas table has one row with the name Mei Xiang and the location DC. \nWhat does the following code output?\nvar url \u003d \"jdbc:derby:pandas\";\nvar sql \u003d \"SELECT name FROM pandas WHERE location \u003d \u0027DC\u0027\";\ntry (var conn \u003d DriverManager.getConnection(url);    // s1\n   var stmt \u003d conn.prepareStatement(sql);            // s2\n   var rs \u003d stmt.executeQuery()) {\n \n   if (rs.next())\n      System.out.println(rs.getString(\"name\"));\n   else\n      System.out.println(\"No match\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Mei Xiang",
      "No match",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to another line.",
      "The code throws an exception at runtime."
    ],
    "explanation": "This code uses a PreparedStatement without bind variables (?). While it would be\nbetter to use bind variables, this code does run. The ResultSet has one value and does \nprint Mei Xiang successfully. Therefore, option A is the answer."
  },
  {
    "number": 10,
    "chapter": 11,
    "question": "Suppose we have a peacocks table with two columns: name and rating. What does the fol-\nlowing code output if the table is empty?\nvar url \u003d \"jdbc:derby:birds\";\nvar sql \u003d \"SELECT name FROM peacocks WHERE name \u003d ?\";\ntry (var conn \u003d DriverManager.getConnection(url);\n   var stmt \u003d conn.prepareStatement(sql)) {       // s1\n \n   stmt.setString(1, \"Feathers\");\n   stmt.setString(2, \"Nice\");\n \n   boolean result \u003d stmt.execute();               // s2\n \n   System.out.println(result);\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "false",
      "true",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to another line.",
      "The code throws an exception at runtime."
    ],
    "explanation": "While the table has two columns, the SQL query has only one bind variable (?). Therefore,\nthe code throws an exception when attempting to set the second bind variable, and option F \nis correct."
  },
  {
    "number": 11,
    "chapter": 11,
    "question": "Suppose we have an empty bunny table with two columns: name and color. What is the state \nof the table after running this code?\nvar url \u003d \"jdbc:derby:bunnies\";\nvar sql \u003d \"INSERT INTO bunny(name, color) VALUES (?, ?)\";\ntry (var conn \u003d DriverManager.getConnection(url);\n   var stmt \u003d conn.prepareStatement(sql)) {  // s1\n \n   stmt.setString(1, \"Daisy\");\n   stmt.setString(2, \"Brown\");\n \n   stmt.executeUpdate();\n \n   stmt.setString(1, \"Cinna\");\n   stmt.setString(2, \"Brown\");\n \n   stmt.executeUpdate();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "It has one row.",
      "It has two rows, and the color is Brown in both.",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to another line.",
      "The code throws an exception at runtime."
    ],
    "explanation": "This code is correct. It executes the first update to add the first row and then sets the\nparameters for the second. When it updates the second time, it adds the second row. There-\nfore, option B is the answer."
  },
  {
    "number": 12,
    "chapter": 11,
    "question": "What is the name of a concrete class that implements Statement and is included in \nthe core JDK?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "CallableStatement",
      "PreparedStatement",
      "StatementImpl",
      "Both A and B",
      "None of the above"
    ],
    "explanation": "CallableStatement and PreparedStatement are interfaces that extend the\nStatement interface. You don’t need to know that for the exam. You do need to know that \na database driver is required to provide the concrete implementation class of Statement \nrather than the JDK. This makes option E correct."
  },
  {
    "number": 13,
    "chapter": 11,
    "question": "Given the table books in the figure and a ResultSet created by running the following SQL \nstatement, which option prints the value 379?\ntitle\nvarchar(255)\nBeginning Java\nAdvanced Java\n379\n669\nnum_pages\ninteger\nSELECT * FROM books WHERE title \u003d \u0027Beginning Java\u0027",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "System.out.println(rs.getInt(1));",
      "System.out.println(rs.getInt(2));",
      "System.out.println(rs.getInteger(1));",
      "System.out.println(rs.getInteger(2));"
    ],
    "explanation": "Unlike arrays, JDBC uses one-based indexes. Since num_pages is in the second column,\nthe parameter needs to be 2, ruling out options A and C .  Further, there is not a method \nnamed getInteger() on the ResultSet interface, ruling out option D .  Since the proper \nmethod is getInt(), option B is the answer."
  },
  {
    "number": 14,
    "chapter": 11,
    "question": "Given the table books in the previous question and the following code, which lines would \nyou add to successfully insert a row? (Choose two.)\nvar url \u003d \"jdbc:derby:books;create\u003dtrue\";\nvar sql \u003d \"INSERT INTO books (title,num_pages) VALUES(?,?)\";\ntry (var conn \u003d DriverManager.getConnection(url);\n     var stmt \u003d conn.prepareStatement(sql)) {\n \n  // INSERT CODE HERE\n \n  stmt.executeUpdate();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      3
    ],
    "options": [
      "stmt.setObject(0, \"Intermediate Java\");",
      "stmt.setObject(1, \"Intermediate Java\");",
      "stmt.setObject(1, 500);",
      "stmt.setObject(2, 500);"
    ],
    "explanation": "Since JDBC does not begin indexes with zero, option A is incorrect, and option B is\ncorrect. Similarly, the second parameter is at index 2, so option C is incorrect, and option D \nis the other answer. Note that setObject() can be called instead of a more specific type."
  },
  {
    "number": 15,
    "chapter": 11,
    "question": "Given the table books from the previous two questions and a ResultSet created by \nrunning this SQL statement, which option prints Advanced Java?\nSELECT title FROM books WHERE num_pages \u003e 500",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "System.out.println(rs.getString());",
      "System.out.println(rs.getString(\"0\"));",
      "System.out.println(rs.getString(\"1\"));",
      "System.out.println(rs.getString(\"title\"));",
      "None of the above"
    ],
    "explanation": "Option A does not compile because you have to pass a column index or column name to\nthe method. Options B and C compile. However, there are not columns named 0 or 1 .  Since \nthese column names don’t exist, the code would throw a SQLException at runtime. Option \nD is correct as it uses the proper column name."
  },
  {
    "number": 16,
    "chapter": 11,
    "question": "Which of the following could be valid JDBC URL formats for an imaginary driver named \nmagic and a database named box?\nString first \u003d \"jdbc:magic:127.0.0.1:1234/box\";\nString second \u003d \"jdbc:magic:box\";\nString third \u003d \"jdbc@magic:@127.0.0.1:1234\"; ",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Only first",
      "Only second",
      "Only third",
      "Both first and second",
      "Both first and third",
      "All of these"
    ],
    "explanation": "A JDBC URL has three components separated by colons. All three of these URLs meet\nthose criteria. For the data after the component, the database driver specifies the format. \nDepending on the driver, this might include an IP address and port. Regardless, it needs to \ninclude the database name or alias. The first and second URLs could both be valid for-\nmats because they mention the database box. However, third is incorrect because it has \njdbc@ instead of jdbc:. Therefore, option D correct."
  },
  {
    "number": 17,
    "chapter": 11,
    "question": "Which is a benefit of PreparedStatement over Statement? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "Language independence",
      "NoSQL support",
      "Readability",
      "Security",
      "Supports stored procedures"
    ],
    "explanation": "JDBC uses Java and SQL, so it is not language independent, making option A incorrect.\nIt is used with relational databases, ruling out option B .  A CallableStatement supports \nstored procedures, not a PreparedStatement, making option E incorrect.\nOptions C and D are correct. Using bind variables with a PreparedStatement produces \ncode that is easier to read than one with a lot of String concatenation. Further, when used \nproperly, a PreparedStatement prevents SQL injection."
  },
  {
    "number": 18,
    "chapter": 11,
    "question": "Assuming the clowns database exists and contains one empty table named clowns, what is the \noutput of the following?\nvar url \u003d \"jdbc:derby:clowns\";\nvar sql \u003d \"SELECT * FROM clowns\";\ntry (var conn \u003d new Connection(url);      // s1\n   var stmt \u003d conn.prepareStatement(sql); // s2\n   var rs \u003d stmt.executeQuery()) {        // s3  \n   if (rs.next())\n      System.out.println(rs.getString(1));\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "The code terminates successfully without any output.",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to line s3.",
      "None of the above."
    ],
    "explanation": "Connection is an interface rather than a concrete class. Therefore, it does not have\na constructor and line s1 does not compile. As a result, option B is the answer. Option A \nwould be the answer if the code new Connection() was changed to DriverManager \n.getConnection()."
  },
  {
    "number": 19,
    "chapter": 11,
    "question": "What is the correct order to close database resources?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Connection then PreparedStatement then ResultSet",
      "Connection then ResultSet then PreparedStatement",
      "PreparedStatement then Connection then ResultSet",
      "PreparedStatement then ResultSet then Connection",
      "ResultSet then PreparedStatement then Connection",
      "None of the above"
    ],
    "explanation": "When manually closing database resources, they should be closed in the reverse order\nfrom which they were opened. This means the ResultSet object is closed before the \nStatement object and the Statement object is closed before the Connection object. \nThis makes option E the answer."
  },
  {
    "number": 20,
    "chapter": 11,
    "question": "Assuming the clowns database exists and contains one empty table named clowns, what is the \noutput of the following?\nvar url \u003d \"jdbc:derby:clowns\";\nvar sql \u003d \"SELECT * FROM clowns\";\ntry (var conn \u003d DriverManager.getConnection(url);   // s1\n   var stmt \u003d conn.prepareStatement(sql);           // s2\n   var rs \u003d stmt.executeQuery()) {                    // s3\n \n   if (rs.next())\n      System.out.println(rs.getString(1));\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "The code terminates successfully without any output.",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to line s3.",
      "None of the above."
    ],
    "explanation": "This code correctly obtains a Connection and PreparedStatement. It then runs a\nquery, getting back a ResultSet without any rows. The rs.next() call returns false, so \nnothing is printed, making option A correct."
  },
  {
    "number": 21,
    "chapter": 11,
    "question": "Suppose we have a bunny table with two columns: name and color. What does the following \ncode output if the table is empty?\nvar url \u003d \"jdbc:derby:bunnies\";\nvar sql \u003d \n   \"SELECT count(*) FROM bunny WHERE color \u003d ? and name \u003d ?\";\ntry (var conn \u003d DriverManager.getConnection(url);\n   var stmt \u003d conn.prepareStatement(sql)) {  // s1\n \n   stmt.setString(1, \"White\");\n \n   try (var rs \u003d stmt.executeQuery()) {      // s2\n      if (rs.next())\n         System.out.println(rs.getInt(1));\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "0",
      "1",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to another line.",
      "The code throws an exception at runtime."
    ],
    "explanation": "The SQL query has two bind variables, but the code sets only one. This causes a \nSQLException when executeQuery() is called, making option F the answer."
  },
  {
    "number": 22,
    "chapter": 11,
    "question": "Suppose the pandas table has one row with the name Mei Xiang and the location DC. \nWhat does the following code output?\nvar url \u003d \"jdbc:derby:pandas\";\nvar sql \u003d \"SELECT name FROM pandas WHERE location \u003d ?\";\ntry (var conn \u003d DriverManager.getConnection(url);  // s1\n   var stmt \u003d conn.prepareStatement(sql)) {        // s2\n \n   stmt.setString(1, \"DC\");\n   try (var rs \u003d stmt.executeQuery()) {\n      if (rs.next())\n         System.out.println(rs.getString(\"name\"));\n      else\n         System.out.println(\"No match\");\n   }\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Mei Xiang",
      "No match",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to another line.",
      "The code throws an exception at runtime."
    ],
    "explanation": "This code uses a PreparedStatement and properly sets a bind variable (?). The\nResultSet has one value and does print Mei Xiang successfully. Therefore, option A is \nthe answer."
  },
  {
    "number": 23,
    "chapter": 11,
    "question": "Which statement is true about the JDBC core classes?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Driver is an implementation of DriverManager.",
      "A general Connection implementation is included in the JDK.",
      "A PreparedStatement uses bind variables.",
      "None of the above."
    ],
    "explanation": "Option A is incorrect because Driver is an interface, while DriverManager is a\nconcrete class. The inverse isn’t true either; DriverManager doesn’t implement Driver. \nOption B is incorrect because the Connection implementation comes from a specific data-\nbase driver JAR. Option C is correct as bind variables (?) are used."
  },
  {
    "number": 24,
    "chapter": 11,
    "question": "Which is true if the clowns database exists and contains an empty clowns table?\nvar url \u003d \"jdbc:derby:clowns\";\nvar sql \u003d \"SELECT COUNT(*) FROM clowns\";\ntry (var conn \u003d DriverManager.getConnection(url);\n    var stmt \u003d conn.prepareStatement(sql);\n    var rs \u003d stmt.executeQuery()) {\n \n    rs.next();                          // r1\n    System.out.println(rs.getInt(1));   // r2\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "The code compiles and prints 0 without error.",
      "The code compiles and prints 1 without error.",
      "The code does not compile.",
      "The code compiles but throws an exception at runtime on line r1.",
      "The code compiles but throws an exception at runtime on line r2."
    ],
    "explanation": "The count(*) function in SQL always returns a number. In this case, it is the number\nzero. This means line r1 executes successfully because it positions the cursor at that row. \nLine r2 also executes successfully and prints 0, which is the value in the row. Since the code \nruns successfully, option A is the answer."
  },
  {
    "number": 25,
    "chapter": 11,
    "question": "Suppose we have an empty bunny table with two columns: name and color. What is the state \nof the table after running this code?\nvar url \u003d \"jdbc:derby:bunnies\";\nvar sql \u003d \"INSERT INTO bunny(name, color) VALUES (?, ?)\";\ntry (var conn \u003d DriverManager.getConnection(url);\n   var stmt \u003d conn.prepareStatement(sql)) {  // s1\n \n   stmt.setString(1, \"Hoppy\");\n   stmt.setString(2, \"Brown\");\n \n   stmt.executeUpdate();\n \n   stmt.setString(1, \"Daisy\");\n \n   stmt.executeUpdate();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Only one row has the color Brown set.",
      "It has two rows, and the color is Brown in both.",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to another line.",
      "The code throws an exception at runtime."
    ],
    "explanation": "This code is correct. It executes the first update to add the first row and then sets the\nparameters for the second. For the second update, only one parameter is set. The other is \nreused since it was set earlier. Therefore, option B is the answer."
  },
  {
    "number": 26,
    "chapter": 11,
    "question": "Which are true statements? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "A PreparedStatement is generally faster than a Statement when each is run 100 times.",
      "A PreparedStatement is generally slower than a Statement when each is run 100 times.",
      "A PreparedStatement is generally the same speed as a Statement when each is run 100 times.",
      "PreparedStatement extends Statement",
      "Statement extends PreparedStatement",
      "PreparedStatement and Statement are not in the same inheritance hierarchy."
    ],
    "explanation": "The PreparedStatement interface extends the Statement interface, which \nmatches option D .  One of the benefits of a PreparedStatement is performance. While a \nPreparedStatement may not be faster if run only once, it will quickly become so. There-\nfore, option A is the other correct answer."
  },
  {
    "number": 27,
    "chapter": 11,
    "question": "Which is true of a PreparedStatement?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "It has a method to change the bind variable to a different character other than ?.",
      "It can be used only for SELECT statements.",
      "It can be used only for UPDATE statements.",
      "All of these are true.",
      "None of these are true."
    ],
    "explanation": "In JDBC, the bind variable is always a question mark (?), making option A incorrect. A\nPreparedStatatement is not limited to specific types of SQL, making options B and C \nincorrect as well. This makes option E the correct answer."
  },
  {
    "number": 28,
    "chapter": 11,
    "question": "Suppose we have a peacocks table with two columns: name and rating. What does the \nfollowing code output if the table is empty?\nvar url \u003d \"jdbc:derby:birds\";\nvar sql \u003d \"SELECT name FROM peacocks WHERE name \u003d ?\";\ntry (var conn \u003d DriverManager.getConnection(url);\n   var stmt \u003d conn.prepareStatement(sql)) {    // s1\n \n   stmt.setString(1, \"Feathers\");\n \n   System.out.println(stmt.executeUpdate());   // s2\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "false",
      "true",
      "The code does not compile due to line s1.",
      "The code does not compile due to line s2.",
      "The code does not compile due to another line.",
      "The code throws an exception at runtime."
    ],
    "explanation": "While this code compiles, it isn’t right. Since we have a SELECT statement, we should be\ncalling execute() or executeQuery(). Option F is the answer because the code throws \nan exception when attempting to call executeUpdate()."
  },
  {
    "number": 29,
    "chapter": 11,
    "question": "What is the most likely outcome of this code if the people table is empty?\n6: var stmt \u003d conn.prepareStatement(\"SELECT * FROM people\");\n7: var rs1 \u003d stmt.executeQuery();\n8: var rs2 \u003d stmt.executeQuery();\n9: System.out.println(rs1.next() + \" \" + rs2.next());",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "It prints false false.",
      "It prints true false.",
      "It does not terminate.",
      "It throws a SQLException.",
      "None of the above."
    ],
    "explanation": "When running a query on a PreparedStatement, Java closes any already open\nResultSet objects associated with the statement. This means that rs1 is closed on line 8 .\nTherefore, it throws a SQLException on line 9 because we are trying to call next() on a \nclosed ResultSet, and option D is correct."
  },
  {
    "number": 30,
    "chapter": 11,
    "question": "What is the most likely outcome of this code if the bunnies table is empty?\nvar url \u003d \"jdbc:derby:bunnies\";\nvar sql \u003d \"INSERT INTO bunny(name, color) VALUES (?, ?)\";\ntry (var conn \u003d DriverManager.getConnection(url);\n   var stmt \u003d conn.createStatement()) {\n   stmt.setString(1, \"Hoppy\");\n   stmt.setString(2, \"Brown\");\n \n   stmt.executeUpdate(sql);\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "One row is in the table.",
      "Two rows are in the table.",
      "The code does not compile.",
      "The code throws a SQLException."
    ],
    "explanation": "This question is trickier if you know more JDBC than is on the exam. If you know only\nwhat is on the exam, you would assume the createStatement() method doesn’t exist. \nHowever, it does, and stmt is a Statement object. Since setString() does not exist on \nStatement, the code does not compile. This means the answer is option C regardless of \nyour level of knowledge of JDBC ."
  },
  {
    "number": 1,
    "chapter": 12,
    "question": "Which of the following are considered locales? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      4,
      5
    ],
    "userAnswers": [
      0,
      4,
      5,
      0,
      4,
      5,
      0,
      4,
      5
    ],
    "options": [
      "Cultural region",
      "Local address",
      "City",
      "Time zone region",
      "Political region",
      "Geographical region"
    ],
    "explanation": "Oracle defines a locale as a geographical, political, or cultural region, making options\nA, E, and F correct. A local address and city are too granular for a locale. Also, time zones \noften span multiple locales."
  },
  {
    "number": 2,
    "chapter": 12,
    "question": "Assuming the key green is in all five of the files referenced in the options, which file will the \nfollowing code use for the resource bundle?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb \u003d ResourceBundle.getBundle(\"Colors\", new Locale(\"fr\"));\nSystem.out.print(rb.getString(\"green\"));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Colors_default.properties",
      "Colors.properties",
      "Colors_en.properties",
      "Colors_US.properties",
      "Colors_en_US.properties",
      "None of the above"
    ],
    "explanation": "Java starts out by looking for a properties file with the requested locale, which in this case\nis the fr language. It doesn’t find it, so it moves onto the default locale en_US, which it does \nfind, making option E correct."
  },
  {
    "number": 3,
    "chapter": 12,
    "question": "When localizing an application, which type of data varies in presentation depending \non locale?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Currencies",
      "Dates",
      "Both",
      "Neither"
    ],
    "explanation": "Currencies vary in presentation by locale. For example, 9,000 and 9.000 both represent\nnine thousand, depending on the locale. Similarly, for dates, 01-02-2022 and 02-01-2022 \nrepresent January 2, 2022, or February 1, 2020, depending on the locale. This makes option \nC the answer."
  },
  {
    "number": 4,
    "chapter": 12,
    "question": "How do you find out the locale of the running program?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Locale.get(\"default\")",
      "Locale.get(Locale.DEFAULT)",
      "Locale.of()",
      "Locale.now()",
      "Locale.getDefault()",
      "None of the above"
    ],
    "explanation": "The Locale object provides getDefault() and setDefault() methods for working\nwith the default locale, so option E is correct. The rest of the methods do not exist in the \nLocale class."
  },
  {
    "number": 5,
    "chapter": 12,
    "question": "How long will the effects of calling Locale.setDefault() be active assuming no other \ncalls to that method are made?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Until the end of the method.",
      "Until the program exits.",
      "Until the next reboot of the computer.",
      "It persists after reboot.",
      "None of the above."
    ],
    "explanation": "Calling Locale.setDefault() changes the default locale within the program. It does\nnot change any settings on the computer. The next time you run a Java program, it will have \nthe original default locale rather than the one you changed it to."
  },
  {
    "number": 6,
    "chapter": 12,
    "question": "What is the output of the following code snippet?\nvar d \u003d LocalDateTime.parse(\"2022-01-21T12:00:00\",\n   DateTimeFormatter.ISO_LOCAL_DATE_TIME);\nSystem.out.print(d.format(DateTimeFormatter.ISO_LOCAL_DATE));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "2022-00-21",
      "2022-00-22",
      "2022-01-21",
      "2022-01-22",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The code compiles and runs without issue. The data is in a valid date format, so the text\nis parsed as January 21, 2022 .  Date values are indexed from 1, not 0, making option C the \ncorrect output. Note that a date formatter is able to format a date/time value, as the time \nelement can be discarded."
  },
  {
    "number": 7,
    "chapter": 12,
    "question": "What is the output if the solveMystery() method is applied to a Properties object \nloaded from mystery.properties?\nmystery.properties\nmystery\u003dbag\ntype\u003dpaper\n \nvoid solveMystery(Properties props) {\n   var a \u003d props.get(\"mystery\");\n   var b \u003d props.get(\"more\", null);\n   var c \u003d props.get(\"more\", \"trick\");\n   System.out.print(a + \" \" + b + \" \" + c);\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "bag ? trick",
      "bag ? null",
      "bag null null",
      "bag null trick",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The first line of the method is correct, as Properties inherits Map and has a get()\nmethod. The get() method does not have an overloaded version that takes a default value, \nthough. For this reason, the second and third get() calls do not compile, and option E is \ncorrect. If getProperty() were instead used on the second and third call, then the output \nwould be bag null trick."
  },
  {
    "number": 8,
    "chapter": 12,
    "question": "Fill in the blank with the option that allows the code snippet to compile and print a message \nwithout throwing an exception at runtime.\nvar x \u003d LocalDate.of(2022, 3, 1);\nvar y \u003d LocalDateTime.of(2022, 3, 1, 5, 55);\nvar f \u003d DateTimeFormatter.ofPattern(\"MMMM\u0027 at \u0027h\u0027 o\u0027clock\u0027\");\nSystem.out.print( );",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "f.formatDate(x)",
      "f.formatDate(y)",
      "f.format(x)",
      "f.format(y)",
      "The code does not compile regardless of what is placed in the blank.",
      "None of the above."
    ],
    "explanation": "Options A and B are incorrect because formatDate() is not a valid method name in\nDateTimeFormatter. Option E is incorrect because the code compiles if either option \nC or D is used. Both options C and D will produce an exception at runtime, though, as the \ndate pattern is invalid. In particular, the apostrophe in o\u0027clock should be escaped. Option \nC is also incorrect because there is no hour value h for a LocalDate. If the pattern string \nwas corrected with o\u0027\u0027clock, then option D would be correct and print March at 5 \no\u0027clock at runtime."
  },
  {
    "number": 9,
    "chapter": 12,
    "question": "Which of the following are valid locale formats? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1
    ],
    "userAnswers": [
      0,
      1
    ],
    "options": [
      "hi",
      "hi_IN",
      "IN_hi",
      "in_hi",
      "HI_IN",
      "IN"
    ],
    "explanation": "In Java, a locale can be represented by a language code in lowercase, or a language\nand country code, with language in lowercase and country in uppercase. For these reasons, \noptions A and B are correct. Options C, D, and E are incorrect because the lowercase lan-\nguage must be before the uppercase country. Option F is incorrect because the language is \nmissing. Remember, the exam won’t expect you to know which language and country codes \nexist, but it will expect you to know how to use them."
  },
  {
    "number": 10,
    "chapter": 12,
    "question": "Assuming the key indigo is in all five of the files referenced in the options, which file will the \nfollowing code use for the resource bundle?\nLocale loc \u003d new Locale(\"fr\", \"CH\");\nLocale.setDefault(new Locale(\"it\", \"CH\"));\nResourceBundle rb \u003d ResourceBundle.getBundle(\"Colors\", loc);\nrb.getString(\"Indigo\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Colors_default.properties",
      "Colors_en_US.properties",
      "Colors_CH.properties",
      "Colors_en.properties",
      "Colors_es.properties",
      "None of the above"
    ],
    "explanation": "Java starts out by looking for a properties file with the requested locale, which in this \ncase is the fr_CH language and country. It doesn’t find Colors_fr_CH.properties,  \nso it moves onto the locale with just a language code fr. It also does not find  \nColors_fr.properties. It then moves on to the default locale it_CH checking  \nColors_it_CH.properties, but there is still no match. It drops the country code and \nchecks it for Colors_it.properties, but still doesn’t find a match. Lastly, it checks for \na Colors.properties file but since that’s not an option, it fails. The result is a  \nMissingResourceException is thrown at runtime, making option F correct."
  },
  {
    "number": 11,
    "chapter": 12,
    "question": "For currency, the US uses the $ symbol, the UK uses the £ symbol, and Germany uses the € \nsymbol. Given this information, what is the expected output of the following code snippet?\nLocale.setDefault(Locale.US);\nLocale.setDefault(Category.FORMAT, Locale.GERMANY);\nSystem.out.print(NumberFormat.getCurrencyInstance(Locale.UK)\n   .format(1.1));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "$1.10",
      "1,10€",
      "£1.10",
      "The code does not compile.",
      "An exception is thrown at runtime.",
      "The output cannot be determined without knowing the locale of the system where it will "
    ],
    "explanation": "The code compiles, so option D is incorrect. In this sample, the default locale is set to US,\nwhile the default locale format is set to GERMANY. Neither is used for formatting the value, as \ngetCurrencyInstance() is called with UK as the locale. For this reason, the £ symbol is \nused, making option C correct."
  },
  {
    "number": 12,
    "chapter": 12,
    "question": "Given the following four properties files, what does this code print?\nLocale.setDefault(new Locale(\"en\"));\nvar rb \u003d ResourceBundle.getBundle(\"Cars\",\n   new Locale(\"de\", \"DE\"));\nvar r1 \u003d rb.getString(\"engine\");\nvar r2 \u003d rb.getString(\"horses\");\nvar r3 \u003d rb.getString(\"country\");\nSystem.out.print(r1+ \" \" + r2 + \" \" + r3);",
    "answered": true,
    "correct": true,
    "questionHasImage": true,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "null null null",
      "engine 241 US",
      "moteur 45 US",
      "engine 241 earth",
      "moteur 241 earth",
      "An exception is thrown at runtime."
    ],
    "explanation": "The getBundle() does not find Cars_de_DE.properties or \nCars_de.properties, so it moves on to the default locale. Since Cars_en.properties \nis available, it will use this file, falling back to Cars.properties if any values are not \navailable. Therefore, it selects engine and horses from the first file, and country from \nthe second file, printing engine 241 earth and making option D correct."
  },
  {
    "number": 13,
    "chapter": 12,
    "question": " Given the four properties files in question 12, what does this\ncode print?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb \u003d ResourceBundle.getBundle(\"Cars\",\n   new Locale(\"fr\", \"FR\"));\nvar s1 \u003d rb.getString(\"country\");\nvar s2 \u003d rb.getString(\"horses\");\nvar s3 \u003d rb.getString(\"engine\");\nSystem.out.print(s1+ \" \" + s2 + \" \" + s3);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "France null engine",
      "France 241 moteur",
      "France 45 moteur",
      "France 241 engine",
      "France 45 engine",
      "An exception is thrown at runtime."
    ],
    "explanation": "The getBundle() method matches Cars_fr_FR.properties. It will then fall back to\nCars_fr.properties (which does not exist) and Cars.properties if the value is not \navailable. For this reason, the first and third values would be France and moteur. While \nthe second value horses is in the default locale, it is not available if the requested locale has \nbeen found. As a result, the code throws a MissingResourceException, making option \nF the answer."
  },
  {
    "number": 14,
    "chapter": 12,
    "question": "Given the four properties files in question 12, what does this code print?\nLocale.setDefault(new Locale(\"ja\",\"JP\"));\nvar rb \u003d ResourceBundle.getBundle(\"Cars\",\n   new Locale(\"fr\", \"FR\"));\nvar t1 \u003d rb.getString(\"engine\");\nvar t2 \u003d rb.getString(\"road\");\nvar t3 \u003d rb.getString(\"country\");\nSystem.out.print(t1+ \" \" + t2 + \" \" + t3);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "moteur autoroute France",
      "engine autoroute France",
      "engine highway France",
      "moteur highway France",
      "moteur highway US",
      "An exception is thrown at runtime."
    ],
    "explanation": "The getBundle() method matches Cars_fr_FR.properties. It will then fall \nback to Cars_fr.properties (which does not exist) and Cars.properties if  \nthe value is not available. For this reason, the first value printed is moteur from  \nCars.properties, while the next two values printed are autoroute and France  \nfrom Cars_fr_FR.properties, making option A correct."
  },
  {
    "number": 15,
    "chapter": 12,
    "question": "Fill in the blank so the code correctly compiles and creates a Locale reference.\nLocale loc \u003d Locale.____________________;",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "get(\"Italian\")",
      "of(Locale.ITALIAN)",
      "get(Locale.ITALIAN)",
      "getLocale(\"Italian\")",
      "of(\"Italian\")",
      "None of the above"
    ],
    "explanation": "There are no get() or of() methods in Locale. You need to use a constructor or a\npredefined Locale constant to obtain a Locale reference. Therefore, option F is the correct \nanswer. Options B and C are close in that Locale.ITALIAN does reference a Locale \nobject. However, it should not be passed to the nonexistent get() method."
  },
  {
    "number": 16,
    "chapter": 12,
    "question": "Assuming the key turquoise is in all five of the files referenced in the options, which file will \nthe following code use for the resource bundle?\nLocale loc \u003d new Locale(\"zh\", \"CN\");\nLocale.setDefault(new Locale(\"en\", \"US\"));\nResourceBundle rb \u003d ResourceBundle.getBundle(\"Colors\", loc);\nrb.getString(\"turquoise\");",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Colors_en.properties",
      "Colors_CN.properties",
      "Colors.properties",
      "Colors_default.properties",
      "Colors_en_CN.properties",
      "None of the above"
    ],
    "explanation": "Java starts out by looking for a properties file with the requested locale, which in this case\nis the zh_CN language and country. It doesn’t find it, so it moves onto the locale with just a \nlanguage code zh, which it also does not find. It then moves on to the default locale en_US, \nbut there is still no match. It drops the country code and does find a match with en, making \noption A correct."
  },
  {
    "number": 17,
    "chapter": 12,
    "question": "How many lines does the following print out?\n3: Locale.setDefault(Locale.KOREAN);\n4: System.out.println(Locale.getDefault());\n5: Locale.setDefault(new Locale(\"en\", \"AU\"));\n6: System.out.println(Locale.getDefault());\n7: Locale.setDefault(new Locale(\"EN\"));\n8: System.out.println(Locale.getDefault());",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "Only an exception is printed.",
      "One, followed by an exception.",
      "Two, followed by an exception.",
      "Three.",
      "It does not compile."
    ],
    "explanation": "This code compiles and runs without exception, making option D the correct answer. Line\n3 uses a predefined Locale constant. Line 5 passes a language and country code for English \nin Australia. Line 7 incorrectly passes capital letters as a language code. However, Java auto-\nmatically converts it to lowercase without throwing an exception. The three lines printed by \nthe code are ko, en_AU, and en."
  },
  {
    "number": 18,
    "chapter": 12,
    "question": "Assuming the key red is in all five of the files referenced in the options, which file will the fol-\nlowing code use for the resource bundle?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb \u003d ResourceBundle.getBundle(\"Colors\",\n   new Locale(\"ca\",\"ES\"));\nSystem.out.print(rb.getString(\"red\"));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "Colors.properties",
      "Colors_en_US.properties",
      "Colors_US.properties",
      "Colors_ES.properties",
      "Colors_ca.properties",
      "None of the above"
    ],
    "explanation": "Java starts out by looking for a properties file with the requested locale, which in this case\nis the ca_ES language and country. It doesn’t find it, so it moves onto the locale with just a \nlanguage code ca, which it does find, making option E correct."
  },
  {
    "number": 19,
    "chapter": 12,
    "question": "What is the output of the following code snippet?\nvar d \u003d LocalDate.parse(\"2022-04-01\",\n   DateTimeFormatter.ISO_LOCAL_DATE);\nSystem.out.print(d.format(\n   DateTimeFormatter.ISO_LOCAL_DATE_TIME));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "2022 APRIL 1",
      "2022 MAY 0",
      "2022 MAY 1",
      "2022 APRIL 0",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The parse() method properly reads the date as April 1, 2022. The format() tries to\nuse a date/time formatter on a date, which produces an exception at runtime since the time \nelement is missing. For this reason, option F is correct."
  },
  {
    "number": 20,
    "chapter": 12,
    "question": "What is the output if the launch() method is applied to a Properties object loaded from \nscifi.properties?\nscifi.properties\nrocket\u003dsaturn5\nmoon\u003dlanding\n \nvoid launch(Properties props) {\n   var a \u003d props.getProperty(\"rocket\", \"?\");\n   var b \u003d props.getProperty(\"earth\");\n   var c \u003d props.getProperty(\"earth\", \"?\");\n   System.out.print(a + \" \" + b + \" \" + c);\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "saturn5 null ?",
      "saturn5 null null",
      "null null ?",
      "saturn5 ? ?",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The first line of the method retrieves the value for the property with key rocket, which\nis saturn5 .  The next line retrieves the value for earth, but since it’s not found, null is \nreturned. The last functions similarly to the previous line but uses ? as the default value \nsince earth is not set. The code then prints saturn5 null ?, making option A the \ncorrect answer."
  },
  {
    "number": 21,
    "chapter": 12,
    "question": "For what values of pattern will the following print \u003c02.1\u003e \u003c06.9\u003e \u003c10,00\u003e? \n(Choose two.)\nString pattern \u003d \" \";\nvar message \u003d DoubleStream.of(2.1, 6.923, 1000)\n   .mapToObj(v -\u003e new DecimalFormat(pattern).format(v))\n   .collect(Collectors.joining(\"\u003e \u003c\"));\nSystem.out.print(\"\u003c\" + message + \"\u003e\");",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      1,
      2
    ],
    "options": [
      "##,00.##",
      "##,00.#",
      "0,00.#",
      "#,00.#",
      "0,00.0",
      "#,##.#"
    ],
    "explanation": "Options B and D correctly print the same string value in the specified format. Option\nA is incorrect because  \u003c06 .92\u003e  is printed instead of  \u003c06 .9\u003e.  Options C and E are incor-\nrect, because (among other things) commas are printed as part of both of the first two values. \nOption F is incorrect because  \u003c2 .1\u003e  \u003c6 .9\u003e is printed instead of  \u003c02 .1\u003e  \u003c06 .9\u003e."
  },
  {
    "number": 22,
    "chapter": 12,
    "question": "What is the result of the following?\nMap\u003cString, String\u003e map \u003d new TreeMap\u003c\u003e();\nmap.put(\"tool\", \"hammer\");\nmap.put(\"problem\", \"nail\");\n \nvar props \u003d new Property();             // p1\nmap.forEach((k,v) -\u003e props.put(k, v));  // p2\n \nString t \u003d props.getProperty(\"tool\");   // p3\nString n \u003d props.getProperty(\"nail\");\nSystem.out.print(t + \" \" + n);",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "hammer nail",
      "The code does not compile due to line p1.",
      "The code does not compile due to line p2.",
      "The code does not compile due to line p3.",
      "An exception is thrown at runtime.",
      "None of the above."
    ],
    "explanation": "The class on line p1 should be Properties rather than Property. As written, it is\nincorrect and does not compile, making option B the correct answer."
  },
  {
    "number": 23,
    "chapter": 12,
    "question": "Assuming the key purple is in all five of the files referenced in the options, which file will the \nfollowing code use for the resource bundle?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb \u003d ResourceBundle.getBundle(\"Colors\", new Locale(\"en\"));\nSystem.out.print(rb.getString(\"purple\"));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "Colors_en_US.properties",
      "Colors_en.properties",
      "Colors_US.properties",
      "Colors_fr.properties",
      "Colors.properties",
      "None of the above"
    ],
    "explanation": "Java starts out by looking for a properties file with the requested locale, which in this case\nis the en language. It finds it right away, making option B correct."
  },
  {
    "number": 24,
    "chapter": 12,
    "question": "Which of the following are not valid Locale formats? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      3
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "nl_BE",
      "fr_CA",
      "uk_ua",
      "CR",
      "no",
      "ro_RO"
    ],
    "explanation": "In Java, a locale can be represented by a language code in lowercase, or a language\nand country code, with language in lowercase and country in uppercase. Option C is invalid \nbecause both values are lowercase. Option D is invalid because the value is in uppercase. The \nrest of the options are valid locale formats. Remember, the exam won’t expect you to know \nwhich language and country codes exist, but it will expect you to know how to use them."
  },
  {
    "number": 25,
    "chapter": 12,
    "question": "For currency, the US uses the $ symbol, the UK uses the £ symbol, and Germany uses the € \nsymbol. Given this information, what is the expected output of the following code snippet?\nLocale.setDefault(Locale.US);\nLocale.setDefault(Category.FORMAT, Locale.GERMANY);\nLocale.setDefault(Category.DISPLAY, Locale.UK);\nSystem.out.print(NumberFormat.getCurrencyInstance()\n   .format(6.95));",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "$6.95",
      "6,95 €",
      "£6.95",
      "The code does not compile.",
      "An exception is thrown at runtime.",
      "The output cannot be determined without knowing the locale of the system where it will "
    ],
    "explanation": "The code compiles, so option D is incorrect. While three distinct locale values are set, the\none that is used for formatting text is Category.FORMAT. For this reason, the GERMANY \nlocale is used to formatting the data with the € symbol, making option B correct."
  },
  {
    "number": 26,
    "chapter": 12,
    "question": "What is the output of the following code snippet?\nvar x \u003d LocalDate.of(2022, 3, 1);\nvar y \u003d LocalDateTime.of(2022, 1, 1, 2, 55);\nvar f \u003d DateTimeFormatter.ofPattern(\"\u0027yyyy-MM\u0027\");\nSystem.out.print(f.format(x) + \" \" + f.format(y));",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "2022-03 2022-01",
      "2022-01 2022-03",
      "2022-02 2022-00",
      "yyyy-MM yyyy-MM",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The date/time pattern uses single quotes to escape the date/time values, meaning the\noutput is yyyy-MM for all valid inputs. For this reason, option D is correct. If the single \nquotes were removed, then 2022-03 2022-01 would be the correct output."
  },
  {
    "number": 27,
    "chapter": 12,
    "question": "Given the following two properties files, what does the following class output?\ncontainer.properties\nname\u003dgeneric\nnumber\u003d2\n \ncontainer_en.properties\nname\u003dDocker\ntype\u003dcontainer\n \nvoid loadPod() {\n   new Locale.Builder()\n      .setLanguage(\"en\")\n      .setRegion(\"US\").build();\n   var rb \u003d ResourceBundle.getBundle(\"container\");\n   String name \u003d rb.getString(\"name\");\n   String type \u003d rb.getString(\"type\");\n   System.out.print(name + \" \" + type);\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "Docker container",
      "generic container",
      "generic null",
      "The output cannot be determined without knowing the locale of the system where it will be run.",
      "An exception is thrown at runtime.",
      "None of the above."
    ],
    "explanation": "The method creates a resource bundle using a builder but never sets it. Since we don’t\nknow the default locale of the code, the answer depends on where it is executed, making \noption D correct."
  },
  {
    "number": 28,
    "chapter": 12,
    "question": "Given the two properties files from question 27, what does the following class output?\nvoid loadContainer() {\n   Locale.setDefault(new Locale(\"en\"));\n   var rb \u003d ResourceBundle.getBundle(\"container\");\n   String name \u003d rb.getString(\"name\");\n   String type \u003d rb.getString(\"type\");\n   System.out.print(name + \" \" + type);\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Docker container",
      "generic container",
      "generic null",
      "The output cannot be determined without knowing the locale of the system where it will be run.",
      "An exception is thrown at runtime.",
      "None of the above."
    ],
    "explanation": "This code sets the default locale to English and then tries to get a resource bundle for\ncontainer. It finds the resource bundle container_en.properties as the most \nspecific match. Both keys are found in this file, so option A is the answer."
  },
  {
    "number": 29,
    "chapter": 12,
    "question": "Given the two properties files from question 27, what does the following class output?\nvoid loadControlPlane() {\n   Locale.setDefault(new Locale(\"en_US\"));\n   var rb \u003d ResourceBundle.getBundle(\"container\");\n   String name \u003d rb.getString(\"name\");\n   String type \u003d rb.getString(\"type\");\n   System.out.print(name + \" \" + type);\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "Docker container",
      "generic container",
      "generic null",
      "The output cannot be determined without knowing the locale of the system where it will be run.",
      "An exception is thrown at runtime.",
      "None of the above."
    ],
    "explanation": "The Locale constructor that takes a single argument expects a language code, not a\nconcatenation of language and region codes. Therefore, the language is set as en_us, not \nen, with no region code set. Since no properties files match the language en_us, the default\ncontainer.properties is used. Since type is not found in this properties file, a  \nMissingResourceException is thrown at runtime."
  },
  {
    "number": 30,
    "chapter": 12,
    "question": "Assuming the Forest.properties file is the only resource file available, what is the \noutput of calling the hike() method?\nForest.properties\ntrees\u003devergreen {0}\nanimals\u003dsquirrels\n \nstatic void hike() {\n   Locale.setDefault(new Locale.Builder()\n      .setLanguage(\"en\").build());\n   var rb \u003d ResourceBundle\n      .getBundle(\"Forest\", new Locale(\"fr\"));\n   System.out.print(MessageFormat.format(\"trees\",\"pretty\"));\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "trees",
      "trees pretty",
      "trees {0}",
      "trees null",
      "The code does not compile.",
      "An exception is thrown at runtime."
    ],
    "explanation": "The code compiles, so option E is incorrect. Java starts out by looking for a properties \nfile with the requested locale, which in this case is the fr language. It doesn’t find  \nForest_fr.properties, so it moves onto the default locale en. It also doesn’t find \nForest_en.properties. It settles on Forest.properties without throwing an \nexception, so option F is incorrect. The first argument to MessageFormat.format() \nshould be a pattern String value. Since trees is sent, the output of the formatting string is \ntrees, making option A correct. If rb.getString(\"trees\") was passed instead of just \ntrees, then the output would be evergreen pretty."
  },
  {
    "number": 1,
    "chapter": 13,
    "question": "What modifier is used to mark an annotation element as optional?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "optional",
      "default",
      "required",
      "value",
      "case",
      "None of the above"
    ],
    "explanation": "The default modifier along with a value is used to mark an annotation element as\noptional, as opposed to required."
  },
  {
    "number": 2,
    "chapter": 13,
    "question": "Given a Broadway show, which information is best stored using annotations? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2
    ],
    "userAnswers": [
      1,
      2,
      1,
      2
    ],
    "options": [
      "The number of people attending each day",
      "The maximum number of tickets a person can purchase",
      "The total number of people the theater can hold",
      "The price including discounts a person pays for a ticket",
      "A person’s seat assignment",
      "The time a ticket is sold"
    ],
    "explanation": "Annotations are about storing metadata, or data about data. The maximum number\nof tickets per person and total number of people the theater can hold define rules that are \nunlikely to change frequently, so they are best stored with annotations. The number of people \nattending, price, and time the ticket is sold are likely to change frequently and should be part \nof the transactional information for the ticket. The seat assignment also changes for every \nticket sold."
  },
  {
    "number": 3,
    "chapter": 13,
    "question": "Fill in the blank with the correct annotation usage that allows the code to compile.\npublic interface CelestialBody {\n   String name();\n   double size() default 100;\n   int lightYears \u003d 2;\n}\n \n_________________ class Planet {}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "@CelestialBody(name\u003d\"Venus\")",
      "@CelestialBody(name\u003d\"Pluto\", size\u003d2, lightYears\u003d5)",
      "@CelestialBody(lightYears\u003d10)",
      "@CelestialBody(\"Jupiter\")",
      "@CelestialBody(size\u003d3)",
      "None of the above"
    ],
    "explanation": "CelestialBody is not an annotation definition because it is not declared with the \n@interface type, making option F correct. If the correct declaration was used, then option \nA would be the correct answer. Options B and C are incorrect, because lightYears is \na constant and cannot be set as part of the annotation. Options C and E are also incor-\nrect because they are missing a name element. Option D is incorrect because there is no \nvalue() element."
  },
  {
    "number": 4,
    "chapter": 13,
    "question": "Fill in the blank with the correct value for @Target that allows the code to compile.\nimport java.lang.annotation.*;\n \n@Target({____________________})\npublic @interface LightSource {}\n \n@LightSource class Bulb {\n   @LightSource void lightSwitch() {}\n   @LightSource private Bulb() {}\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "ElementType.METHOD, ElementType.CONSTRUCTOR",
      "ElementType.ANNOTATION_TYPE",
      "ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.METHOD",
      "ElementType.TYPE_USE",
      "ElementType.LOCAL_VARIABLE, ElementType.FIELD",
      "None of the above"
    ],
    "explanation": "Option C uses the correct values and allows all three annotations to compile. Option A is\nincorrect because the class declaration usage does not compile. Using option B or E does not \nallow any of the annotations to compile. Option D allows the class and constructor annota-\ntions to compile, but not the method usage."
  },
  {
    "number": 5,
    "chapter": 13,
    "question": "Which of the following are marker annotations? (Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      5
    ],
    "userAnswers": [
      0,
      1,
      3
    ],
    "options": [
      "@Target",
      "@Inherited",
      "@Override",
      "@Retention",
      "@Repeatable",
      "@Documented"
    ],
    "explanation": "Options B, C, and F are each marker annotations because they do not contain any ele\nments. Option A is incorrect because @Target requires an ElementType[] value. Option \nD is incorrect because @Retention requires a RetentionPolicy value. Option E is \nincorrect because @Repeatable requires a Class value."
  },
  {
    "number": 6,
    "chapter": 13,
    "question": "Given the following declarations, which annotations can fill in the blank that would allow \nthe code to compile? (Choose three.)\npublic @interface Music {\n   String value() default \"violin\";\n}\n \nclass Orchestra {\n   ______________ void play() {}\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      5
    ],
    "userAnswers": [
      1,
      3,
      5
    ],
    "options": [
      "@Music(super\u003d\"piccolo\")",
      "@Music(\"viola\")",
      "@Music(value()\u003d\"bass\")",
      "@Music",
      "@Music(default\u003d\"flute\")",
      "@Music(value\u003d\"cello\")"
    ],
    "explanation": "Option B is correct and relies on the fact that the single element value() can be\nused without an element name. Option D is correct because the annotation has a default \nvalue; therefore, value is optional. Option F is correct and uses the correct name for value. \nOptions A, C, and E are incorrect because they use the wrong name for the element."
  },
  {
    "number": 7,
    "chapter": 13,
    "question": "How many lines of the following declaration contain a compiler error?\n1: public @interface Thermometer {\n2:    int minTemp();\n3:    Integer maxTemp() default 1;\n4:    double[] color();\n5:    final String type;\n6:    Boolean compact;\n7: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Lines 3 and 6 do not compile because wrapper classes are not permitted as annotation\nelement types. Line 5 does not compile because a constant must be declared with a value. For \nthese reasons, option D is correct. The rest of the lines compile without issue."
  },
  {
    "number": 8,
    "chapter": 13,
    "question": "In what ways are annotations similar to interfaces? (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      2,
      4
    ],
    "userAnswers": [
      2,
      4
    ],
    "options": [
      "They can both declare methods with bodies.",
      "They can both declare constructors.",
      "They can both declare constants.",
      "They can both be extended with the extends keyword.",
      "They can both be used in a class declaration.",
      "They both are declared with the interface type."
    ],
    "explanation": "Options A and D are incorrect. An interface can define a method and be extended, but\nan annotation cannot. Neither type can declare constructors, making option B incorrect. \nAnnotations and interfaces can both declare constants and be applied to a class declaration, \nmaking options C and E correct. Interfaces use the interface type, while annotations use \nthe @interface type, making option F incorrect."
  },
  {
    "number": 9,
    "chapter": 13,
    "question": "In how many of the marked places (m1, m2, m3) will adding the line  \n@SuppressWarnings() independently allow the class to compile without any warnings?\nimport java.util.*;\n// m1\npublic class Space {\n   // m2\n   final void frontier() {\n      List\u003cObject\u003e stars \u003d List.of(1,2,3);\n      stars.add(4);\n      \n      // m3\n      List planets \u003d new ArrayList\u003c\u003e();\n      planets.add(5);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "None, the class does not compile as is.",
      "None, the class already compiles without warnings.",
      "One.",
      "Two.",
      "Three.",
      "None of the above."
    ],
    "explanation": "The class compiles as is but generates warnings for unchecked/unsafe operations \nwith the planets.add(5) operation, so options A and B are incorrect. Inserting  \n@Suppress Warnings(), though, will cause a compiler error as it requires at least one \nvalue. For this reason, option F is correct. If @SuppressWarnings(\"unchecked\") was \nused instead, then inserting it on lines m1 and m2 would allow the code to compile without \nany warnings."
  },
  {
    "number": 10,
    "chapter": 13,
    "question": "An annotation cannot be applied to which of the following?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "Class declaration.",
      "Annotation declaration.",
      "Inner class declaration.",
      "Cast operation.",
      "Local variable declaration using var.",
      "An annotation can be applied to all of the above."
    ],
    "explanation": "An annotation can be applied to all of these Java declarations, making option F correct"
  },
  {
    "number": 11,
    "chapter": 13,
    "question": "Which statements about the @Override annotation are correct? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      4
    ],
    "userAnswers": [
      0,
      1,
      4
    ],
    "options": [
      "It can be optionally specified when a class implements an abstract interface method.",
      "Adding it to a method may trigger a compiler error.",
      "It is required whenever a class implements an abstract interface method.",
      "It can be added to an interface declaration type.",
      "It can be optionally specified when a method is overridden in a subclass.",
      "It is required whenever a method is overridden in a subclass."
    ],
    "explanation": "The @Override annotation is always optional for methods and never required. For\nthis reason, options A and E are correct, and options C and F are incorrect. Option B is correct \nbecause adding it to a method that is not actually overriding an inherited method will cause a \ncompiler error. Option D is incorrect because it can be applied only to method declarations."
  },
  {
    "number": 12,
    "chapter": 13,
    "question": "Given the following declarations, which annotation can be applied to a method declaration?\nimport java.lang.annotation.*;\n@interface Bread {\n   public int maker \u003d 5;\n   String baker();\n}\n@Inherited\n@interface Toast {\n   boolean buttered() default true;\n   int freshness() default Bread.maker;\n   static boolean wheat \u003d false;\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      1
    ],
    "options": [
      "@Toast(true)",
      "@Toast",
      "@Bread(\"null\")",
      "@Toast(wheat\u003dtrue)",
      "@Bread",
      "None of the above, as the annotation declarations do not compile"
    ],
    "explanation": "The declaration compiles, so option F is incorrect. The Bread annotation is declared with\none required element, while Toast is declared with no required elements. For these reasons, \noption B is correct, and option E is incorrect. Options A and C are incorrect because neither \nannotation contains a value() element. Option D is incorrect because wheat is a constant, \nnot an element."
  },
  {
    "number": 13,
    "chapter": 13,
    "question": "Which properties of the Clean annotation must be true for the following to compile? \n(Choose three.)\n@Clean(\"Basement\") public class House {}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3,
      4
    ],
    "userAnswers": [
      1,
      2,
      3
    ],
    "options": [
      "The annotation must contain exactly one element.",
      "The annotation must contain an element named value.",
      "The element must not have a default value.",
      "The element may have a default value.",
      "The annotation may contain more than one element.",
      "The annotation must contain an element named values."
    ],
    "explanation": "An annotation may omit the element name if it contains an element named value,\ndeclared as value(), making option B correct and option F incorrect. Additionally, it may \ncontain any number of additional elements, provided none of them is required, making \noption E correct. Finally, the element may optionally have a default value, making option D \ncorrect. The other options are incorrect statements that contradict the correct answers."
  },
  {
    "number": 14,
    "chapter": 13,
    "question": "Assume the following code compiles. Which annotation inserted in the line allows the code to \nprint a non-null value at runtime?\n// INSERT HERE\n@interface Fast {\n   int topSpeed() default 10;\n}\n \n@Fast class BigCat {}\n \npublic class Cheetah extends BigCat {\n   public static void main(String... unused) {\n      var a \u003d Cheetah.class.getAnnotation(Fast.class);\n      System.out.print(a);\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "@Inherited",
      "@Polymorphism",
      "@Inheritance",
      "@Retention",
      "@Subclass",
      "None of the above"
    ],
    "explanation": "Trick question! By default, annotations are not present at runtime. To print a non-null\nvalue, both @Retention(RetentionPolicy.RUNTIME) and @Inherited would \nbe required, making option F correct. The @Retention annotation would preserve the \nannotation for runtime, while the @Inherited annotation would apply it to the sub-\nclass Cheetah."
  },
  {
    "number": 15,
    "chapter": 13,
    "question": "How many lines of the following declaration contain a compiler error?\n1: public @interface Student {\n2:    final boolean likesPonies \u003d true;\n3:    int value default 100;\n4:    int age();\n5:    /** TODO **/\n6:    String name() default \"Olivia\";\n7: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Only line 3 contains a compiler error, as an element declared in an annotation must use\nparentheses after its name, making option B correct. If value() was used instead of value, \nthen the code would compile."
  },
  {
    "number": 16,
    "chapter": 13,
    "question": "Which statement about the following declarations is correct?\nimport java.lang.annotation.*;\nimport java.util.List;\n \n@Target(ElementType.TYPE_USE)\npublic @interface Friend {\n   String value();\n   String lastName() default null;\n   int age \u003d 10;\n}\nclass MyFriends {\n   void makeFriends() {\n      var friends \u003d List.of(new @Friend(\"Olivia\") Object(),\n            new @Friend(\"Adeline\") String(),\n            new @Friend(\"Henry\") MyFriends());\n   }\n}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      4
    ],
    "options": [
      "None of the declarations compile.",
      "Only the declaration of Friend contains a compiler error.",
      "Only the declaration of MyFriends contains a compiler error.",
      "Both declarations contain compiler errors.",
      "None of the above."
    ],
    "explanation": "A default annotation element value must be a non-null constant expression. Since \nlastName() provides a null value by default, the declaration of Friend contains a  \ncompiler error. The declaration of MyFriends does not contain any compiler errors, so \noption B is correct."
  },
  {
    "number": 17,
    "chapter": 13,
    "question": "Which of the following are permitted to be used for annotation element type? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      3
    ],
    "userAnswers": [
      1,
      2,
      3
    ],
    "options": [
      "Object",
      "An annotation",
      "Class[]",
      "An enum",
      "Double",
      "var"
    ],
    "explanation": "An annotation element type must be a primitive type, a String, a Class, an enum,\nanother annotation, or an array of any of these types. For this reason, options B, C, and D \nare correct. Option A is incorrect because Object is not supported. While primitives are sup-\nported, wrappers are not, making option E incorrect. Option F is also incorrect as local vari-\nable type inference with var is not permitted, even if a default value is provided."
  },
  {
    "number": 18,
    "chapter": 13,
    "question": "Fill in the blanks with the lines of code that allow the program to compile. (Choose two.)\nimport java.lang.annotation.*;\n@Repeatable(___________)  // t1\n@interface Gift {\n   String value();\n}\n@interface Presents {\n   ___________;           // t2\n}\n@Gift(\"Book\") @Gift(\"Toy\") public class Surprise {}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3,
      4
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "Presents on line t1",
      "@Presents on line t1",
      "Gift value() on line t2",
      "Presents.class on line t1",
      "Gift[] value() on line t2",
      "Gift[] gift() on line t2"
    ],
    "explanation": "Gift is a repeatable annotation. It requires specifying a container type annotation\nusing the Class object, making option D correct. The containing type annotation referenced \nmust declare a value() element that is an array of the repeatable annotation, making \noption E correct."
  },
  {
    "number": 19,
    "chapter": 13,
    "question": "Which statements about annotations are correct? (Choose three.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2,
      5
    ],
    "userAnswers": [
      1,
      2,
      5
    ],
    "options": [
      "Annotations contain data that changes throughout the program execution.",
      "Adding an annotation to a class that already compiles may trigger a compiler error and\ncause it to fail to compile.",
      "Annotations contain metadata about a Java type.",
      "Annotations cannot be applied to lambda expression variables.",
      "Annotations cannot be applied to other annotations.",
      "Removing all annotations from a class that already compiles will not introduce a compiler error."
    ],
    "explanation": "Option A is incorrect, as annotations generally contain information that is constant\nthroughout the program execution. Option B is correct. For example, adding an @Override \nannotation to a method that is not a valid override will trigger a compiler error. Option C \nis also correct and is the primary purpose of annotations. Options D and E are incorrect, \nas annotations can be applied to a variety of types including lambda expression variables \nand other annotations. Finally, option F is correct. Annotations are optional metadata, and \nremoving all of them from a class does not cause a compiler error."
  },
  {
    "number": 20,
    "chapter": 13,
    "question": "Given the following declarations, which annotations can fill in the blank that would allow \nthe code to compile? (Choose three.)\nimport java.util.*;\npublic @interface Vacuum {\n   String[] value();\n}\n \nclass Appliance {\n   ______________ void clean() {}\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      4
    ],
    "userAnswers": [
      0,
      1,
      4
    ],
    "options": [
      "@Vacuum({})",
      "@Vacuum({\"upright\",\"new\"})",
      "@Vacuum(List.of(\"portable\"))",
      "@Vacuum",
      "@Vacuum(\"handheld\")",
      "@Vacuum(default\u003d\"shop\")"
    ],
    "explanation": "Options A, B, and E are correct and rely on the fact that the element name is optional\nfor an annotation with a single element named value(). Option E also relies on annota-\ntions supporting a single element for an array. Note that the array provided is not required to \nhave any elements. Option C is incorrect because Java does not automatically convert from a \nList to an array. Option D is incorrect because the annotation contains a required element. \nFinally, option F is incorrect because default is the wrong element name."
  },
  {
    "number": 21,
    "chapter": 13,
    "question": "Which method declarations can @SafeVarargs be correctly applied to? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      3
    ],
    "userAnswers": [
      0,
      4
    ],
    "options": [
      "protected void hum(double... tune)",
      "final int whistle(int length, float... measure)",
      "static void sing()",
      "private void listen(String... mp3)",
      "void dance(List\u003cInteger\u003e... beat)",
      "private static int play(int[] notes)"
    ],
    "explanation": "The @SafeVarargs annotation requires the method to which it is applied con\ntain a varargs parameter and be unable to be overridden, aka marked static, final, or \nprivate. Options B and D fulfill this requirement. Options A and E are missing a modifier \nthat prevents them from being overridden. Options C and F are missing a vararg parameter. \nWhile a primitive array int[] can be passed to a method containing a varargs param-\neter, to apply the @SafeVarargs annotation, the method must be declared with a varargs \nannotation."
  },
  {
    "number": 22,
    "chapter": 13,
    "question": "Which annotation can be applied to an existing annotation X and ensures a class that uses X \nshows the annotation in its generated Javadoc?",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "@Documented",
      "@Generated",
      "@JavaDoc",
      "@PreserveAnnotations",
      "@Retention",
      "None of the above"
    ],
    "explanation": "The correct annotation that preserves information about annotations in generated \nJavadoc files is @Documented. The rest are incorrect."
  },
  {
    "number": 23,
    "chapter": 13,
    "question": "Fill in the blank with the value that allows the annotation to be accessible by the JVM in \nwhich it is executed?\nimport java.lang.annotation.*; \n@Retention(__________________)\npublic class Corn {}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      5
    ],
    "userAnswers": [
      2
    ],
    "options": [
      "RetentionPolicy.CLASS",
      "RetentionPolicy.JRE",
      "RetentionPolicy.RUNTIME",
      "RetentionPolicy.SOURCE",
      "RetentionPolicy.LIVE",
      "None of the above"
    ],
    "explanation": "The @Retention annotation can be applied only to an annotation declaration, not a\nclass declaration, making option F the correct answer. Applying it to a class will result in a \ncompiler error. If Corn were an annotation, though, then RetentionPolicy.RUNTIME \nwould be correct."
  },
  {
    "number": 24,
    "chapter": 13,
    "question": "How many lines of the following declarations contain a compiler error?\n1: @interface Sword {}\n2: public @interface Zelda {\n3:    private String game();\n4:    Sword sword();\n5:    java.util.List\u003cInteger\u003e gems;\n6:    final boolean hasBossKey();\n7:    public abstract int level() default 99;\n8:    protected boolean continue();\n9: }",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      4
    ],
    "userAnswers": [
      5
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "Lines 3 and 8 do not compile because annotation elements must be public, implicitly or\nexplicitly. Line 8 also does not compile because continue is a keyword in Java. Line 5 does \nnot compile. While arrays are permitted as element types, collections like List are not.\nLine 6 does not compile because annotation elements cannot be marked final, as they are \nimplicitly abstract. For these reasons, option E is correct. Line 4 compiles because an \nannotation can declare another annotation as the element type. Line 7 also compiles. While \nthe public and abstract modifiers aren’t required for an annotation element, they can be \nspecified."
  },
  {
    "number": 25,
    "chapter": 13,
    "question": "Which of the following are permitted for an annotation element default value? \n(Choose three.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      1,
      5
    ],
    "userAnswers": [
      0,
      1,
      3
    ],
    "options": [
      "\"\"",
      "(int)1_000.0",
      "new String()",
      "Integer.valueOf(3).intValue()",
      "null",
      "Integer.MAX_VALUE"
    ],
    "explanation": "An annotation element can include a default value if it is a non-null constant\nexpression. Options A, B, and F fulfill this criteria. Option C is incorrect because it creates a \nnew object. Option D is incorrect because it uses method calls. Option E is incorrect because \nnull is not permitted."
  },
  {
    "number": 26,
    "chapter": 13,
    "question": "Assuming @Weather is a valid repeatable annotation that takes a String, with its associated \ncontaining type annotation @Forecast, which of the following can be applied to a type decla-\nration? (Choose two.)",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      2
    ],
    "userAnswers": [
      2,
      3
    ],
    "options": [
      "@Forecast({\"Storm\", \"Cloudy\"})",
      "@Forecast({@Weather(\"Storm\"), @Weather(\"Cloudy\")})",
      "@Weather(\"Storm\") @Weather(\"Cloudy\")",
      "@Weather({@Forecast(\"Storm\"), @Forecast(\"Cloudy\")})",
      "@Forecast(\"Storm\") @Forecast(\"Cloudy\")",
      "@Weather({\"Storm\", \"Cloudy\"})"
    ],
    "explanation": "@Weather is the repeatable annotation, so it can be used twice on the same type dec\nlaration, making option C correct. A containing type annotation @Forecast takes an array \nof the repeatable annotation @Weather, making option B also correct. Options A and F are \nincorrect, as those represent an annotation that takes an array of String values. Option D \nand E are incorrect because the repeatable and containing type annotations are reversed."
  },
  {
    "number": 27,
    "chapter": 13,
    "question": "Which of the following interface declarations will still compile if @FunctionalInterface is \napplied to each? (Choose two.)\ninterface Dog {\n   default void drink() {}\n   void play();\n}\ninterface Astra extends Dog {\n   private static int eat() { return 1; }\n   void fetch();\n}\ninterface Webby extends Dog {\n   abstract void play();\n   default void rest() {}\n   abstract String toString();\n}\ninterface KC {}\ninterface Georgette extends Dog {\n   int intelligence \u003d 5;\n   void jump();\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      0,
      3
    ],
    "userAnswers": [
      0,
      3
    ],
    "options": [
      "Dog",
      "KC",
      "Georgette",
      "Webby",
      "Astra"
    ],
    "explanation": "To correctly apply the @FunctionalInterface annotation, the interface must pass\nthe single abstract method test. Also, note that none of the default or static methods \ncontributes to the abstract method count.\nDog contains a single abstract method play(), so it will compile, making option A correct. \nWebby extends Dog with the same abstract method as Dog. It also declares toString(), \nbut since this is inherited from java.lang.Object, it does not count as an abstract \nmethod. Therefore, Webby passes the single abstract method test for functional interfaces, \nmaking option D correct. Astra is incorrect because it contains two abstract methods, \nplay() and fetch(). KC is incorrect because it does not extend Dog and does not con-\ntain any abstract methods. Finally, Georgette is incorrect because it contains two abstract \nmethods, play() and jump()."
  },
  {
    "number": 28,
    "chapter": 13,
    "question": "How many lines of the following declarations contain a compiler error?\nimport java.lang.annotation.*;\n \nenum Colors { RED, BLUE, GREEN }\n@Documented\npublic @interface Bouncy {\n   int value();\n   Colors color() default Colors.RED;\n   double size();\n}\n@Bouncy(999, size\u003d10.0) class Trampoline {}",
    "answered": true,
    "correct": false,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1
    ],
    "userAnswers": [
      0
    ],
    "options": [
      "None",
      "One",
      "Two",
      "Three",
      "Four",
      "Five"
    ],
    "explanation": "The declaration of Colors and Bouncy compile without issue. The declaration of \nTrampoline does not compile, though. The Bouncy annotation has two required elements, \nvalue() and size(), so the name of the element value cannot be dropped. For this \nreason, option B is correct."
  },
  {
    "number": 29,
    "chapter": 13,
    "question": "Fill in the blanks: The __________ annotation allows annotations from a superclass to be \napplied to a subclass, while the __________ annotation determines whether annotations are \npresent in generated Javadoc. (Choose two.)",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      1,
      5
    ],
    "userAnswers": [
      1,
      5
    ],
    "options": [
      "@Retention in the first blank",
      "@Inherited in the first blank",
      "@Subclass in the first blank",
      "@Javadoc in the second blank",
      "@Retention in the second blank",
      "@Documented in the second blank"
    ],
    "explanation": "The @Inherited annotation determines whether annotations applied to a supertype\nare applied to its subtypes, while the @Documented annotation allows annotations to be \nincluded in generated Javadoc. For these reasons, options B and F are correct."
  },
  {
    "number": 30,
    "chapter": 13,
    "question": "Fill in the blank with the correct annotation usage that allows the code to compile without\nany warnings.\n@Deprecated(since\u003d\"5.0\")\npublic class ProjectPlanner\u003cT\u003e {\n    ProjectPlanner create(T t) { return this; }\n}\n@SuppressWarnings(___________________)\nclass SystemPlanner {\n    ProjectPlanner planner \u003d new ProjectPlanner().create(\"TPS\");\n}",
    "answered": true,
    "correct": true,
    "questionHasImage": false,
    "optionsHaveImage": false,
    "rightAnswers": [
      3
    ],
    "userAnswers": [
      3
    ],
    "options": [
      "value\u003dignoreAll",
      "value\u003d\"deprecation\",\"unchecked\"",
      "\"unchecked\",\"deprecation\"",
      "{\"deprecation\",\"unchecked\"}",
      "\"deprecation\"",
      "None of the above"
    ],
    "explanation": "The SystemPlanner class compiles although it contains two warnings. First, the\nProjectPlanner class is used, which is deprecated. Second, the create() method uses\nan unchecked/unsafe operation taking a String for the generic type. For this reason, both\nunchecked and deprecation options are required for the code to compile without any\nwarnings. Option D uses the correct format for passing an array to an annotation. Note that\nignoreAll is not a known parameter that the JVM accepts."
  }
]