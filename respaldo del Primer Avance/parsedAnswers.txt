1. A,C. An identifier name must begin with a letter, dollar sign ($), or underscore (_). Num-
bers are permitted only for subsequent characters. Therefore, option C is not a valid variable 
name. Additionally, an identifier may not be a single underscore, making option A an invalid 
variable name.
2. A. In a ternary expression, only one of the two right-most expressions is evaluated. Since 
meal>6 is false, tip-- is evaluated, and tip++ is skipped. The result is that tip is 
changed from 2 to 1, making option A the correct answer. The value of total is 7, since the 
post-decrement operator was used on tip, although you did not need to know this to solve 
the question.
3. A. The f in 4.0f means the type is a float, making option A correct. Local variable type 
inference chooses an exact match rather than using autoboxing to choose Float.
4. D. Trick question. There is no reverse method on the String class. There is one on the 
StringBuilder class. Therefore, the code does not compile, and option D is correct.
5. D. A StringBuilder is mutable, so the length is 2 after line 6 completes. The  
StringBuilder methods return a reference to the same object, so you can chain method 
calls. Therefore, line and anotherLine refer to the same object. This means that line 7 
prints true. Then on line 9, both references point to the same object of length 2, and option 
D is correct.
6. E. The diagram represents all cases where apples or oranges is true, but bananas is 
false, making option E correct. Option A is close but is correct only if the top overlapping 
portion of apples and oranges was filled in. For fun, you should try to draw the diagrams 
that would represent the other answers.
7. A. A String is immutable, so a different object is returned on line 6. The object  
anotherLine points to is of length 2 after line 6 completes. However, the original line 
reference still points to an object of length 1 . Therefore, option A is correct.
8. B,E. Options A and D are incorrect because byte and short do not store values with dec-
imal points. Option C is tempting. However, 3 .14 is automatically a double. It requires 
casting to float or writing  3 .14f to be assigned to a float. Therefore, option B is correct. 
Additionally, option E is correct because local variable type inference is able to automatically 
determine the type is double.
9. A,B. Option A is correct and lists the operators in the same or increasing level of operator 
precedence. In option B, the three operators actually have the same operator precedence, so 
it is correct. Option C is incorrect, as division (/) has a lower precedence than the decre-
ment operator (--). Option D is incorrect because the logical complement operator (!) has 
a higher order of precedence than the other two operators. Option E lists the operators in 
the correct order, but they don’t fit within not equals (!=) and the increment operator (++) 
as listed in the question. In particular, compound addition operator (+=) and short-circuit
logical operator (&&) have a lower precedence than the not equals operator (!=). Finally, 
option F is incorrect because the relational operator (<) does not fit between multiplication 
operator (*) and the division operator (/) in order of precedence.
10. D. Line 18 compiles because neither type is specified for the lambda parameters. Lines 19 
and 22 compile because the lambda parameters use a type or var consistently. These are the 
three lines that compile, making option D correct. Lines 20 and 21 do not compile because 
var must be used for all parameters in a lambda if it is used for any.
11. B. The charAt() and length() methods are declared on both String and  
StringBuilder. However, the insert() method is declared only on a StringBuilder 
and not a String. Therefore, option B is correct.
12. B. Since StringBuilder is mutable, each call to append adds to the value. When calling 
print, toString() is automatically called, and 333 806 1601 is output. Therefore, 
option B is correct.
13. A. Option A does not compile because Java does not allow declaring different types as 
part of the same declaration. The other three options show various legal combinations of 
combining multiple variables in the same declarations with optional default values.
14. E. Local variable type inference requires a value, so that the type can be inferred. The state-
ment var color; without a value is not allowed, making option E the answer.
15. A. The code starts by creating a list of three elements. On line 16, it removes two elements 
and then removes the final one on line 19 . This prints an empty list, making option A the 
correct answer. Note that num is effectively final, so can be used in a lambda.
16. C. The trim() method returns a String with all leading and trailing white space removed. 
In this question, that’s the seven-character String: ":) - (:". Options A and B are 
incorrect because they do not remove the first blank space in happy. Option D is incorrect 
because it does not remove the last character in happy. Therefore, option C is correct.
17. C. Underscores are allowed between any two digits in a numeric literal, causing num4 to fail 
to compile. Additionally, underscores are not allowed adjacent to a decimal point, causing a 
compiler error in num2 . Since two lines have errors, option C is the correct answer.
18. A. The code compiles, so option D is incorrect. The input to the constructor is ignored,  
making the assignment of end to be 4 . Since start is 2, the subtraction of 4 by 2 results in 
the application printing 2, followed by 5, making option A the correct answer.
19. D. Line 4 creates a String of length 5. Since String is immutable, line 5 creates a new 
String with the value 1 and assigns it to builder. Remember that indexes in Java begin 
with zero, so the substring() method is taking the values from the fifth element through 
the end. Since the first element is the last element, there’s only one character in there. Then 
line 6 tries to retrieve the second indexed element. Since there is only one element, this gives a 
StringIndexOutOfBoundsException, and option D is correct.
20. D. The code compiles and runs without issue, making option E incorrect. In this 
example, partA is the integer division of the two numbers. Since 3 does not divide 11
evenly, it is rounded down to 3 . The variable partB is the remainder from the first expres-
sion, which is 2 . The results are added together, resulting in the expression 3 * 5, or 15, and 
making option D correct.
21. C. Calling the constructor and then insert() is an example of method chaining. However, 
the sb.length() call is a problem. The sb reference doesn’t exist until after the chained 
calls complete. Just because it happens to be on a separate line doesn’t change when the refer-
ence is created. Since the code does not compile, option C is correct.
22. C. While parentheses are recommended for ternary operations, especially embedded ones, 
they are not required, so option D is incorrect. The first expression evaluates to 10 >= 10, 
so the first branch of the ternary operation is selected, and "Leftovers" can be eliminated. 
The expression in the second ternary operation evaluates to 3 <= 2, which is false, so 
"Salad" is selected, and option C is correct.
23. A. Since String is immutable, each call to concat() returns a new object with the new 
value. However, that return value is ignored, and the teams variable never changes in value. 
Therefore, it stays as 694, and option A is correct.
24. C. First, bool and Bool are not valid Java types. They should be boolean and Boolean, 
respectively. Next, objects are allowed to have a null reference while primitives cannot. 
Since Integer and String are objects, those lines compile. Finally, the line with int is a 
primitive, so assigning null to it does not compile. Therefore, option C is correct.
25. A. In the first expression, height > 1 is true. Since it uses the logical operator (|), which 
evaluates both sides, the right side is still executed, resulting in length being assigned a 
value of 2 and w assigned a value of true. In the second expression, only the right-hand side 
of the expression is evaluated, so x is assigned a value of 2, and length is unchanged. The 
last expression evaluates to 2 % 2, which is 0, so z is assigned a value of 0 .
26. A. Line 3 creates an empty StringBuilder. Line 4 adds three characters to it. Line 5 
removes the first character, resulting in ed. Line 6 deletes the characters starting at position 
1 and ending right before position 2, which removes the character at index 1, which is d. The 
only character left is e, so option A is correct.
27. D. Options A and B are not true if the String is "deabc". Option C is not true if the 
String is "abcde". Option D is true in all cases.
28. E. The code compiles, so option F is incorrect. The first expression evaluates to true & 
false, which sets carrot to false. The next expression resolves to true ? true : 
false, which results in broccoli being set to true. The last expression reduces to false 
^ false, which sets potato to false. Therefore, option E is the correct output.
29. B. The code successfully defines a local variable inside the lambda. Each value is replaced 
with baby. Since we have a List, all three are output, and option B is the correct answer.
30. D. Line 4 creates a StringBuilder of length 5. Pay attention to the substring() 
method in StringBuilder. It returns a String with the value 321 . It does not change 
the StringBuilder itself. Then line 6 retrieves the second indexed element from that 
unchanged value, which is 4 . Therefore, option D is correct.
1. B,F. A switch statement supports the primitive types byte, short, char, and int and 
the wrapper classes Character, Byte, Short, and Integer. It also supports String 
and enumerated types. Finally, it permits var if it can be resolved to one of the previous 
types. Floating-point types like float and double are not supported; therefore, option B 
is correct. Object is also not supported since it could include any class, making option F 
correct as well.
2. E. The code does not compile because parentheses, (), are used instead of braces, {}, mak-
ing option E the correct answer. If the code was fixed to use braces, then option B would be 
the correct answer. The exclusive or (^) of two true values is false. Therefore, gas would 
be true at the end of the first loop and would exit since the loop condition !gas is false.
3. F. When getting this type of question, the best approach is to write down the values of 
the variables. Both start out as 0 on line 10 . On the first iteration of the loop, n becomes 
1, while m remains 0, so the clause in the if statement doesn’t run. In the switch state-
ment, the value of m remains 0, so it matches the first case. Since there is no break, the 
default block is also executed, and n is incremented twice and is now 3 . Finally, m is incre-
mented to 1 .
On the second iteration of the loop, m goes from 1 to 2, and n goes from 3 to 6 . On the third 
iteration, m goes from 2 to 3, and n goes from 6 to 8 . On the fourth iteration m is 3, and 
the continue is executed with only n increasing in value by 1 . This pattern continues with 
the loop never terminating, while n continues to increase by 1 . Since the execution does not 
complete, option F is the correct answer.
4. B,D,E. A for-each loop accepts arrays and classes that implement java.lang.Iterable,  
such as List. For these reasons, options B, D, and E are correct. Option A is incorrect 
because it is a primitive value. Options C and F are incorrect because StringBuilder and 
String do not implement Iterable.
5. C,D. A default statement inside a switch statement is optional and can be placed in any 
order within the switch’s case statements, making options A and B incorrect and option 
C correct. Option D is also correct because a default statement does not take a parameter 
value. Options E and F are incorrect rules about switch statements. 
6. A. A while loop requires a boolean condition. While singer is a variable, it is not a 
boolean. Therefore, the code does not compile, and option A is correct.
7. A,F. A traditional for loop gives you full control over the order of iteration. This means 
you can iterate through the array backward or forward. By contrast, with a for-each loop, 
the iteration order is determined for you. With an array, this means starting with index 0 . 
Options A and F match this scenario.
8. D. This code does not compile because it has two else statements as part of a single if 
statement. Notice that the second if statement is not connected to the last else statement. 
For this reason, option D is the correct answer.
9. A,E. The code compiles as is. Due to the break statement on line 27, the loop executes only 
once. It prints a single x, which means option A is the first correct answer. While the label on 
line 24 is present with lines 25 and 28 removed, it no longer points to a loop. This causes the 
code to not compile, and option E is the other correct answer.
10. A,D. The method prints the elements of the array in the reverse order in which they are 
defined. Option A correctly accomplishes this using a different starting value for the loop. 
Options B and F do not compile, as they do not use the correct syntax in a for-each loop. 
Option C compiles and runs without issue, but prints the items in their natural ordering,  
as opposed to the reverse ordering. Option D is correct, as it increments in positive order 
but reverses the output within the body of the for loop. Finally, option E is incorrect.  
The first element read is circus[circus.length+1], which results in an  
ArrayIndexOut OfBoundsException.
11. C. The first time through the loop, type is 1, and plastic- is output. The break 
statement then terminates the loop, with end bring printed. If the break keyword was 
removed, then this would be an infinite loop because type is not incremented between loop 
executions.
12. F. The code does not compile because the switch statement is missing the case keyword 
for each value. Also, two case values cannot be combined as in 4,5.
13. A. First, determine whether the if statement’s expression is executed. The expression  
8 % 3 evaluates to 2 .  The right-hand side of the expression is evaluated next since + has a 
higher precedence than >. Since 2 > 2 is false, the expression triceratops++ is not 
called. Notice there are no braces, {}, in the if statement. Despite the triceratops–– line 
being indented, it is not part of the if statement. Therefore, triceratops–– is always exe-
cuted, resulting in a value of 2 for triceratops, and making option A the correct answer.
14. F. The value of a case statement must be a constant, a literal value, or a final variable. 
Since red is missing the final attribute, no variable type allows the code to compile, mak-
ing option F the correct answer. If the final modifier was added to the declaration of red, 
then int or var would be correct. The other options use types that are incompatible with 
switch statements or with colorOfRainbow.
15. D. Line 15 does not compile because the post-decrement operator can be applied only to var-
iables, not values. Line 16 also does not compile because the label LOOP is out of scope after 
line 15 .  Finally, line 18 does not compile because trick is declared within the do/while 
loop and out of scope after line 17 .  For these reasons, option D is the correct answer.
16. C. If the code follows the arrow, then it prints each letter once, breaking out of the inner 
loop on every iteration. Since a break without a label applies to the innermost structure, 
break and break numbers are equivalent, and both of these are correct answers.  
Likewise, continue and continue numbers are both equivalent although both wrong 
in this case since they resume operation of the inner loop. That leaves break letters and 
continue letters. In this case, break letters stops the outer loop after printing just 
one letter, so it is incorrect. On the other hand, continue letters exits the inner loop 
and returns control to the outer loop, which is the desired behavior. Since three statements 
are correct, option C is correct.
17. B. The code compiles without issue, so options D and E are incorrect. A var can be used in a 
switch statement, provided the underlying type resolves to a supported switch type. Next, 
notice there are no break statements. Once the matching case statement, 30, is reached, all 
remaining case statements will be executed. The variable eaten is increased by 1, then 2, 
then reduced by 1, resulting in a final value of 2, making option B the correct answer.
18. A,D,F. A while loop and do/while loop both require a boolean expression, making 
options A and D correct and options B and E incorrect. Option C is incorrect because a for-
each statement requires an assignment type and an object to iterate on. Option F is correct 
and shows a traditional for loop with no arguments.
19. C. Option A goes through five indexes on the iterations: 0, 1, 2, 3, and 4. Option B also goes 
through five indexes: 1, 2, 3, 4, and 5 .  Option D goes through five iterations as well, from 0 
to 4 .  However, option C goes through six iterations since the loop condition is at the end of 
the loop. Therefore, it is not like the others, and option C is the correct answer.
20. B. On the first iteration of the loop, stops[++count] evaluates to stops[1], while also 
setting count to 1 .  Since stops[1] is Monroe and it has six characters, the break is 
reached, and the loop stops. For this reason, 1 is printed, making option B correct.
21. C. The statement if(jumps) evaluates to if(0), and since 0 is not a boolean value, the 
code does not compile. Java requires boolean expressions in if statements.
22. B. The initializer, which is alpha, runs first. Then Java checks the condition, which is beta, 
to see whether loop execution should start. Since beta returns false, the loop is never 
entered, and option B is correct.
23. B. On the first iteration of the loop, the if statement executes and prints inflate-. 
Then the loop condition is checked. The variable balloonInflated is true, so the loop 
condition is false, and the loop completes and done is printed.
24. B. Options A and C print one line if numChipmunks is 1, 2, or 3. Option B does not behave 
the same way if numChipmunks is 1 or 2 .  There is no break statement, so the case state-
ments fall through, and more than one statement will be printed.
25. A,C,D. A do/while loop requires a body, making option A correct. Options B and E are 
incorrect, as both types of while loops can be exited early with a return statement. 
Both also require a conditional expression, making option C correct. What distinguishes a 
do/while loop from a while loop is that it executes its body at least once, making option D 
correct and option F incorrect.
26. F. Option A is incorrect because the enum type Season is not used within a case statement. 
If it were just case WINTER:, then it would compile. Options B and C do not compile 
because switch statements do not support multiple values within a case statement. Option 
D is incorrect because -> is used instead of :. Option E is incorrect because FALL is not 
defined in the list of values for the enum Season. Since none of the lines of code is correct, 
option F is correct.
27. B. In a traditional for loop, only one initialization type is allowed to be specified. If more 
than one variable is supplied, then they are separated by a comma. Therefore, options A, C,
and D do not compile. Options B and E both compile, although only option B prints a single 
line at runtime. Option E instead prints two lines since nycTour is of size 3 and times is 
of size 2 .
28. C. The braces on lines 12/27 are required because they comprise the method body. The 
braces on lines 24/26 are required because a switch statement needs braces regardless of 
how many case statements are inside. Finally, the braces on lines 18/21 are required because 
the else has two statements inside.
The braces on lines 14/23, 15/22, and 16/18 are all optional because there is only one state-
ment inside. Since there are three pairs, option C is correct.
29. B. The method prints the elements of the list in the order in which they are defined. Option A 
is incorrect and prints the first element repeatedly. Option B is correct and prints the elements 
using a for-each loop. Options C and E are incorrect because the first element read results in 
an ArrayIndexOutOfBoundsException. Finally, option D is incorrect because the entire 
list is printed each time.
30. D. The code snippet compiles, making options A, B, and C incorrect. Notice that the inner 
for-each loop does not use braces, {}, so the break statement applies to the outer loop only. 
On the first iteration of the outer loop, the inner loop prints 9_1Z0-811 and 9_1Z0-819 . 
Then, the break statement is encountered, and the outer loop is terminated, making option 
D correct. If braces were added around lines 7 and 8, then the code would instead print 
9_1Z0-811, 10_1Z0-811, and 11_1Z0-811, and option E would be correct.
1. F. The program does not compile because Story is marked final, which means it cannot 
be extended by Adventure. If the final modifier were removed, the rest of the code would 
compile and print 93 at runtime.
2. C,F. A class can start with a comment, an optional package statement, or an import 
statement if there is no package statement. It cannot start with a variable definition or 
method declaration, since those cannot be declared outside a type. Therefore, options C and 
F are correct.
3. C,E. An abstract method cannot include the final or private modifier. If a method 
contained either of these modifiers, then no concrete subclass would ever be able to override 
it with an implementation. For these reasons, options A and B are incorrect. Option D is also 
incorrect because the default keyword applies to concrete interface methods, not abstract 
methods. Option F is incorrect because there is no concrete modifier. That leaves options C 
and E as the correct answer. The protected, package-private, and public access modifiers 
can each be applied to abstract methods.
4. C. The code does not compile because of line 5, making option C the correct answer. For this 
question, it helps to understand variable scope. The main() method is static and does not 
have access to any class instance variables. The birds variable is not static and requires 
a class instance variable to access. Therefore, the code does not compile when the static 
method attempts to access a non-static variable without an instance of the class.
5. E. The public access modifier allows access to members in the same class, package, sub-
class, or even classes in other packages, while the private modifier allows access only to 
members in the same class. Therefore, the public access modifier allows access to every-
thing the private access modifier does, and more, making option E the correct answer. 
Options A, B, C, and D are incorrect because the first term is a more restrictive access 
modifier than the second term.
6. F. There is no modifier that can prevent a default method from being overridden in a class 
implementing an interface, making option F correct.
7. B. Notice in this question that main() is not a static method; therefore, it can access 
both class and instance variables. Since there are two class variables and two instance  
variables defined, option B is the correct answer.
8. B,D. Option A is incorrect because new cannot be used to declare a type. Option C is incor-
rect because null is a literal and cannot be used as the name of a class. Options E and F are 
incorrect because a void method cannot return a value. That leaves options B and D as the 
correct answers. Note that 10 can be returned as an int or implicitly promoted to a long, 
without issue.
9. C,E. Options A and B are static methods rather than constructors. Option D is a method 
that happens to have the same name as the class. It is not a constructor because constructors 
don’t have return types. Option C is a valid constructor.
As for the output, the key is that Java uses “pass by value” to send object references to 
methods. Since the Phone reference p was reassigned in the first line of the sendHome() 
method, any changes to the p reference were made to a new object. In other words, no 
changes in the sendHome() method affected the object that was passed in. Therefore, the 
value of size was the same before and after the method call, making the output 3 and 
option E the correct answer.
10. C,F. Options A and E are incorrect because the new keyword before Pterodactyl is 
required to create an instance of the member inner class Pterodactyl using a member 
of the outer class Dinosaur. Option B is incorrect, as this is not a valid way to instantiate 
a member inner class. Option C is correct and relies on the dino instance variable for the 
outer class instance. Option D would be correct if Dino was changed to the correct class 
name, Dinosaur. Finally, option F is correct and relies on the fact that roar() is an  
instance method, which means there’s an implicit instance of the outer class Dinosaur  
available. The Dinosaur. prefix is optional, though.
11. C. Both objects are instances of the class Laptop. This means the overridden startup() 
method in the Laptop class gets called both times thanks to polymorphism, making option 
C correct.
12. E. In Java, the lack of an access modifier indicates that the member is package-private; there-
fore, option E is correct. Note that the default keyword is used for interfaces, annotations, 
and switch statements, and is not an access modifier.
13. E. A static initializer is not allowed inside a method. It should go on the class level rather 
than the method level. Therefore, the code does not compile, and option E is correct.
14. B,D,F. Option A is incorrect as methods cannot be marked final within an interface.  
Interfaces support static methods that are marked public or private, making options 
B and D correct and option E incorrect. Option F is correct and lack of access modifier 
makes the method implicitly public, not package-private, making option C incorrect.
15. B. A static nested class cannot access instance members of the enclosing class, making option 
B correct. The rest of the options form true statements.
16. E. The first woof() method does not compile because bark is a primitive, not an object, 
and does not have a toString() method. The main() method also does not com-
pile because it is static and all of the woof() methods require an instance of Canine. 
Since these two lines do not compile, option E is the correct answer. If the toString() 
was removed from the first method and all of the methods were marked static, then the 
program would print 15 at runtime.
17. C. A local variable is effectively final when its primitive value or object reference does not 
change after it is initialized, making option C the correct answer. Note that option D is incor-
rect because any change to the variable after it is initialized disqualifies it for being consid-
ered effectively final.
18. C. The sell() method is declared final in the Vegetable class. The Turnip class 
then attempts to override this method, resulting in a compilation error, making option C the 
correct answer.
19. D. The case statements incorrectly use the enum name as well as the value, such as  
DaysOff.ValentinesDay. Since the type of the enum is determined by the value of the 
variable in the switch statement, the enum name is not allowed and causes a compila-
tion error when used. For this reason, option D is correct. If the enum name DaysOff was 
removed, the application would output 12, since the lack of any break statements causes 
multiple blocks to be reached, and option C would have been the correct answer.
20. B,E. There is no that keyword, so options A and D are incorrect. Option B is correct, 
as this can access all members declared within the class. Option C is incorrect, as only 
inherited members can be accessed. For example, private members declared in a parent 
class cannot be accessed using super. Option E is correct, as this allows access to mem-
bers declared in the class and those inherited from a parent. Finally, option F is incorrect, as 
static methods do not have access to this or super references.
21. D. A class can implement an interface, not extend it, ruling out options A, B, and C. Classes 
do extend an abstract class, ruling out option F . Finally, an interface can only extend 
another interface, making option D the correct answer.
22. B. Three instances of Chicken are created on lines 8–10. On line 11, the value of eggs  
in the first two instances is set to 2, while the third instance has a value of 3 . On line 12,  
the original instance that was pointed to by c1 (with an eggs value of 2) is dereferenced  
and eligible for garbage collection. The c1 and c2 variables now both point to the same  
instance with an egg value of 2 . Finally, on line 13, the eggs value for c3 is changed from 
3 to null.
23. C. Java does not allow multiple inheritance, so having one class implement two interfaces 
that both define the same default method signature leads to a compiler error, unless  
the class overrides the method. In this case, the talk(String...) method defined in the 
Performance class is an overloaded method, not an overridden one, because the  signatures 
do not match. Therefore, the Performance class does not compile, making option 
C correct.
24. C. A functional interface must contain exactly one abstract method. The Bend interface 
contains two abstract methods, pump() and bend(), since it extends Pump and inherits 
pump(). For this reason, the Bend interface is not a valid functional interface and therefore 
cannot be used as a lambda expression, making option C the correct answer. The rest of the 
code compiles without issue. Note that the usage of an instance variable to call a static 
method, r.apply() in the main() method, is permitted but discouraged.
25. B. If the variables are public, the class is not encapsulated because callers have direct access 
to them. This rules out options C and D . Having private methods doesn’t allow the callers 
to use the data, making option A an undesirable answer. Option B is correct and the classic 
definition of encapsulation where the data is not exposed directly.
26. A. Package-private allows access by code within the same package, while the private 
modifier allows access only to members in the same class. This makes option A the correct 
answer. Options B, C, and D are incorrect because the first term is a more restrictive access 
modifier than the second term.
27. C. The stroke() method is static, which means it cannot access the instance method 
breath() on line k2, making option C correct.
28. D. The Hammer class is a subclass of the Tool class. The repair() method can be declared 
in the Hammer subclass with a different return type because the parent method is not inher-
ited. For these reasons, options A and C are incorrect. On the other hand, the use() method 
is package-private in Tool, with the overridden version in Hammer reducing the visibility to 
private. This is an invalid override, making option D correct. The rest of the lines compile 
without issue.
29. E. Methods cannot be both abstract and final, making option A incorrect. Abstract 
interface methods are always public, making option C incorrect. Finally, interface and 
void are not modifiers on a method, making options B and D incorrect. Therefore, option E 
is the answer.
30. A. While both objects are instances of Bush, we are not calling methods in this example. 
Virtual method invocation works only for methods, not instance variables. For instance var-
iables, Java looks at the type of the reference and calls the appropriate variable based on the 
reference. Based on the reference types of the three variables (Plant, Bush, Plant), option 
A is correct.
31. A,F. An instance variable can be referenced only from instance methods in the class, making 
option A correct. A static variable can be referenced from any method. Therefore, option 
F is correct.
32. D. Java classes are defined in this order: package statement, import statements, class dec-
laration. That makes option D the only correct answer. Note that not all of these statements 
are required. For example, a class may not have a package statement, but if it does, it must 
come first in the file.
33. A, C, E. The code does compile as is, making option A correct. Removing line 2 would cause 
a compiler error in the main() method since the enum inside Chick is not referenced. 
This makes option C the next answer. Finally, option E is the final answer because an enum 
cannot be defined in a non-static inner class. Only top-level types and static nested 
classes can define static members other than static constants, and enums are implic-
itly static.
34. B,F. A static method can access static variables, but not instance variables. The  
getNumRakes() method does not compile, so option B is correct.
The main() method calls the constructor, which outputs a. Then the main method calls the 
run() method. The run() method calls the constructor again, which outputs a again. Then 
the run() method calls the Sand() method, which happens to have the same name as the 
constructor. This outputs b. Therefore, option F is correct.
35. C. While an anonymous class can extend another class or implement an interface, it cannot 
be declared final or abstract since it has no class definition. For this reason, option C 
is correct. The other classes may be declared final or abstract since they have a class 
definition.
36. C,E,F. The public access modifier is the broadest, making options E and F correct. Pack-
age-private access limits references to those in the same package. The protected access 
modifier adds on subclass access, making option C correct.
37. B. Java does not allow multiple variables to be declared in the same statement using local 
variable type inference. Lines x2 and x3 both have compiler errors. Since the question asks 
about the first line with a compiler error, option B is the answer.
38. E. All four members of the Telephone interface are implicitly public, making option E 
correct. Only private and private static interface methods are not public, and they 
must be explicitly marked private.
39. C. The new keyword is used to call the constructor for a class and instantiate an instance 
of the class, making option C correct. A primitive cannot be created using the new keyword, 
so option B is incorrect. Dealing with references happens after the object created by new is 
returned. The other options are invalid.
40. B. From within a method, an array or varargs parameter is treated the same. However, there 
is a difference from the caller’s point of view. A varargs parameter can receive either an array 
or individual values, making line 19 and 20 compile. However, an array parameter can take 
only an array, which permits line 23 but prevents line 22 from compiling. Both lines 21 and
24 compile because null can be passed to a method taking an array or a varargs. Since there 
is only one line that doesn’t compile, option B is the answer.
41. A,C,F. Both abstract classes and interfaces can include static methods, so options A and 
C are correct. Of all the nested class types, only static nested classes can include static 
methods, making option F correct, and options B, D, and E incorrect.
42. E. This code is already a functional interface and compiles without any changes. The Play 
interface has a single abstract method: fun(). The other methods have a method body, 
which shows they are not abstract.
43. F. Both of these descriptions refer to variable and static method hiding, respectively, mak-
ing option F correct. Only instance methods can be overridden, making options A and B 
incorrect. Options C, D, and E are also incorrect because replacing and masking are not real 
terms in this context.
44. F. This class is a good example of encapsulation. It has a private instance variable and 
is accessed by a public method. No changes are needed to encapsulate it, and option F 
is correct.
45. B,D. Option A is incorrect because static methods cannot call instance methods directly. 
Options B and D are correct and are the primary reasons to create a static interface 
method. Options C and E are incorrect and describe attributes of a default method. 
Option F applies only to private static interface methods, not public ones.
46. C. The Bottle class includes a static nested class Ship that must be instantiated in a 
static manner. Line w2 uses an instance of Bottle to instantiate the Ship. Therefore, line 
w2 does not compile, and option C is the correct answer. Note that if Ship were changed to 
be a member inner class, the code would still not compile since a member inner class cannot 
include static members and enums are inherently static.
47. E. The instance variables, constructor, instance and static initializers, and method declara-
tions can appear in any order within a class declaration.
48. A. First, all of the lines compile, but they produce various different results. Remember that 
the default initialization of a boolean instance variable is false, so outside is false at 
line p1 .  Therefore, this(4) will cause rope to be set to 5, while this(5) will cause rope 
to be set to 6 .  Since 5 is the number we are looking for, option A is correct, and option C 
is incorrect. Option B is incorrect. While the statement does create a new instance of Jump, 
with rope having a value of 5, that instance is nested, and the value of rope does not affect 
the surrounding instance of Jump that the constructor was called in. Option D is also 
incorrect. The value assigned to rope is 4, not the target 5 .  Options E and F do not compile 
because the superclass is Object, which does not have a constructor taking an int.
49. B,E. Option A is true because encapsulation improves security because instance variables 
cannot be accessed directly. Implementing encapsulation prevents internal attributes of a class 
from being modified directly, so option D is a true statement. By preventing access to internal 
attributes, we can also maintain class data integrity between elements, making option C a 
true statement. Option F is also a true statement about encapsulation, since well-encapsulated 
classes are often easier to use. Option B is an incorrect statement. Encapsulation makes
no guarantees about performance and concurrency. Option E is also an incorrect statement 
because it describes immutability.
50. B,D. Line u2 does not compile because getPartner() is overridden with a return type 
that is not covariant, as Follower is not the same type nor a subtype of the Leader class. 
Line u4 also does not compile because SwingDancer is marked abstract and cannot be 
instantiated directly. For these reasons, options B and D are the correct answers. The rest of 
the code compiles without issue.
51. C. Option A is allowed because the turnOn() method is public and can be called from 
anywhere. Options B and D are allowed since the method is in the same class, which is 
always allowed! Option C is not allowed because wash() is a package-private method in 
another package. Option C is the correct answer.
52. C. The display() method has protected access. This means it can be accessed by in-
stance methods in the same package and any subclasses. There are no subclasses in this 
example, so we only need to count the classes in the same package. Option C is correct 
because Flashlight and Phone are in the package.
53. B,D. While Java does not allow a class to extend more than one class, it does allow a class 
to implement any number of interfaces. Multiple inheritance is, therefore, only allowed via 
interfaces, making option B correct. Interfaces can extend other interfaces, making option D 
the other answer.
54. B. The Dress type is declared as a class, not an interface. For this reason, it cannot 
contain the default method getSize(), making option B correct. The rest of the methods 
compile within the class declaration without issue.
55. E. The main() method attempts to define an anonymous class instance but fails to provide 
the class or interface name, or use the new keyword. The right-hand side of the assignment 
to the seaTurtle variable should start with new CanSwim(). For this reason, option E is 
the correct answer. If the code was corrected with the proper declaration, then the program 
would output 7 at runtime.
56. E. The Puppy class does not declare a constructor, so the default no-argument constructor is 
automatically inserted by the compiler. What looks like a constructor in the class is actually 
a method that has a return type of void. Therefore, the line in the main() method to create 
the new Puppy(2) object does not compile, since there is no constructor capable of taking 
an int value, making option E the correct answer.
57. B. The method signature has package-private, or default, access; therefore, it is accessible to 
classes in the same package, making option B the correct answer.
58. D. First, both CanBurrow and HasHardShell compile as functional interfaces since  
they contain exactly one abstract method, although only the latter uses the optional  
@FunctionalInterface annotation. The declarations of these two interfaces, along with 
the abstract class Tortoise, compile without issue, making options A, B, and C incor-
rect. The class DesertTortoise inherits two abstract methods, one from the interface 
CanBurrow and the other from the abstract parent class Tortoise. Since the class 
implements only one of them and the class is concrete, the class declaration of  
Desert Tortoise fails to compile, making option D the correct answer.
59. C. The interface declarations compile without issue. When inheriting two default methods 
with the same signature, the Tower class is required to override both methods even if the 
class is marked abstract. For this reason, line m3 is the first line that does not compile, and 
option C is correct. Note that there is no possible overridden method that can fulfill both 
inherited default methods since the return types are not covariant.
60. D. The height variable is declared within the if-then statement block. Therefore, it 
cannot be referenced outside the if statement, and the code does not compile.
61. A,E,F. Java supports three types of comments: single-line (//), multiline (/* */), and  
Javadoc (/** **/), making options A, E, and F correct. The other options may be com-
ments in other languages, but not in Java.
62. A,C,F. An abstract method is one that will be implemented by a subclass. For this reason, 
it cannot be combined with final or private, as both prevent a method from being over-
ridden, making options B and D incorrect. An abstract method can also not be marked 
static, since static members belong to the class level, not an instance, making option 
E incorrect. Options A, C, and F are the correct answers. Note that marking a private 
method final has no practical implication, although it is allowed.
63. E. The class data, stuff, is declared public, allowing any class to modify the stuff vari-
able and making the implementation inherently unsafe for encapsulation. Therefore, there are 
no values that can be placed in the two blanks to ensure the class properly encapsulates its 
data, making option E correct. Note that if stuff were declared private, options A, B, C, 
and D would all be correct. Encapsulation does not require any specific method names, just 
that the internal attributes are protected from outside access, which all of these sets of values 
do achieve.
64. C. The second row is incorrect, as private methods belong to an instance, not the class. 
The fourth row is also incorrect, as default methods require a method body. The rest of the 
rows are correct, making option C correct.
65. D. The super() statement is used to call a constructor in the parent class, while super is 
used to reference a member of the parent class. The this() statement is used to call a con-
structor in the current class, while this is used to reference a member of the current class. 
For these reasons, option D is the correct answer.
66. B. Line 15 calls the method on line 9 since it is a Watch object. That returns watch, making 
option A incorrect. Line 16 calls the method on line 3 since it is a SmartWatch object and 
the method is properly overridden. That returns smart watch, so option B is the answer, 
and option C is incorrect.
67. F. The Cinema class defines a constructor that takes a String value, which means the com-
piler does not insert the default no-argument constructor. Therefore, it is not available in the 
Movie constructor, and an explicit constructor must be called with super(). Since this is 
not done, the Movie constructor does not compile, making option F the correct answer. The 
rest of the code compiles without issue.
68. A,D,E. A final instance must be assigned a value (exactly once) on the line it is declared, in 
an instance initializer, or in a constructor. This makes options A, D, and E correct.
69. C. This example deals with method signatures rather than polymorphism. Since the hop() 
methods are static, the precise method called depends on the reference type rather than 
the actual type of the object. Since the first reference is Rabbit, the first value printed is 
hop. The second reference actually is FlemishRabbit, so HOP is printed, and option C is 
the answer.
70. A. If the program is called with a single input south, then south would be printed at run-
time. If the program is called with no input, then the compass array would be of size zero 
and an ArrayIndexOutOfBoundsException would be thrown at runtime. Finally, if the 
program is called with a string that does not match one of the values in Direction, then an 
IllegalArgumentException would be thrown at runtime. The only result not possible is 
WEST, since the enum value is in lowercase, making option A the correct answer.
71. C. Encapsulation doesn’t allow callers access to the instance variables, which makes it easier 
to change the code. The instance variables can be any type, which means they can be mutable 
or immutable. There are not constraints on the implementation of methods. The purpose of 
encapsulation is to lessen how tightly tied or coupled the classes are. Option C is the opposite 
of this, making it the answer.
72. C. A class cannot contain two methods with the same method signature, even if one is 
static and the other is not. Therefore, the code does not compile because the two declara-
tions of playMusic() conflict with one another, making option C the correct answer.
73. A,E,F. First, the return types of an overridden method must be covariant, making option A 
correct. They can be the same, but it is not required, making option C incorrect. Next, the 
access modifier must be the same or broader in the child method, making option B incorrect 
and option F correct. Option D is incorrect as an overridden method is not required to throw 
a checked exception declared in the parent version of the method. If it does declare a checked 
exception, it cannot be new or broader than the ones declared in the superclass, making 
option E correct.
74. D. A private non-static interface method may only be accessed from other private 
or default methods declared within the interface. Lines 15 and 21 do not compile because 
the private method is called within static methods. Line 26 does not compile because 
a private interface method cannot be called in a method outside the interface declaration. 
Since these three lines do not compile, option D is correct.
75. B. Interface variables are implicitly public, static, and final. Variables cannot be 
declared as abstract in interfaces, nor in classes. Therefore, option B is the answer.
76. B. Integer is the name of a class in Java. While it is bad practice to use the name of a class 
as your local variable name, this is legal. Therefore, k1 does compile. It is not legal to use a 
reserved word as a variable name. All of the primitives including int are reserved words. 
Therefore, k2 does not compile, and option B is the answer. Lines k4 and k5 don’t compile 
either, but the question asks about the first line to not compile.
77. C. The code compiles and runs without issue, so options A and B are incorrect. The question 
relies on your ability to understand variable scope. The variable today has local scope to 
the method in which it is executed. The variable tomorrow is re-declared in the method, but 
the reference used on line y is to the instance variable with a value of 10 .  Finally, the variable
yesterday is static. While using an instance reference to access a static variable is not 
recommended, it does not prevent the variable from being read. The result is line y evaluates 
and prints 31 (20 + 10 + 1), making option C the correct answer.
78. E. If an enum contains anything other than a list of values, then a semicolon (;) must follow 
the list of values. The Snow enum includes a method, so there must be a semicolon after the 
last value, FLURRY. For this reason, the code does not compile, and option E is correct.  
If the semicolon was added, then the code would compile and print 0 Sunny at runtime, 
with the overridden toString() replacing the default value of FLURRY.
79. A. Option A is the correct answer because the first line of a constructor could be this() or 
super(), making it an untrue statement. Option B is a true statement because the compiler 
will insert the default no-argument constructor if one is not defined. Option C is also a true 
statement, since zero or more arguments may be passed to the parent constructor, if the  
parent class defines such constructors. Option D is also true. The value of a final instance 
variable must be set when it is declared, in an initialization block, or in a constructor.
80. E. If only the com.mammal class needed access, option A would be correct. Access modifiers 
cannot be used to grant access to a list of packages. The Java Platform Module Framework 
can do this, but it is not an option in this question. Therefore, option E is correct.
81. E. The code does not compile because super.height is not visible in the Rocket class, 
making option E the correct answer. Even though the Rocket class defines a height value, 
the super keyword looks for an inherited version. Since there are none, the code does not 
compile. Note that super.getWeight() returns 3 from the variable in the parent class, as 
polymorphism and overriding do not apply to instance variables.
82. B,E. The key here is understanding which of these features of Java allow one developer to 
build their application around another developer’s code, even if that code is not ready yet. 
For this problem, an interface is the best choice. If the two teams agree on a common inter-
face, one developer can write code that uses the interface, while another developer writes 
code that implements the interface. Assuming neither team changes the interface, the code 
can be easily integrated once both teams are done. For these reasons, option B is correct. 
Interfaces expose methods using the public keyword, making option E the other answer.
83. F. The code compiles, even if the blank is replaced with a constant value, making option E 
incorrect. Note that the class correctly overrides both inherited default methods. While it 
is possible to call a specific inherited default method, even when it has been overridden, it 
requires calling super, which is not accessible from a static method. For these reasons, 
options A, B, C, and D do not work, making option F correct.
84. B. An enum declaration itself cannot be marked abstract, nor can any of its values, but 
its methods can be marked abstract, making option B the correct answer. Note that if an 
enum contains an abstract method, then every enum value must include an override of this 
abstract method.
85. C. The static initializer is run only once. The static method is run twice since it is called 
twice. Therefore, three lines are printed, and option C is correct. The instance initializer block 
is never run because the Cars class is never constructed.
86. C. Dot notation is used for both reading and writing instance variables, assuming they are in 
scope. It cannot be used for referencing local variables, making option C the correct answer. 
It is possible that bar is a static variable, although accessing it in this manner is not 
recommended.
87. A,D,E. The reference type of unknownBunny must be Bunny or a supertype of Bunny, 
including any abstract classes, concrete classes, or interfaces that Bunny inherits. For this 
reason, options A and E are correct, and option C is incorrect. Option B is incorrect. Since it 
already points to an instance of Bunny, casting it to a Bunny reference is allowed. Option 
D is trivially true. If the reference types of both are the same, then they can call the same in-
stance members. Option F is incorrect, as casting is required to access members declared in 
Bunny that are not defined in Object.
88. C,E. Methods marked private or static are never inherited, so options A, B, and D are 
incorrect. Interface methods cannot be final, so option F is incorrect. That leaves default 
and abstract methods, which are both inherited by classes implementing the interface.
89. C. The code does compile, so option E is incorrect. A functional interface is required to have 
exactly one abstract method. In both interfaces, that is roar(). The toString() and 
hashCode() method signatures match those from Object. Since they are provided to all 
subclasses, they are not considered abstract. Since roar() is the only abstract method, 
both are functional interfaces, making option C the answer.
90. C,E. To call a constructor, you must use the new keyword, making option E correct. It 
cannot be called as if it was a normal method. This rules out options A and B .  Further, option 
D is incorrect because the parentheses are required. Option C is also correct, as var may be 
used as a variable name.
91. C. To a call an instance method, you can use the this prefix. The class name is not included, 
ruling out the last three methods. A method may contain at most one varargs parameter, and 
it must appear as the last argument in the list. For this reason, the sing_do() method is the 
only method using varargs that compiles. The sing() method also compiles without using 
varargs. Therefore, option C is the answer.
92. B. The code compiles without issue. The first print() statement refers to level declared 
in the Deeper class, so 5 is printed. The second and third print() statements actually refer 
to the same value in the Deep class, so 2 is printed twice. The prefix Matrix. is unnecessary 
in the first of the two print() statements and does not change the result. For these reasons, 
option B is the correct answer.
93. A. The play() method is overridden in Violin for both MusicCreator and  
StringInstrument, so the return type must be covariant with both. Long is a subclass of 
Number, and therefore, it is covariant with the version in MusicCreator. Since it matches the 
type in StringInstrument, it can be inserted into the blank, and the code would compile.
While Integer is a subclass of Number, meaning the override for MusicCreator is valid, 
it is not a subclass of Long used in StringInstrument. Therefore, using Integer would 
cause the code to not compile.
Finally, Number is compatible with the version of the method in MusicCreator but not 
with the version in StringInstrument, because Number is a superclass of Long, not a 
subclass. For these reasons, Long is the only class that allows the code to compile, making 
option A the correct answer.
94. E. The IsoRightTriangle class is abstract; therefore, it cannot be instantiated on line 
g3 .  If the abstract modifier was removed from the IsoRightTraingle declaration, 
then the rest of the code would compile and print irt at runtime.
95. F. The private static method wagTail()attempts to access an instance-based 
default method chaseTail(), which results in a compiler error, making option F 
correct. While buryBone() is not used, it does not result in a compiler error, making 
option D incorrect. Overridden methods are permitted to declare new unchecked excep-
tions, and since IllegalArgumentException is unchecked, the override is allowed, 
making option E incorrect.
96. B,C,D. Enumerated types support creating a set of reusable values whose values are fixed 
and consistent across the entire application. For these reasons, options B and D are correct, 
and option F is incorrect. Option C is also correct, as it provides callers of a method with a 
list of acceptable values. Finally, options A and E are incorrect. Using an enum does not, by 
itself, improve performance or support concurrency.
97. E. While you can suggest to the JVM that it might want to run a garbage collection cycle, 
the JVM is free to ignore your suggestion. Option B is how to make this suggestion. Since 
garbage collection is not guaranteed to run, option E is correct.
98. D. The access modifier of strength is protected, meaning subclasses and classes within 
the same package can modify it. Changing the value to private would improve encapsu-
lation by making the Protect class the only one capable of directly modifying it. For these 
reasons, option D is correct.
99. A,D. A lambda can reference any instance variable, static variable, or lambda param-
eter that is in scope, making option A correct. Lambdas require local variables and method 
parameters to be effectively final in order to use them, making option D the other correct 
answer.
100. E. A static import is used to import static members of another class. In this case, the 
withdrawal() and deposit() methods in the Bank class are not marked static. 
They require an instance of Bank to be used and cannot be imported as static methods. 
Therefore, option E is correct. If the two methods in the Bank class were marked static, 
then option A would be the correct answer since wildcards can be used with static 
imports to import more than one method. Options C and D reverse the keywords static 
and import, while option B incorrectly imports a class, which cannot be imported via a 
static import.
101. A,C,E. Option A returns true since Coral inherits Friendly from its superclass 
Animal. Option B is false, as using null with the instanceof operator always returns 
false. Options C and E both return true because all classes inherit Object, even those 
that don’t explicitly extend it. Option D is false because Fish does not inherit the 
Friendly interface. Finally, option F does not compile as Dolphin is abstract and cannot 
be instantiated directly. If it was not marked abstract, then it would return true. 
102. B. While it is not recommended to change the value of an enum after it is created, it is 
legal. Each enum value has its own copy of numDays. This means the setter changes it for 
CHICKEN, but not for PENGUIN. Therefore, option B is correct. Both calls on CHICKEN 
print the updated value of 20, while PENGUIN retains the original 75 .
103. B. Line 3 does not compile, as a method with a body within an interface must be explicitly
marked static, default, or private, making option B correct. The rest of the lines
compile without issue. For this question, it helps to remember which implicit modifiers
the compiler will insert, and which it will not. On line 2, the compiler will insert public
static final automatically, and on lines 4 and 6, the compiler will insert public automatically.
The compiler will also insert abstract on line 4 since the method does not
declare a body.
104. E. The type of the variable in the switch statement is the enum Currency, but the case 
statements use int values. While the enum class hierarchy does support an ordinal() 
method, which returns an int value, the enum values cannot be compared directly with 
int values. For this reason, the Bank class does not compile, making option E the correct 
answer.
105. D. Lines 3 and 4 do not compile because the returned values of double and long are not 
compatible with int. Lines 6 through 8 compile without issue, since each method takes 
a different set of input arguments. The first line of the main() method does not compile 
either, making option D correct. The no-argument version of the nested() method does 
not return a value, and trying to output a void return type in the print() method doesn’t 
compile.
106. B. A class can trivially be assigned to a superclass reference variable but requires an explicit
 cast to be assigned to a subclass reference variable. For these reasons, option B is correct.
107. D. A functional interface may have any number of static, default, private static, 
or private methods. It can have only one qualified abstract method, though, making 
option D correct.
108. D. This class has poor encapsulation since the age variable is public. This means that a 
developer could modify the body of main() to change the value of mandrill.age to any 
integer value, and option D is correct.
109. C. All three references point to the String object "lion". This makes the other two 
String objects eligible for garbage collection and makes option C correct.
110. B,F. A functional interface has exactly one abstract method. This includes inherited 
methods. If Panther has a single abstract method, Cub is a functional interface if it 
does not add any more abstract methods. This matches option B . However, if Panther 
has two abstract methods, there is no code in Cub that can make it a functional inter-
face, and option F is the other answer.
111. A,C. A local class can access final or effectively final local variables, making options A 
and C the correct answer. Local variables cannot be marked private or static, making 
options B and D incorrect. Options E and F are also incorrect, as those are not valid vari-
able modifiers.
112. B. When the main() method instantiates the object, line 2 first runs and sets the variable 
using the declaration. Then the instance initializer on line 6 runs. Finally, the constructor 
runs. Since the constructor is the last to run of the three, that is the value that is set when 
we print the result, so option B is correct.
113. C. An abstract method cannot define a body, meaning the declaration of  
getNumberOfRings() is invalid and option C is correct. The rest of the code compiles 
without issue. While the compiler will prevent cycles within overloaded constructors, it does 
not do so for methods, meaning option F is incorrect.
114. B,F. The type is determined based on the value at initialization. It cannot be null at that 
point, but the variable can be assigned as null later, making option B correct. Both primi-
tives and objects can be used with var, making option F correct.
115. A. The protected modifier allows access by any subclass or class that is in the same 
package; therefore, option A is the correct answer.
116. C. The main() method defines a local class Oak that correctly extends Tree, a static 
nested class. The method getWater() is not permitted to read the local variable water, 
though, since it is not final or effectively final, making option C correct. If the last line of 
the method was removed, though, then the program would compile and print 8 .
117. B,D. A class can implement multiple interfaces, making option B correct. An interface can 
extend multiple interfaces, making option D correct as well.
118. D. The method looks like a setter or mutator method. However, it is incorrectly imple-
mented since the method is missing a this reference and doesn’t actually change the value. 
Therefore, option D is correct.
119. A,C,F. Option A is correct and option B is incorrect because this() calls another con-
structor in the same class. Option C is correct because this() without parameters is the 
default constructor and is not inserted automatically by the compiler if another constructor 
is present. Options D and E are both incorrect because only one of super() or this() 
can be used from the same constructor. Finally, option F is correct as super() or this() 
must come first.
120. E. The code compiles and runs without issue, so option A is incorrect. The question 
involves understanding the value and scope of each variable at the print() statement. 
The variables feet and tracks are locally scoped and set to 4 and 15, respectively, 
ignoring the value of tracks of 5 in the instance of the class. Finally, the static variable 
s.wheels has a value of 1 .  The result is that the combined value is 20, making option E 
the correct answer.
121. C,F. Line m3 does not compile because isDanger() is an invalid method override. An 
overridden method may not throw a broader checked exception than it inherits. Since 
Exception is a superclass of Problem, the code does not compile, and option C is 
correct. Line m6 does not compile because the return type of isDanger() is void, which 
cannot be assigned to a variable, making option F also correct.
122. C,E,F. Top-level classes can be set only with public and package-private access, making 
option A incorrect. On the other hand, member inner classes can be set with any of the four 
access levels, making option D incorrect. Both types of classes can be declared with final 
or abstract modifier, making option B incorrect and option F correct. Both can also 
include constructors, making option C correct. Finally, option E is correct and one of the 
primary features of inner classes.
123. A. Option A is the only correct answer as a class declaration is the only required com-
ponent in a Java class file. Note that we said a Java class file here; Java also allows inter-
faces, annotations, modules, and enums to be defined in a file. A class file may have a single 
package statement or any number of import statements. Neither is required.
124. B. On line 9, all three objects have references. The elena and zoe objects have a direct 
reference. The janeice object is referenced through the elena object. On line 10, the ref-
erence to the janeice object is replaced by a reference to the zoe object. Therefore, the 
janeice object is eligible to be garbage collected, and option B is correct.
125. D. Both the Drive and Hover interfaces define a default method getSpeed() with 
the same signature. The class Car implements both interfaces, which means it inherits 
both default methods. Since the compiler does not know which one to choose, the Car 
class must override the default method. Since it does not, the code does not compile, 
and option D is correct. Note that the RaceCar class does properly override the default 
method, the problem is with the Car class.
126. C,D. On line 10, we are passing a float. Since there is no exact match, Java attempts 
promotion of the primitive type to double, before trying to wrap it as a Float, mak-
ing option D correct. On line 11, the value 2 is first cast to a byte. It is then increased 
by one using the addition + operator. The addition + operator automatically promotes all 
byte and short values to int. Therefore, the value passed to choose() in the main() 
method is an int. The choose(int) method is called, returning 5 and making option 
C the correct answer. Note that without the addition operation in the main() method, 
byte would have been used as the parameter to the choose() method, causing the 
choose(short) to be selected as the next closest type and outputting 2, making option A 
the correct answer.
127. C,F. An interface can be extended by another interface and a class can be extended by 
another class. This makes the second part of options A, D, and E incorrect. Among nested 
classes, all types can be extended except an anonymous class since it does not declare a class 
name, making option F correct and both parts of option B incorrect. Option C is correct 
because an enum cannot be extended.
128. D. Line 3 does not compile because printColor() is marked final and cannot be over-
ridden. Line 5 does not compile because the method toSpectrum() is marked abstract 
and must be overridden by each enum value. Finally, line 6 does not compile because enum 
constructors are implicitly private. For these three reasons, option D is correct.
129. E. The override of getEqualSides() in Square is invalid. A static method cannot 
override a non-static method and vice versa. For this reason, option E is the correct 
answer. The rest of the lines compile without issue. If the static modifier were added to 
the method declaration on line x2, then the code would print 4 at runtime.
130. A. Since only one package needs access and it is the same package the class is in, option A 
is correct.
131. D. A concrete class is not allowed to have abstract methods, but the other two types are. 
This makes the second row in the first column incorrect. All three types are allowed to have 
static final constants, making the whole second column correct. In the last column,
there are two errors. An abstract class can have a constructor, but an interface cannot. 
Note that an abstract class cannot be instantiated. Instead, it requires a subclass. This 
gives us a total of three incorrect cells, making option D the answer.
132. B,C,E. A functional interface must have exactly one abstract method, which is option B.
There are no restrictions on the number of private or static methods, which make options C
and E also correct.
133. D. Only local variables have such a small scope, making option D the correct answer.
134. C. The code contains a compilation error in regard to the contents instance variable. The 
contents instance variable is marked final, but there is a setContents() instance 
method that can change the value of the variable. Since these two are incompatible, the code 
does not compile, and option C is correct. If the final modifier were removed from the 
contents variable declaration, then the expected output would be of the form shown in 
option A .
135. B,E. One of the motivations for adding default interface methods to Java was for 
backward compatibility. These methods allow developers to update older classes with a 
newer version of an interface without breaking functionality in the existing classes, making 
option B correct. Option E is also correct, as classes implementing the interface can share 
common methods. Option A is incorrect, as interface methods can already be overloaded. 
Option C is incorrect because methods in interfaces cannot be marked final. Option D 
sounds plausible, but could be accomplished with static interface methods alone. Option 
F is incorrect as that statement only applies to private interface methods.
136. D. The method fly() defined in CanFly defines an implementation, an empty {}, 
meaning it cannot be assumed to be abstract; therefore, the code does not compile.
Next, the implementation of fly(int speed) in the Bird class also does not compile, 
but not because of the signature. The method body fails to return an int value.
Finally, the Eagle class does not compile because it extends the Bird class, which is marked 
final and, therefore, cannot be extended. For these three reasons, option D is the correct 
answer.
137. B. Options A, C, and D are true statements. Option A is correct because public allows any 
class to access it. Option C is true because protected access also provides package-private 
access. Option D allows us to write the equals() methods between two objects that com-
pare private attributes of the class. Option B is false. Package-private attributes are visible 
only if the two classes are in the same package, regardless of whether one extends the other.
138. D. This example deals with polymorphism since the methods are being called on the object 
instance. Since both objects are of type FlemishRabbit, HOP is printed twice, and option 
D is the correct answer.
139. B,D,E. Class names follow the same requirements as other identifiers. Underscores (_) and 
dollar signs ($) are allowed, but no other symbols are allowed, making option C incorrect. 
Since Java 9, a single underscore is not permitted as an identifier, making option A incorrect. 
Numbers are allowed, but not as the first character. Therefore, option F is incorrect. The rest 
of the options are valid class names, making the answer options B, D, and E correct. Note 
that class names begin with an uppercase letter by convention, but this is not a requirement.
140. A. The code compiles without issue. Java allows methods to be overridden, but not vari-
ables. Therefore, marking them final does not prevent them from being reimplemented in 
a subclass. Furthermore, polymorphism does not apply in the same way it would to methods 
as it does to variables. In particular, the reference type determines the version of the secret 
variable that is selected, making the output  2 .0 and option A the correct answer. 
141. C. To solve this problem, it helps to remember that Java is a pass-by-value language in which 
copies of primitives and object references are sent to methods. This also means that an object’s 
data can be modified within a method and shared with the caller, but not the reference to 
the object. Any changes to the object’s reference within the method are not carried over to 
the caller. In the slalom() method, the Ski object is updated with an age value of 18. 
Although the last line of the slalom() method changes the variable value to null, it does 
not affect the mySkier object or reference in the main() method. Therefore, the mySkier 
object is not null, and the age variable is set to 18, making options A and D incorrect.
Next, the name variable is reassigned to the Wendy object, but this does not change the 
reference in the main() method, so myName remains Rosie. Finally, the speed array is 
assigned a new object and updated. Since the array is updated after the reference is reas-
signed, it does not affect the mySpeed array in the main() method. The result is that 
mySpeed continues to have a single element with the default int value of 0 .  For these  
reasons, option B is incorrect, and option C is correct.
142. C. The Penguin class includes a member inner class Chick. Member inner classes can 
only include static variables if they are marked final. Since the variable volume is not 
marked final, the Chick does not compile, making option C correct. Note that the vari-
able volume referenced in the chick() method is one defined in the Penguin outer class. 
If the final modifier was added to the volume variable in the Chick class, then the rest 
of the code would compile, printing Honk(1)! at runtime.
143. F. An anonymous class can implement a single interface, and a top-level class can implement 
any number of interfaces. Since a functional interface is an interface with additional rules, 
both anonymous class and top-level class are correct. Additionally, a lambda expression can 
also implement a functional interface. Since all three are correct, the answer is option F .
144. B. The code compiles, even if the blank is replaced with a constant char value, making 
option E incorrect. Note that the class correctly overrides both inherited default methods. 
It is possible to access a default method, even if it is overridden in the class, but requires 
using the super keyword properly. Option B demonstrates the correct syntax. Note that 
option D would not be correct even if there was only one inherited default method.
145. C. Option A is incorrect because the keywords static and import are reversed. The 
Closet class uses the method getClothes() without a reference to the class name 
Store; therefore, a static import is required. For this reason, option B is incorrect since 
it is missing the static keyword. Option D is also incorrect since static imports are 
used with members of the class, not a class name. Finally, option C is the correct answer 
since it properly imports the method into the class using a static import.
146. B. The drive() method in the Car class does not override the private version in the 
Automobile class since the method is not visible to the Car class. Therefore, the final 
attribute in the Automobile class does not prevent the Car class from implementing a 
method with the same signature. The drive() method in the ElectricCar class is a valid 
override of the method in the Car class, with the public access modifier expanding access
in the subclass. In the main() method, the object created is an ElectricCar, even if it is 
assigned to a Car or Automobile reference. Due to polymorphism, the method from the 
ElectricCar will be invoked, making option B the correct answer.
147. A. The code compiles, so option F is incorrect. The Music class is loaded, and the static 
initializers are executed in order, with re-fa- being printed first. Next, the first line of the 
main() method is executed, printing ti-. The second line of the main() method creates a 
Music object, with the instance initializers being called first, printing do-mi-. Finally, the 
no-argument constructor is executed, and so- is printed last.
148. D. All of the options attempt to create an instance using an anonymous class that extends 
Sky. Option A is incorrect because when you create an anonymous class, you do not specify 
a name. Even if there was a Sunset class, the declaration of an anonymous class can only 
extend or implement one type directly. Since it would already extend Sunset, it cannot 
specify Sky at the same time. Option B is incorrect because Sky is abstract and cannot 
be instantiated directly. Option C is incorrect because it is missing a semicolon (;) at the 
end. Option D is the correct answer. Remember that all nested classes can have static 
variables if they are marked final.
149. E. The code may look complicated, but it does not compile for a simple reason. The 
abstract read() method defined in Book cannot have a method body. Since it does, the 
code does not compile, and option E is correct.
150. C. While using null with instanceof compiles, it always returns false. The other two 
instanceof calls show that instanceof can be used with both classes and interfaces. 
They both return true since Bus implements Vehicle, making option C correct.
151. D. The first row is incorrect as the private modifier is required for private interface 
methods. The second row is correct. The third row is also incorrect because the static 
modifier is required, not optional, for static interface methods. The public modifier is 
optional, though, as the static method is implicitly public without it. The last row is 
incorrect as the abstract modifier can be implied if the method does not declare a body. 
Since three rows contain an error, option D is correct.
152. D. A final instance variable must be assigned a value when it is declared, in an instance 
initializer, or by a constructor. The Dwarf(String) constructor does not assign a value 
since it contains a local variable called name already. For this reason, this constructor does 
not compile, and option D is correct. If the assignment in the constructor was changed to 
this.name, then the program would compile and print Sleepy.
153. A. The AddNumbers interface is a valid functional interface. While it includes both 
static and default methods, it includes only one abstract method, the precise 
requirement for it to be considered a functional interface, making option B incorrect. The 
class compiles and prints 8 at runtime, making option A correct.
154. B. There is no such thing as package variables, so option A is incorrect. Option C is incor-
rect as the variable is only in scope within a specific instance of the class. Option D is also 
incorrect as the variable is only in scope for a single method that it is defined in. Option B is 
the only correct answer as class variables are in scope within the program.
155. D. The super() statement is used to call a constructor in a parent class, while the this() 
statement is used to call a constructor in the same class, making option D correct and 
option C incorrect. Options A, B, and E are incorrect because they are not built-in function-
ality in Java.
156. C,D. The default no-argument instructor is inserted by the compiler whenever a class, 
abstract or concrete, does not declare any constructors. For this reason, option A is incor-
rect, and option D is correct. Even if a parent class does not declare a no-argument con-
structor, the child class can still declare one, making option B incorrect. If the parent class 
does not declare a no-argument constructor (and none is inserted by the compiler), then the 
child class must declare at least one constructor, making option C correct. Without a con-
structor call, inserting the default no-argument constructor into the child class would lead 
to a compiler error on the implicit super() call. Finally, options E and F are incorrect, as a 
child class of a parent with a no-argument constructor is free to declare or not declare any 
constructors.
157. C. Interfaces allow Java to support multiple inheritance because a class may implement any 
number of interfaces. On the other hand, an anonymous class may implement or extend at 
most one interface or class, respectively, since it does not have a class definition. For these 
reasons, option C is the correct answer.
158. B. The hop() method has protected access, which allows subclasses to call it. Both the 
move() method and main() method are allowed to call hop() since Grasshopper is a 
subclass. The code runs without error and prints hop twice, making option B the answer.
159. A. This code is not a functional interface because it has three abstract methods: fun(), 
game(), and toy(). Removing two of these three methods would cause the code to com-
pile. However, there is no requirement that the code be a functional interface. Since it only 
needs to compile, removing the @FunctionalInterface annotation would also cause 
the code to compile. Option A is correct since only the annotation needs to be removed.
160. C,E. Options A and B are incorrect and describe properties of default interface methods. 
Option C is correct and one of the primary reasons to add a private interface method. 
Option D is not a property of private interface methods. Option E is also correct, as 
private interface methods are not exposed to classes implementing the interface. Option F 
is a nonsensical statement.
161. C. The speak() method has private access, which does not allow code outside the class 
to call it. Therefore, option C is the answer.
162. D. The sell() method does not compile because it does not return a value if both of the 
if-then statements’ conditional expressions evaluate to false. While logically it is true that 
price is either less than 10 or greater than or equal to 10, the compiler does not know 
that. It just knows that if both if-then statements evaluate to false, then it does not have a 
return value; therefore, it does not compile.
163. E. Options A and C do not compile, as they are invalid ways of accessing a member vari-
able. Options B and D both compile but print 100 at runtime, since they reference the speed 
variable defined in the Engine class. Option E is the correct answer, accessing the speed 
variable in the Racecar class and printing 88 at runtime.
164. B,C,F. A static initializer can create instances of any class it has access to, so option A is 
incorrect. It can assign values to static final variables, specifically ones that have not 
been assigned a value already, so option B is correct. A static initializer is executed when 
the class is first loaded, not when an object is created or loaded, making option C correct, 
and options D and E incorrect. If the class is never loaded, then they will not be executed, 
making option F correct.
165. D. The class is loaded first, with the static initialization block called and 1 is printed. 
When the BlueCar is created in the main() method, the superclass initialization happens 
first. The instance initialization blocks are executed before the constructor, so 32 is out-
putted next. Finally, the object is created with the instance initialization blocks again being 
called before the constructor, outputting 45 .  The result is that 13245 is printed, making 
option D the correct answer.
166. B. Recall that this refers to an instance of the current class. Therefore, any superclass of 
Canine can be used as a return type of the method, including Canine itself, making option 
A an incorrect answer. Option D is also incorrect because Canine implements the Pet 
interface. An instance of a class can be assigned to any interface reference that it inherits. 
Option C is incorrect because Object is the superclass of all instances in Java. Finally, 
option B is the correct answer. Canine cannot be returned as an instance of List because 
Canine does not inherit List.
167. D. The static method getDrink() attempts to access an instance-based private 
method buyPopcorn() that results in a compiler error, making option D correct. The rest 
of the code compiles without issue.
168. C. An instance method can access both instance variables and static variables. Both 
methods compile, and option C is correct.
169. A. As ugly as the class looks, it does compile, making option A correct. Lines 2–4 each 
define an instance method since they each have a name and return type. There is no rule 
saying you cannot define a method with the same name as the class, although it is consid-
ered bad style. The main() method calls the default no-argument constructor on line 6, 
inserted by the compiler. Finally, line 7 calls the method declared on line 2 .
170. C. This method has package-private access, which means only classes in the same package 
can access it. In our case, this is the Red and Blue classes, making option C correct.
171. D. This variable has protected access, which means code in the same package can access 
it in addition to subclasses. There are two classes in the com.color package and one class 
that subclasses it, making option D the answer.
172. A. The protected modifier allows access to the same package and subclasses, which are 
options B, C, and D .  Therefore, the correct answer is option A .
173. F. The declarations of the local classes Robot and Transformer compile without issue. 
The only compilation problem in this program is the last line of the main() method. The 
variable name is defined inside the local class and not accessible outside class declaration 
without a reference to the local class. Due to scope, this last line of the main() method does 
not compile, making option F the correct answer. Note that the first part of the print() 
statement in the main() method, if the code compiled, would print GiantRobot.
174. D. When overriding a method, a new or broader checked exception cannot be declared. 
The getNumStudents() method in HighSchool is an invalid override since it declares 
FileNotFoundException, which is not declared in the parent method. Since this is the 
only line that does not compile, option D is correct. Note that an abstract method can be 
overridden with a final method, as shown with getNumTeachers().
175. C. Having one class implement two interfaces that both define the same default method 
signature leads to a compiler error unless the class overrides the default method. In this 
case, the Sprint class overrides both walk() methods correctly; therefore, the code compiles 
without issue, and option C is correct. Note that the return types of the two default methods 
are different, but the overridden method uses a return type that is covariant with both.
176. A. Interface methods are implicitly public, giving both the same signature. This means 
a class implementing them must implement a single wriggle() method, and option A is 
correct.
177. D. The code does compile, so option E is incorrect. A functional interface is required to 
have exactly one abstract method. Both interfaces have two. In both interfaces, roar() 
is abstract. The equals(Lion) method is similar to the equals(Object) in Object 
but is not an override of that method. Similarly, the toString() method in Tiger is also 
an abstract method. While there is a toString() method in Object, it does not take 
any parameters. Since each method has two abstract methods, neither is a functional 
interface, making option D the answer.
178. B. The gold variable is marked final, which means it must be set either when it is 
declared or in a static initializer, as shown on line 17 .  It cannot be modified by a method, 
though, so line 15 does not compile. Since this is the only line that does not compile, option 
B is correct. Line 8 compiles because the static method is modifying the local variable 
scaly, not the instance variable of the same name. Line 12 also compiles. While accessing 
a static variable via an instance is not recommended, it is allowed.
179. A. The method is a correct getter or accessor, making option A is correct.
180. A. From within a method, an array parameter and a varargs parameter are treated the 
same. From the caller, an array parameter is more restrictive. Both types can receive an 
array. However, only a varargs parameter is allowed to automatically turn individual 
parameters into an array. Therefore, the answer is option A .
181. A,C. Marking a class final tends to improve security by guaranteeing the behavior of a 
class is not replaced by overridden methods at runtime. For this reason, options A and C 
are correct. Option B is incorrect and is the opposite of what marking a class final does. 
Options D and E are incorrect and have nothing to do with marking a class final. Option 
F is incorrect as the contents of the class can still be changed, even if the class is marked 
final.
182. E. The code does not compile because the constant variable circumference does not 
declare a value, making option E correct. Remember that all variables within interfaces are 
implicitly static and final. The rest of the lines of code compile without issue. Note 
that while the static method leaveOrbit() cannot access the instance-based default 
method getCircumference() directly, it can through the reference variable earth.
183. F. Trick question! Overloaded methods is correct in the first part of the sentence, but none 
of the answers is correct in the second part of the sentence. Remember, overridden methods 
can have covariant return types. They do not need to be the same. For this reason, option F 
is the correct answer.
184. D. This class creates a final instance toy variable, but it is assigned a value twice. First, 
it is assigned a value in an instance initializer and then in a constructor. For this reason, the 
second line of the constructor does not compile, and option D is correct. The first line of 
the constructor, in which a static variable is referenced from an instance variable, is per-
mitted but discouraged. Also, initializers may reference variables defined later in the class 
declaration.
185. C. Lines 15–17 create the three objects. Lines 18–19 change the references, so orange 
and banana point to each other. Lines 20–21 wipe out two of the original references. This 
means the object with name as x is inaccessible. Option C matches this scenario.
186. C. Option A is incorrect because Java inserts a no-argument constructor only if there are no 
other constructors in the class. Option B is incorrect because the parent can have a default 
no-argument constructor, which is inserted by the compiler and accessible in the child class. 
Option D is incorrect. A class that contains two no-argument constructors will not compile 
because they would have the same signature. Finally, option C is correct. If a class extends a 
parent class that does not include a no-argument constructor, the default no-argument con-
structor cannot be automatically inserted into the child class by the compiler. Instead, the 
developer must explicitly declare at least one constructor and explicitly define how the call 
to the parent constructor is made.
187. B. Building and House are both properly declared inner classes. Any House object 
can be stored in a Building reference, making the declarations for b3 and b4 compile. 
The declaration for h3 is also correct. It so happens that b2 is a House object, so the cast 
works. The declaration of h2 is a problem, though. While the cast itself is fine, a Building 
cannot be stored in a House reference, which means the assignment fails to compile. 
Option B is correct and is the only line with a compiler error in this code. Note that  
if the declaration of h2 was removed, the declaration of b3 would produce a  
ClassCastException at runtime.
188. E. This main() method declares an anonymous class that implements the Tasty interface. 
Interface methods are public, whereas the override in the anonymous class uses package-
private access. Since this reduces the visibility of the method, the declaration of eat() on 
line 9 does not compile. Next, the declaration of the apple object must end with a semi-
colon (;) on line 12, and it does not. For these two reasons, the code does not compile, 
and option E is the correct answer. Note that if these two issues were corrected, with the 
public modifier and missing semicolon (;), then the correct answer would be option C 
because the code does not actually call the eat() method; it just declares it.
189. B. Java supports only a single return data type or void. Therefore, it is not possible 
to define a functional interface that returns two data types, making option A incorrect. 
Although Java does not include built-in support for primitive functional interfaces that 
include float, char, or short, there is nothing to prevent a developer from creating 
them in their own project, making option B the true statement and the correct answer.
Option C is incorrect because a functional interface that takes no values and returns 
void is possible. In fact, Runnable is one such example. Option D is also incorrect, since 
IntFunction<R> takes a primitive argument as input and a generic argument for the 
return type.
190. C. The init() method is accessible only from the same package. Since Tortoise is in 
a different package, the method is not available, and option C is correct. Line x2 does not 
compile either since Tortoise is in a different package and not a subclass. However, the 
question asks about the first line.
191. A. The code does not contain any compilation errors. While an abstract class cannot be 
marked final, a concrete class extending it can be. Likewise, a concrete method overriding 
an abstract one can also be marked final. In the ParkVisit class, the getValue() 
method accesses the effectively final variables width and fun. Finally, a class can override 
a method that it inherits from both an interface and an abstract class, provided the method 
signatures are compatible.
192. D. The Sheep class does not compile because there is no default access modifier key-
word. If the default keyword were omitted, the code would use package-private access. 
Since Sounds is in a different package, option C would then be the answer. However, since 
both classes have problems, Option D the correct answer.
193. B. Marking an interface method private improves the encapsulation of the class, making 
option B correct. Options A and D are incorrect as static methods cannot be overridden, 
regardless if they are marked private. Option C is incorrect, as adding private to a 
method reduces the visibility of the method. Options E and F are flat out wrong.
194. D. Since a constructor call is not the first line of the RainForest() constructor, the com-
piler inserts the no-argument super() call. Since the parent class, Forest, does not define 
a no-argument super() constructor, the RainForest() constructor does not compile, 
and option D is correct.
195. B. First, the color variable defined in the instance and set to red is ignored in the method 
printColor(). Since local scope overrides instance scope, option A is incorrect. The value 
of color passed to the printColor() method is blue, but that is lost by the assignment 
to purple, making option B the correct answer and option C incorrect. Option D is incor-
rect as the code compiles and runs without issue.
196. E. The play() method is overridden in Saxophone for both Horn and Woodwind, so the 
return type must be covariant with both. Object and Number do not work, because nei-
ther is a subclass of Integer or Short. As stated in the question text, both Integer and 
Short extend Number directly, so neither can be a subclass of the other. Therefore, nothing 
can fill in the blank that would allow this code to compile, and option E is correct.
197. A,B,C. Options A, B, and C are correct statements about abstract classes. Option D is 
incorrect as Java allows a class to extend only one class directly, abstract or otherwise. 
Option E is incorrect, as a class can implement or inherit an interface. Option F is also 
incorrect as classes can only extend classes, and interfaces can only extend interfaces.
198. C. The code does not compile. First, the enum list is not terminated with a semicolon (;), 
which is required when an enum includes anything beyond just the list of values. Second, 
the access modifier of TRUE’s implementation of getNickName() is package-private, but 
the abstract method signature has a protected modifier. Since package-private is a 
more restrictive access than protected, the override is invalid, and the code does not com-
pile. For these two reasons, option C is the correct answer. Note that the value variable is 
not final nor properly encapsulated and can therefore be modified by callers outside the 
enum. This is permitted but considered a poor practice.
199. B,C,D. A Java class file may have at most one package statement and any number of 
import statements and comments. For this reason, option A is incorrect, and options B and 
C are correct. When declaring a class, the name comes first, before instance declarations, 
making option D correct and option E incorrect. Finally, Java does not support fragments of 
code outside of a top-level type, such as a class or interface, making option F incorrect. 
200. E. The hop() method has protected access, which allows subclasses to call it, making 
line p1 correct. The HopCounter class is allowed to call the move() method because it is 
public. However, it is not allowed to call the hop() method since it is referencing a sub-
class, but not in one. Therefore, option E is the answer.
201. C. Interfaces cannot contain protected methods, making option C the answer.
202. B. Options A and D would not allow the class to compile because two methods in the class 
cannot have the same name and arguments, but a different return value. Option C would 
allow the class to compile, but it is not a valid overloaded form of our findAverage() 
method since it uses a different method name. Option B is a valid overloaded version of the 
findAverage() method, since the name is the same but the argument list differs.
203. A,E. Options A and E are correct since method names may include the underscore (_) 
character as well as the dollar ($) symbol. Note that there is no rule that requires a method 
start with a lowercase character; it is just a practice adopted by the community. Options B 
and F are incorrect because the hyphen (-) and pound (#) characters may not be part of a 
method name. Option C is incorrect since new is a reserved word in Java. Finally, option D 
is incorrect. A method name must start with a letter, the dollar ($) symbol, or an underscore 
(_) character.
204. C. A functional interface must include exactly one abstract method, either by inheritance 
or declared directly. It may also have any number, including zero, of default or static 
methods. For this reason, both parts of option D are incorrect. The first part of option A 
is incorrect because more than one abstract method disqualifies it as a functional inter-
face. The first part of option B is incorrect because the method must be abstract; that 
is to say, any method will not suffice. Finally, option C is the correct answer. The first part 
of the sentence defines what it means to be a functional interface. The second part refers 
to the optional @FunctionalInterface annotation. It is considered a good practice to 
add this annotation to any functional interfaces you define because the compiler will report 
a problem if you define an invalid interface that does not have exactly one abstract 
method.
205. F. The code compiles, even if the blank is replaced with a constant int value, making 
option E incorrect. The private method play() declared in the Sport interface is not 
accessible in the Game class. For this reason, option F is correct.
206. E. The code does not compile because two of the constructors contain a cyclic reference to 
each other. The MoreMusic(int) constructor calls this(null), which only matches 
the MoreMusic(String) constructor. Then, the MoreMusic(String) constructor calls 
this(9), which only matches the MoreMusic(int) constructor. The compiler notices 
this circular dependency and does not allow the code to compile.
207. A. Both classes compile without issue, and the Hug program prints kitty - 5.0, making 
option A the answer. In the Kitten class, all of the variables have package-private access 
as the access modifiers are commented out. Also, there is no age variable since the entire 
line is commented out. If the comment syntax was removed around private, then the Hug 
class would not compile on the line that accesses the cuteness variable.
208. A,B. A switch statement that uses an enum must include case statements that refer-
ence the value of the enum, without the enum type. For this reason, option A is correct and 
option C is incorrect. The ordinal() value or position cannot be used in case statements 
when the switch statement takes an enum value, making option B correct and option E 
incorrect. Finally, not every value in enum must be present in the case statement, regardless 
of whether a default branch is present, making options D and F incorrect.
209. A. The code compiles without issue. The main() method creates an instance of an anon-
ymous class of Ready. Calling r.first retrieves the static variable within Ready, 
printing 2 on line n3 .  On line n2, there is no reference so the static variable of GetSet 
is called, printing 10 .  For these reasons, option A is correct.
210. D. The init() method is accessible from any code. However, the race() method is avail-
able only within the Hare class. Since Tortoise is a different class, the method is not 
available, and option D is correct.
211. D. The Sheep class does not compile since a static method cannot call an instance 
method. The Sounds class does not compile because it does not have access to the 
speak() method. Since neither class compiles, option D is correct.
212. C. The Rotorcraft class includes an abstract method, but the class itself is not marked 
abstract. Only interfaces and abstract classes can include abstract methods. Since the 
code does not compile, option C is the correct answer.
213. A,C,E. All of the interface methods without a private modifier are implicitly public. In 
a class, though, a method without a modifier is package-private by default. For this reason, 
the write() and think() methods do not compile because they are missing the public 
modifier, making options A and C correct. These are the only compiler errors, making 
option B incorrect. Option D is incorrect because the process() method is not accessible 
with Twins because it is private. Option E is correct, as all methods are accessible.  
Even the overridden default method can be accessed in the Twins class by calling 
Michael.super.write(). Finally, option F is incorrect as the class still compiles if  
it is marked abstract.
214. D. The Super class is marked final, which mean its cannot be used as the supertype of 
an anonymous class. For this reason, line 6 does not compile, and option D is correct. Line 
7 also does not compile as a local class can only contain static variables that are marked 
final.
215. D. The final variable DEFAULT_VALUE is not a static variable; therefore, the static 
nested class GetSet cannot access it without a reference to the class. For this reason, the 
declaration of the static nested class GetSet does not compile, and option D is the 
correct answer. The rest of the code compiles without issue. If the DEFAULT_VALUE vari-
able was modified to be static, then the code would compile and print 5, 10 at runtime.
216. B,C. The static class variables cannot be used with var since they are not local variables. 
Therefore, options E and F are incorrect. Options B and C are correct because numeric 
addition is used here instead of concatenation.
217. F. The code does not compile, as the constructor calls on the first four lines of the main() 
method are missing the new keyword. If the missing new keywords were added to each line, 
then the code would compile, and three Gems objects would be available for garbage collec-
tion.
218. B. The code does not compile, so option A is incorrect. The class contains two methods and 
one constructor. The first method, Stars(), looks a lot like a no-argument constructor, 
but since it has a return value of void, it is a method, not a constructor. Since only construc-
tors can call super(), the code does not compile due to this line. The only constructor in 
this class, which takes an int value as input, performs a pointless assignment, assigning 
a variable to itself. While this assignment has no effect, it does not prevent the code from 
compiling. Finally, the main() method compiles without issue since we just inserted the 
full package name into the class constructor call. This is how a class that does not use an 
import statement could call the constructor. Since the method is in the same class, and 
therefore the same package, it is redundant to include the package name but not disallowed. 
Because only one line causes the class to fail to compile, option B is correct.
219. A. Although the casting is a bit much, the object in question is a SoccerBall. Since  
SoccerBall extends Ball and implements Equipment, it can be explicitly cast to any 
of those types, so no compilation error occurs. At runtime, the object is passed around 
and, due to polymorphism, can be read using any of those references since the underlying 
object is a SoccerBall. In other words, casting it to a different reference variable does not 
modify the object or cause it to lose its underlying SoccerBall information. Therefore, 
the code compiles without issue, and option A is correct.
220. F. The question may appear to be about method overriding, but it is in fact about member 
inner classes. In fact, all of the method overrides are valid in this class. The code does not 
compile because the charge() method is static (even though it is called on an instance), 
which means it requires an instance to instantiate a member of the member inner class 
MyTrunk. For this reason, the call to new MyTrunk() does not compile, and option F is 
correct.
1. B. The throws keyword is used in method declarations, while the throw keyword is used 
to send an exception to the surrounding process, making option B the correct answer. The 
catch keyword is used to handle exceptions. There is no throwing keyword in Java.
2. E. To throw an exception with the throw keyword, an existing or new exception must be 
provided. In this case, the new keyword is missing in front of Exception() in the think() 
method. It is treated as a method call that does not exist, and this line does not compile, mak-
ing option E correct. If the new keyword were added, though, the line would still not compile 
as the checked exception is not handled or declared within the think() method.
3. A,C. The correct order of blocks is try, catch, and finally. For a traditional try/catch 
block at least one catch or finally must be used. In addition, multiple catch blocks are 
allowed, although at most one finally block is allowed. For these reasons, options A and 
C are correct, and the rest are incorrect.
4. C. Unlike a try-with-resources statement, in which the catch and finally blocks are 
optional, a traditional try statement requires a catch or finally block to be used, or 
both. For this reason, option C is correct.
5. E. The code does not compile because the throw keyword is incorrectly used in the toss() 
method declaration. The keyword throws should have been used instead. For this reason, 
option E is the correct answer. If the correct keyword was used, then the code would compile 
and Caught! at runtime.
6. E. The code does not compile because s is defined within the try-with-resources block. It is 
out of scope by the time it reaches the catch and finally blocks, making option E correct.
7. D. The Exception class contains multiple constructors, including one that takes  
Throwable, one that takes String, and a no-argument constructor. The first  
WhaleSharkException constructor compiles, using the Exception constructor that 
takes a String. The second WhaleSharkException constructor also compiles. The two 
statements, super() and new Exception(), actually call the same constructor in the 
Exception class, one after another. The last WhaleSharkException compiles with the 
compiler inserting the default no-argument constructor super(), because it exists in the 
Exception class. For these reasons, all of the constructors compile, and option D is the 
correct answer.
8. D. The application first enters the try block and prints A. It then throws an  
ArrayIndexOutOfBoundsException, which is caught by the first catch block since 
ArrayIndexOutOfBoundsException is a subclass of RuntimeException, printing B .
 The exception is then rethrown, but since there isn’t a separate try/catch block around 
it, it does not get caught by the second catch block. Before printing the stack trace, the 
finally block is called, and D is printed. For these reasons, option D is correct.
9. C,F. While Exception and RuntimeException are commonly caught in Java appli-
cations, it is not recommended that Error and Throwable (which includes Error) be 
caught. An Error often indicates a failure of the JVM, which cannot be recovered from. For 
these reasons, options C and F are correct, and options A and D are incorrect. Options B and 
E are class names that are not part of the standard Java API.
10. E. A variable declared before the start of a try-with-resources statement may be used if it 
is final or effectively final. Since g is modified after it is set, it is neither; therefore, the 
class does not compile, and option E is correct. If the last line of the main() method were 
removed, then the code would compile and print 2459 at runtime.
11. C. The class does not compile because in line r2, curly braces, {}, are used instead of paren-
theses, (), in the try-with-resources statement, making option C the correct answer. If this 
line was fixed to use parentheses, (), then the rest of the class would compile without issue 
and print This just in! at runtime.
12. C. Since IOException and Exception are checked exceptions, ColoringException 
and WritingException are checked exceptions. Further, CursiveException is also 
checked since it extends a checked exception. By contrast, IllegalStateException is an 
unchecked exception. This means that DrawingException and SketchingException 
are also unchecked, and option C is the answer.
13. C. The code does not compile because the variable v is used twice in the main() method, 
both in the method declaration and in the catch block, making option C the correct answer. 
If a different variable name were used in one of the locations, the program would print one 
line, complete, making option A the correct answer. Note that while an exception is created 
inside the turnOn() method, it is not thrown.
14. A,E. When more than one resource is used in a try-with-resources statement, they are closed 
in the reverse order in which they are declared, making option A the first false statement. 
In addition, resources are separated by semicolons, not commas, making option E the other 
false statement. The rest of the statements are true. Note that ability to declare resources 
before they are used in a try-with-resources statement is new since Java 9 .
15. A. The program compiles without issue, so option D is incorrect. The narrower  
SpellingException and NullPointerException, which inherit from Exception, 
are correctly presented in the first catch block, with the broader Exception being  
in the second catch block. The if-then statement evaluates to true, and a new  
Spelling Exception instance is created, but it is not thrown because it is missing the 
throw keyword. For this reason, the try block ends without any of the catch blocks 
being executed. The finally block is then called, making it the only section of code in the 
program that prints a line of text. For this reason, option A is the correct answer.
16. A,D,F. Any class that inherits Exception but not RuntimeException is a checked 
exception and must be handled or declared. For this reason, option F is trivially correct. 
Options A and D are also checked exceptions. Options B and E are incorrect since they 
inherit RuntimeException. Finally, option C is incorrect as Error inherits Throwable 
but not Exception.
17. C. The finally block of the snore() method throws a new checked exception on line x1, 
but there is no try-catch block around it to handle it, nor does the snore() method declare 
any checked exceptions. For these reasons, line x1 does not compile, and option C is the 
correct answer. The rest of the lines of code compile without issue. Note that the code inside 
the try block, if it ran, would produce an ArrayIndexOutOfBoundsException, which 
would be caught by the RuntimeException catch block, printing Awake!.
18. E. The ProblemException class compiles without error. However, the  
MajorProblemException class has, well, a major problem. The constructor attempts to 
call a superclass constructor with a String parameter, but the ProblemException class 
only has a constructor with an Exception parameter. This causes a compiler error, which 
is option  E .
19. B,D. First, option A is an incorrect statement, because the AutoCloseable interface does 
not define a default implementation of close(). Next, the close() method should 
be idempotent, which means it is able to be run multiple times without triggering any side 
effects. For this reason, option B is correct. After being run once, future calls to close() 
should not change any data. Option D is correct, and option C is incorrect because the 
close() method is fully capable of throwing exceptions if there is a problem. In fact, the 
signature of the method in AutoCloseable throws a checked Exception. Option E is 
incorrect because the return type of close() is void, which means no return value can 
be returned.
20. D. Option D is the correct model. The class RuntimeException extends Exception, 
and both Exception and Error extend Throwable. Finally, like all Java classes, they 
all inherit from Object. Notice that Error does not extend Exception, even though we 
often refer to these generally as exceptions.
21. F. The classes MissingMoneyException and MissingFoodException do not extend 
any exception classes; therefore, they cannot be used in a method declaration. The code  
does not compile regardless of what is placed in the blank, making option F correct.
22. B,D. Closeable extends AutoCloseable, making option B correct and option  
A incorrect. The close() method in AutoCloseable throws Exception, while the 
close() method in Closeable throws IOException, making option E incorrect. Since 
IOException is a subclass of Exception, both close() methods can throw an  
IOException, making option C incorrect. On the other hand, Exception is not a  
subclass of IOException. For this reason, the close() method in a class that implements 
Closeable cannot throw an instance of the Exception class, because it is an invalid over-
ride using a broader exception type, making option D the correct answer. Finally, the return 
type for both is void, making option F incorrect.
23. B,F. Option A does not compile because a multi-catch expression uses a single variable, not 
two variables. Since the TideException is handled and neither exception class is a subtype 
of the other, option B is correct. Option C does not compile because the compiler notices 
that it is not possible to throw a checked IOException in this try block. Option D does 
not compile because multi-catch blocks cannot contain two exceptions in which one is a sub-
class of the other. If it did, one of the two exceptions would be redundant. Option E does not 
compile because the checked TideException is not handled or declared by the surf() 
method. Remember, Error and Exception are not subclasses of each other, although they 
both inherit Throwable. Option F is correct because TideException is a subclass of 
Exception, so both are handled by Exception.
24. B,C. Option A is incorrect. You should probably seek help if the computer is on fire! Options 
B and C are correct answers, as invalid or missing data/resources should be expected of most 
programs. Option D is incorrect because code that does not compile cannot run and there-
fore cannot throw any exceptions. Option E is incorrect; finishing sooner is rarely considered 
a problem. Option F is incorrect because an Error is thrown in this situation, and it should 
not be caught, as the JVM cannot usually recover from this scenario.
25. A. The program compiles, making options D and E incorrect. At runtime, line 12 is executed, 
calling the play() method. Line 5 then throws an exception that is immediately caught on 
line 6 .  Line 7 throws a new unchecked exception that is not caught by the program, with 
this exception being thrown to the caller, and making option A correct. In this case, line 13 is 
never executed. Even though the stack trace for the exception may include information about 
the cause, only one exception is actually thrown to the caller.
26. D. The code does not compile due to an invalid override of the operate() method. An 
overridden method must not throw any new or broader checked exceptions than the method 
it inherits. While both IOException and Exception are checked exceptions, Exception 
is broader than IOException. For this reason, the declaration of operate() in Heart 
does not compile, and option D is correct.
27. C,F. Option A is a true statement and one of the primary motivations for using a try-with-
resources statement. Option B is also true, although it is recommended you let the try-with-
resources statement automatically close the resource. The catch blocks are run after the 
declared resources have been closed, making option C the first answer. Options D and E are 
both true, since Closeable extends AutoCloseable and the requirement for try-with-
resources is that they must be of type AutoCloseable. A try-with-resources statement can 
be used with a finally block, making option F the other answer.
28. D. The code compiles without issue. It first prints Tracking from the try block. Upon the 
completion of the try block, the close() method is called, and Thunder is printed. No 
exception is thrown so the catch block is skipped. In the finally block, Storm gone is 
printed, followed by Thunder. Since four lines were printed, option D is correct. While it is 
not recommended to close a resource twice, it is allowed.
29. C. Error is a terrible name for an exception since it is a built-in class. However, it is 
legal. Next, _X is also a bad choice, but it is valid exception as Java identifiers can begin 
with underscores. By contrast, 2BeOrNot2Be does not compile because identifiers are not 
allowed to begin with a number. NumberException is not a valid exception, because it uses 
generics, and the parent class does not. Finally, Worry is not an exception, because it is an 
interface. Since only two are valid exceptions, option C is the answer.
30. C. ClassCastException is a subclass of RuntimeException, so it must appear first in 
any related catch blocks. For this reason, option C is correct.
31. D. The openDrawbridge() method declares a checked exception that is not handled or 
declared in the main() method where it is called. For this reason, line p3 does not com-
pile, and option D is correct. The rest of the lines do not contain any compiler errors. If the 
main() method were changed to declare Exception, then the class would compile and 
print Opening!Walls at runtime.
32. B. The code compiles and runs without issues. The try block throws a  
Class CastException. Since ClassCastException is not a subclass of  
ArrayIndex OutOfBoundsException, the first catch block is skipped. For the second 
catch block, ClassCastException is a subclass of Throwable so that block is exe-
cuted. Afterward, the finally block is executed, and then control returns to the main() 
method with no exception being thrown. The result is that 1345 is printed, making option B 
the correct answer.
33. C,E. A finally block requires curly braces, making option C correct. A finally block 
can throw an exception in which case not every line of the finally block will be executed. 
For this reason, option E is correct, and options A and D are incorrect. Option B is incorrect 
because a finally block is called regardless of whether the related catch block is exe-
cuted. A finally block can throw both checked and unchecked exceptions, making option 
F incorrect. If the exception is checked, then it must be handled or declared in the method in 
which the finally block is used.
34. A. The application compiles without issue and prints Hello, making option A the correct 
answer. The ReadSign and MakeSign classes are both correctly implemented, with both 
overridden versions of close() dropping the checked exceptions. The try-with-resources 
statement is also correctly implemented for two resources and does not cause any compila-
tion errors or runtime exceptions. Note that the semicolon (;) after the second resource dec-
laration is optional.
35. E. The try block is entered and 2 is printed, followed by an exception. Upon completion 
of the try block, the resources are closed in the reverse order in which they are declared, 
printing 8 followed by 1 .  Next, the catch block executes, printing 3, followed by the 
finally block printing 4 .  For these reasons, option E is correct.
36. D. A multi-catch block cannot contain two exception types in which one inherits from the 
other. Since RuntimeException inherits Exception, RuntimeException is redundant. 
For this reason, the code does not compile, and option D is correct.
37. D. In the try block, the code prints 1 and throws an exception. The catch block success-
fully handles it by printing 2 and throwing another exception. Both the inner and outer 
finally blocks run printing 3 and 4, respectively. Then the stack trace for the exception 
thrown by the inner try block is printed.
38. C. The code compiles without issue. Line 8 calls the compute() method, which throws a 
NullPointerException on line 4 .  This is caught in the main() method on line 9, since 
NullPointerException is a subclass of RuntimeException, printing zero followed 
by a stack trace to the caller and making option C correct.
39. F. The UnsupportedOperationException class is an unchecked exception that is a 
direct child of RuntimeException. For this reason, we can eliminate any answer that  
does not inherit from RuntimeException including options A and  E . Options C and  
D are close, but UnsupportedOperationException is a direct subclass of  
Runtime Exception. Option B is incorrect because RuntimeException is a subclass,  
not a superclass, of Exception. The correct diagram would be to reverse option B and  
put RuntimeException at position 1, and Exception at position 2 .  Since this is not 
available, option F is correct.
40. E. The close() method in each of the resources throws an Exception, which must be 
handled or declared in the main() method. The catch block supports TimeException, 
but it is too narrow to catch Exception. Since there are no other catch blocks present and 
the main() method does not declare Exception, the try-with-resources statement does 
not compile, and option E is the correct answer. If the catch block were modified to handle 
Exception instead of TimeException, the code would compile without issue and print 
3215 at runtime, closing the resources in the reverse order in which they were declared.
41. B,D,E. Checked exceptions are commonly used to notify or force a caller to deal with an 
expected type of problem, such as the inability to write a file to the file system, and give them 
the opportunity to recover without terminating the program. For these reasons, options B, D, 
and E are correct. Option A is incorrect as a corrupted JVM is likely an Error that cannot 
be recovered from. Option C is also incorrect, as some problems should result in the applica-
tion terminating. Finally, option F is incorrect and is ideally never the motivation for adding 
a checked exception to a method signature!
42. C. A multi-catch block cannot contain two exceptions in which one is a subtype of the other, 
since it is a redundant expression. Since CarCrash is a subclass of RuntimeException 
and RuntimeException is a subclass of Exception, line w3 contains a compilation error, 
making option C the correct answer. The rest of the lines of code do not contain any compi-
lation errors.
43. A,B,F. Since IOException and SQLException are checked exceptions, Happy and 
Grumpy are checked exceptions, respectively, making options A and F correct. Since Dopey 
inherits Grumpy, option B is also a checked exception. Options C and D are unchecked 
exceptions because those classes inherit RuntimeException. Option E is also an 
unchecked exception because all Error classes are unchecked.
44. E. The code compiles without issue, so option D is incorrect. The key here is noticing that 
count, an instance variable, is initialized with a value of 0 .  The getDuckies() method 
ends up computing 5/0, which leads to an unchecked ArithmeticException at runtime, 
making option E the correct answer.
45. B,D,F. An IllegalArgumentException is an unchecked exception. It can be handled or 
declared in the method in which it is defined, although it is optional and not required. For 
this reason, options B, D, and F are correct, and options A and C are incorrect. Option E is 
incorrect, as there is no requirement where in a method this exception can be thrown.
46. D. While a catch block is permitted to include an embedded try-catch block, the issue here 
is that the variable name e is already used by the first catch block. In the second catch 
block, it is equivalent to declaring a variable e twice. For this reason, line z2 does not com-
pile, and option D is the correct answer. If a different variable name was used for either 
catch block, then the code would compile without issue, printing Failed at runtime.
47. D. The declaration of IncidentReportException does not provide any constructors, 
which means only the default constructor is available. Since the code attempts to pass an 
IOException as a parameter, the main() method does not compile, so the correct answer 
is option  D .
48. A. The try-catch block already catches Exception, so the correct answer would be the one 
that is not a subtype of Exception. In this case, Error extends Throwable and is the only 
choice that allows the code to compile, making option A correct.
49. F. The application does not compile because the roar() method in the BigCat class uses 
throw instead of throws, making option F correct. Note that if the correct keyword was 
used, then the code would compile and print Meow at runtime. 
50. D. The MissedCallException is a checked exception since it extends Exception and 
does not inherit RuntimeException. For this reason, the first catch block fails to com-
pile, since the compiler detects that it is not possible to throw this checked exception inside 
the try block, making option D the correct answer. Note that if MissedCallException 
was changed to extend the unchecked RuntimeException class, then the code would  
compile and the RuntimeException from the finally block would replace the  
ArrayIndexOutOfBoundsException from the try block and Text would be in the 
message to the caller.
51. A. Both IllegalArgumentException and NullPointerException inherit  
RuntimeException, but neither inherits from each other. For this reason, they can be listed 
in catch blocks in either order, making option A the correct statement.
52. C. While RuntimeException is broader than IllegalArgumentException, the 
restriction on overriding methods applies only to checked exceptions, not unchecked excep-
tions. In other words, the code would not compile if both of the exceptions were checked. 
Since they are unchecked, though, the method override is valid. The program compiles and 
prints thud? at runtime, making option C correct.
53. C. The Closeable interface defines a close() method that throws IOException. The 
overridden implementation of MyDatabase, which implements Closeable, declares a 
SQLException. This is a new checked exception not found in the inherited method signa-
ture. Therefore, the method override is invalid, and the close() method in MyDatabase 
does not compile, making option C the correct answer.
54. C. Custom exception classes may simply use the default constructor. It is also common to 
override the constructors that take a single Exception or a single String, making option 
C correct.
55. A. While this code looks a bit strange, it does compile. An exception can be passed to 
a method or set as the return type of a method. In this case, the exception passed to the 
order() method is thrown and caught on line h4 .  The output is just the name of the class, 
making option A correct.
56. C,F. A Java application tends to only throw an Error when the application has encoun-
tered an unrecoverable error. Failure of a user to sign in or register are common occurrences, 
making options A, B, and E incorrect. On the other hand, calling a method infinitely can lead 
to an unrecoverable StackOverflowError, making option C correct. Option D uses the 
word temporarily, meaning the network connection could come back up allowing the appli-
cation to recover. Option F is the other correct answer. Over time, failing to release database 
connections could result in the application running out of available database connections or 
worse, out of memory, and being unable to recover.
57. E. The code does not compile because john is declared in the try-with-resources statement 
and not accessible in the finally block.
58. B. The code does compile, making options C and D incorrect. The catch block successfully 
catches the IncidentReportException and prints the IOException passed to its con-
structor, making option B the correct answer.
59. B. The code compiles without issue, making option C incorrect. In the climb() method, 
two exceptions are thrown. The RuntimeException thrown in the try block is consid-
ered the primary exception, while the FallenException thrown by the close() method 
is suppressed. For this reason, java.lang.RuntimeException is reported to the caller in 
the main() method, and option B is the correct answer.
60. D. For this question, notice that all the exceptions thrown or caught are unchecked  
exceptions. First, the ClassCastException is thrown in the try block and caught  
by the second catch block, since it inherits from RuntimeException, not  
Illegal ArgumentException. Next, a NullPointerException is thrown, but  
before it can be returned the finally block is executed and a RuntimeException 
replaces it. The application exits, and the caller sees the RuntimeException in the  
stack trace, making option D the correct answer. If the finally block did not throw any 
exceptions, then NullPointerException would be printed at runtime.
1. A. While the ArrayList is declared with an initial capacity of one element, it is free to 
expand as more elements are added. Each of the three calls to the add() method adds an 
element to the end of the ArrayList. The remove() method call deletes the element at 
index 2, which is Art. Therefore, option A is correct.
2. B. The array brackets, [], are not allowed to appear before the type, making the lions 
declaration incorrect. When using an array initializer with braces, {}, you are not allowed 
to specify the size separately. The size is inferred from the number of elements listed. There-
fore, tigers and ohMy are incorrect. When you’re not using an array initializer, the 
size is required. An empty array initializer is allowed. Option B is correct because only 
bears is legal.
3. E. When declaring a class that uses generics, you must specify a name for the formal type 
parameter. Java uses the standard rules for naming a variable or class. A question mark is not 
allowed in a variable name, making options A and C incorrect. While it is common practice 
to use a single uppercase letter for the type parameter, this is not required. It certainly isn’t a 
good idea to use existing class names like the News class being declared here or the Object 
class built into Java. However, both are allowed, making option E the answer.
4. B,E. Option B is one answer because line 26 does not compile. The ? wildcard cannot be 
used when instantiating a type on the right side of the assignment operator. The other lines 
do compile. Additionally, option E is correct because lines 28 and 29 use autoboxing. They 
convert a primitive to a wrapper object, in this case Double and Integer, respectively. Line 
30 is correct and does not use autoboxing. It places a null reference as the Integer object.
5. C. A two-dimensional array is declared by listing both sizes in separate pairs of brackets, []. 
Option C correctly shows this syntax.
6. D. The offer() method inserts an element at the end of the queue. This means the queue 
contains [snowball, minnie, sugar]. The peek() method returns the element at the 
front of the queue without removing it. Therefore, snowball is printed twice, but the queue 
remains with three elements. This matches option  D .
7. E. Notice how there is unnecessary information in this description. The fact that patrons 
select books by name is irrelevant. The checkout line is a perfect example of a Queue. 
We need easy access to one end of the Queue for patrons to add themselves to the queue. 
We also need easy access for patrons to get off the queue when it is their turn. Since a 
LinkedList is a Queue, this narrows down the answer to options D, E, and  F .
The book lookup by ISBN is a lookup by key. We need a map for this. A HashMap is prob-
ably better here, but it isn’t a choice. So the answer is option E, which does include both a 
Queue and a Map.
8. B. Line 8 attempts to store a String in an array meant for an int. Line 8 does not compile, 
and option B is correct.
9. B. Options C and D are incorrect because the method signature is incorrect. Unlike the 
equals() method, the method in Comparator<String> takes the type being compared 
as the parameters when using generics. Option A is a valid Comparator<String>. How-
ever, it sorts in ascending order by length. Option B is correct. If s1 is three characters and 
s2 is one character, it returns -2 .  The negative value says that s1 should sort first, which is 
correct, because we want the longest String first.
10. B. In Java, arrays are indexed starting with 0. While it is unusual for the loop to start with 1, 
this does not cause an error. It does cause the code to output six lines instead of seven, since 
the loop doesn’t cover the first array element. Therefore, option B is correct.
11. C. Java talks about the collections framework, but the Map interface does not actually  
implement the Collection interface. TreeMap has different methods than the other 
options. It cannot fill in the blank, so option C is correct.
12. B,F. In Java, Arrays.binarySearch() returns a positive int, representing the index of a 
match if one is found. An int cannot be stored in a String variable, making option F one 
of the answers. When using the correct data type and searching for seed, we find it at index 
1 .  Therefore, option B is the other correct answer.
13. C. As with a one-dimensional array, the brackets, [], must be after the type, making alpha 
and beta illegal declarations. For a multidimensional array, the brackets may be before  
and/or after the variable name. They do not need to be in the same place. Therefore, gamma,
delta, and epsilon are correct. Finally, var can be used as a local variable, but not with 
array brackets after it. The code would compile if it said var zeta. Since three options are 
correct, the answer is option  C .
14. A. First the code creates an ArrayList of three elements. Then the list is transformed into 
a TreeSet. Since sets are not allowed to have duplicates, the set only has two elements. 
Remember that a TreeSet is sorted, which means that the first element in the TreeSet is 
3 .  Therefore, option A is correct.
15. D,E. Three dots in a row is a varargs parameter. While varargs is used like an array  
from within the method, it can only be used as a method parameter. This syntax is 
not allowed for a variable, causing a compiler error on line 5 .  Line 6 does not compile 
because linearSort() should be sort(). On line 7, the method name is also incor-
rect. The search() should be binarySearch(). Finally, line 9 uses size() instead of 
length. Since there are four errors, option D is correct. If all these errors were corrected, 
original[0] would cause an exception because the array is empty. Therefore, option E is 
also correct.
16. A,D,F. Line 20 does not compile for a Map because it requires two generic types. Line 23 
does not compile for a Set because the elements are unordered and do not have an index. 
This makes options D and F correct. Additionally, option A is correct because line 23 replaces 
the second element with a new value, making chars contain [a, c]. Then line 24 removes 
the first element, making it just [c]. There is only one element, but it is not the value b.
17. E. The Magazine class doesn’t implement Comparable<Magazine>. It happens to imple-
ment the compareTo() method properly, but it is missing actually writing implements 
Comparable. Since TreeSet doesn’t look to see if the object can be compared until run-
time, this code throws a ClassCastException when TreeSet calls add(), so option E 
is correct.
18. B. Arrays begin with an index of 0. This array is a 3×3 array, making only indexes 0, 1, and 
2 valid. Line r2 throws an ArrayIndexOutOfBoundsException. Therefore, option B 
is correct.
19. D. The generic declaration on line R is valid. It sets a constraint on the generic type used 
when declaring a Fur object. Lines S and T compile as they meet this constraint. However, 
line U has a problem since Sat does not extend Mammal. Since this line does not compile, 
option D is the answer.
20. C. Line 18 puts 3 in nums since it is the smaller value. Since a Set must have unique ele-
ments, line 19 does not add another value to nums. Line 20 adds the final value of 16 .  The 
set has a total of two elements, 3 and 16 .  A HashSet does not commit to an output order, 
making option C correct.
21. B. Note that LinkedList is a Deque, or double-ended queue. This lets us add elements at 
both ends. The offer() method adds an element to the back of the queue. After line 7 com-
pletes, the queue contains 18 and 5 in that order. The push() method adds an element to 
the front of the queue. How rude! The element 13 pushes past everyone on the line. After line 
8 completes, the queue now contains 13, 18, and 5, in that order. Then we get the first two 
elements from the front, which are 13 and 18, making option B correct.
22. E,F. TreeMap and TreeSet keep track of sort order when you insert elements. TreeMap 
sorts the keys and TreeSet sorts the objects in the set. This makes options E and F correct. 
Note that you have the option of having JellyBean implement Comparable, or you can 
pass a Comparator to the constructor of TreeMap or TreeSet. Option D is trying to trick 
you as SortedArray is not a class or interface in the collections framework.
23. B. Array indices start with 0, making options C and D incorrect. The length attribute refers 
to the number of elements in an array. It is one past the last valid array index. Therefore, 
option B is correct.
24. B. Since the method does not have any declared exceptions, it can only throw unchecked 
exceptions. Option B is the only one that requires the elements of coll to be  
Runtime Exception or any subclasses.
25. D. Options A and B show that the brackets, [], can be before or after the variable name and 
produce the same array. Option C specifies the same array the long way with two arrays of 
length 1 .  Option D is the answer because it is different than the others. It instead specifies an 
array of length 1 where that element is of length 2 .
26. D. Java requires having a sorted array before calling the binarySearch() method. You do 
not have to call Arrays.sort to perform the sort, though. This array happens to already be 
sorted, so it meets the precondition. The target string of "Linux" is the first element in the 
array. Since Java uses zero-based indexing, search is 0 .  The Arrays.mismatch() method 
returns -1 if the arrays are the same and returns the index of the first difference if they are 
not. In our cases, mismatch1 is 0 because the first element differs, and mismatch2 is -1 
because the arrays are the same. This makes option D the correct answer.
27. D. The Comic<C> interface declares a formal type parameter. This means that a class imple-
menting it needs to specify this type. The code on line 21 compiles because the lambda refer-
ence supplies the necessary context making option A incorrect. Option B declares a generic 
class. While this doesn’t tell us the type is Snoopy, it punts the problem to the caller of the 
class. The declaration of c2 on line 22 compiles because it supplies the type, making option 
B incorrect. The code on line 23 compiles because the SnoopyClass itself supplies the type, 
making option C incorrect.
Option D has a problem. SnoopyClass and SnoopyComic appear similar. However, 
SnoopyComic refers to  C . This type parameter exists in the interface. It isn’t available in the 
class because the class has said it is using Snoopy as the type. Since the SnoopyComic class 
itself doesn’t compile, the line with c4 can’t instantiate it, and option D is the answer.
28. C. When implementing Comparable<Truck>, you implement the compareTo() method. 
Since this is an instance method, it already has a reference to itself and only needs the item 
it is comparing. Only one parameter is specified, and option C is correct. By contrast, the 
Comparator<Truck> interface uses the compare() method, and the method takes two 
parameters.
29. B. There is nothing wrong or tricky about this code. It correctly creates a seven-element 
array. The loop starts with index 0 and ends with index 6 .  Each line is correctly output. 
Therefore, option B is correct.
30. A,B. Options E and F are incorrect because they do not compile. List is an interface and 
does not have a constructor. ArrayList has a constructor but not one that takes individual 
elements as parameters. Options C and D are incorrect because List.of() creates an 
immutable list. Trying to change one of its values causes an exception at runtime.
Options A and B are correct. Since we are creating the list from an array, it is a fixed size. We 
are allowed to change elements. When successfully completing this code, museums is [Art, 
Science] for both solutions.
31. F. The Wash class takes a formal type parameter named T. Options A and E show the 
best ways to call it. These option declare a generic reference type that specifies the type is 
String. Option A uses local variable type inference, whereas option E uses the diamond 
syntax to avoid redundantly specifying the type of the assignment.
Options B, C, and D show that you can omit the generic type in the reference and still  
have the code compile. You do get a compiler warning scolding you for having a raw type. 
But compiler warnings do not prevent compilation. With the raw type, the compiler treats 
T as if it is of type Object. That is OK in this example, because the only method we call 
is toString() implicitly when printing the value. Since toString() is defined on the 
Object class, we are safe, and options B, C, and D work. Since all can fill in the blank, 
option F is the answer.
32. B. Options A, C, and D represent 3×3 2D arrays. Option B best represents the array in the 
code. It shows there are three different arrays of different lengths.
33. B,E. The goal is to write code that sorts in descending order. Option A sorts ascendingly and 
option B sorts descendingly. Similarly, option C sorts ascendingly and option E sorts descend-
ingly. Option D attempts to call the reverse() method, which is not defined.
34. B. When creating an array object, a set of elements or size is required. Therefore, lion and 
bear are incorrect. The brackets containing the size are required to be after the type, making 
ohMy incorrect. The only one that is correct is tiger, making the correct answer option  B .
35. C. This code creates a two-dimensional array of size 1×2. Lines m1 and m2 assign values to 
both elements in the outer array. Line m3 attempts to reference the second element of the 
outer array. Since there is no such position, it throws an exception, and option C is correct.
36. C. All four of these return immutable collections. Options B and D take a varargs rather 
than a List. Option A returns a List, not a Set. Option C meets both our requirements.
37. C,E. The code sorts before calling the binarySearch() method, so it meets the precon-
dition for that method. The target string of "RedHat" is not found in the sorted array. If it 
were found, it would be between the second and third elements. The rule is to take the neg-
ative index of where it would be inserted and subtract 1 .  It would need to be inserted as the 
third element. Since indexes are zero-based, this is index 2 .  We take the negative, which is -2, 
and subtract 1, giving -3 .
The target string of "Mac" is the second element in the sorted array. Since array indices begin 
with zero, the second position is index 1 .  This makes the answer options C and  E .
38. D. Line x1 returns a Set of map entries. Set does not have a getKey() method, so line x2 
does not compile, and option D is the answer.
39. A,C,D. The offerLast() and offer() methods insert an element at the back of the 
queue, while the offerFirst() method inserts the element at the front of the queue.  
This means the queue initially contains [snowball, sugar, minnie]. The poll() 
method returns the element at the front of the queue and removes it. In this case, it prints 
snowball, and the queue is reduced from three elements to [sugar, minnie]. Then, the 
removeFirst() method removes sugar, leaving the queue as only containing [minnie]. 
Further, the queue becomes one smaller, and 1 is printed. These are options A, C, and  D .
40. B. All of the variables except nums2b point to a 4D array. Don’t create a 4D array in prac-
tice; it’s confusing. The options show that the brackets, [], can be before or after the variable 
in any combination. Option B is the answer because nums2b points to a 3D array. It has only 
three pairs of brackets before the variable and none after. By comparison, nums2a has three 
pairs of brackets before the variable and the fourth pair of brackets after.
41. C. Option E is the longest way to specify this code. Options A and D shorten it by using the 
diamond operator (<>). Options A and B shorten it using var. Option C does not compile 
because the diamond operator cannot be used on the left side of the assignment.
42. C. The Arrays.compare() method looks at each element in turn. Since the first elements 
are different, we get the result of comparing them. In this case, we get a positive number 
because 3 is larger than 2, and option C is correct.
43. E. List.of() makes an immutable list. Attempting to sort throws an exception so option E 
is the answer. If we were calling, Arrays.asList() instead, option C would be the answer 
because it is the only option to sort ascendingly by length.
44. C. Line 20 creates a List<Character>. Line 21 does not compile because it is the wrong 
type. Char should be Character. Line 22 uses unboxing to get a primitive. Line 23 also 
compiles because Character can be unboxed and widened to int automatically. How-
ever, line 24 does not compile as Integer and Character are not in the same class hier-
archy. The Character value cannot be unboxed, widened to int, and then autoboxed as 
Integer. Finally, line 25 is correct as Character is a subclass of Object. Since two lines 
of code fail to compile, option C is the answer.
45. B. This one is tricky since the array brackets, [], are split up. This means that bools is a  
3D array reference. The brackets both before and after the variable name count. For  
moreBools, it is only a 2D array reference because there are only two pairs of brackets 
next to the type. In other words, boolean[][] applies to both variables. Then bools gets 
another dimension from the brackets right after the variable name. However, moreBools 
stays at 2D, making option B correct.
46. E. A custom sort order is specified using a Comparator to sort in descending order.  
However, this Comparator is not passed when searching. When a different sort order is 
used for searching and sorting, the result is undefined. Therefore, option E is correct.
47. C. The binarySearch() method requires a sorted array in order to return a correct result. 
If the array is not sorted, the results of a binary search are undefined.
48. B,F. The <> is known as the diamond operator. Here, it works as a shortcut to avoid 
repeating the generic type twice for the same declaration. On the right side of the expression, 
this is a handy shortcut. Java still needs the type on the left side, so there is something to 
infer. Positions Q and S are on the right side, making option B correct. In this question, the 
generic type is never specified, so it is Object. Since it is not String, option F is correct.
49. B,D. Since no arguments are passed from the command line, this creates an empty  
array. Sorting an empty array is valid and results in an empty array printed on line 6 . 
Then line 7 attempts to access an element of the empty array and throws an 
ArrayIndexOut OfBoundsException. Therefore, options B and D are correct.
50. A. The generic declaration on line R is not valid due to the question mark (?) wildcard. 
While a question mark is allowed on the left side of a declaration, it is not allowed when 
specifying a constraint on a class. Since line R does not compile, option A is the answer.
51. E. Line 6 assigns an int to a cell in a 2D array. This is fine. Line 7 casts to a general 
Object[]. This is dangerous, but legal. Why is it dangerous, you ask? That brings us to 
line 8 .  The compiler can’t protect us from assigning a String to the int[] because the ref-
erence is more generic. Therefore, line 8 throws an ArrayStoreException because the 
type is incorrect, and option E is correct. You couldn’t have assigned an int on line 8 either 
because obj[3] is really an int[] behind the scenes and not an int.
52. D. TreeSet does not allow null values because it needs to compare the values.  
While HashSet does call hashCode(), it knows to skip that call if the value is null. 
ArrayList and LinkedList do not make method calls on their contents. Three of the 
four allow inserting null values, making option D the answer.
53. B. Unfortunately, you do have to memorize two facts about sort order. First, numbers sort 
before letters. Second, uppercase sorts before lowercase. Since, the first value is 3 and the last 
is three, option B is correct.
54. C. Since the brackets in the declaration are before the variable names, the variable type 
boolean[][][] applies to both variables. Therefore, both bools and moreBools can 
reference a 3D array.
55. D. Line 25 does not compile, making option D the answer. On an ArrayList, the method 
to get the number of elements is size(). The length() method is used for a String or 
StringBuilder. If this were fixed, the answer would be option E .   Line 23 empties the 
ArrayList. Then line 24 attempts to access an index that is not present.
56. C. The ? is an unbounded wildcard. It is used in variable references but is not allowed in 
declarations. In a static method, the type parameter specified inside the <> is used in the 
rest of the method declaration. Since it needs an actual name, options A and B are incorrect. 
We need to specify a type constraint so we can call the add() method. Regardless of whether 
the type is a class or interface, Java uses the extends keyword for generics. Therefore, 
option D is incorrect, and option C is the answer.
57. D. Java requires having a sorted array before calling the binarySearch() method. Since 
the array is not sorted, the result is undefined, and option D is correct. It may happen that 
you get 1 as the result, but this behavior is not guaranteed. You need to know for the exam 
that this is undefined even if you happen to get the “right” answer.
58. A. A multidimensional array is created with multiple sets of size parameters. The first line 
should be char[] ticTacToe = new char[3][3];. Therefore, option A is the answer.
59. B. On a stream, the filter() method only keeps values matching the lambda. The 
removeIf() does the reverse on a Collection and keeps the elements that do not match. 
In this case, that is Austin and Boston, so option B is correct.
60. D. The names.length value is the number of elements in the array. The last valid index in 
the array is one less than names.length. In Java, arrays do not resize automatically. There-
fore, the code throws an ArrayIndexOutOfBoundsException, and option D is correct.
61. A. An ArrayList expands automatically when it is full. An array does not, making option 
A the answer. The other three statements are true of both an array and an ArrayList.
62. C. The forEach() method that takes one parameter is defined on the Collection inter-
face allowing options A and B to fill in the blank. Option C requires you to notice that only 
one generic parameter is passed. A Map needs two parameters, so option C is the answer.
63. D. Option A is incorrect because coll could be any type, which doesn’t necessarily allow 
exceptions to be added. Option B is incorrect because neither add() method compiles. We 
could have Collection<IllegalStateException> as a parameter. That would not 
allow either type to be added. Finally, option C is incorrect as the second add() method 
does not compile because broader types than the generic allows are a problem when adding 
to coll. Therefore, option D is the answer.
64. A,D. Lines 35–38 create a Map with three key/value pairs. Lines 40–43 sort just the values 
ascendingly by year. Lines 45 and 48 show you can assign the Integer values to an int 
via unboxing or an Integer directly. Line 46 shows the values are properly sorted, making 
option A correct. Finally, line 48 throws an exception because sorted.size() returns 3 
and the maximum index in the List is 2 .  This makes option D correct as well.
65. C. Arrays are indexed using numbers, not strings, making options A and B incorrect. Since 
array indexes are zero-based, option C is the answer.
66. B. This code shows a proper implementation of Comparable. It has the correct method 
signature. It compares the magazine names in alphabetical order. Remember that upper-
case letters sort before lowercase letters. Since Newsweek starts with uppercase, option B 
is correct.
67. B. Options A and C are incorrect because a generic type cannot be assigned to another direct 
type unless you are using upper or lower bounds in that statement. Now, we just have to 
decide whether a lower or upper bound is correct for the T formal type parameter in Wash. 
The clue is that the method calls size(). This method is available on Collection, and all 
classes that extend/implement it. Therefore, option B is correct.
68. D. In Java, arrays are indexed starting with 0. While it is unusual for the loop to start with 1,
this does not cause an error. What does cause an error is the loop ending at data.length, 
because the <= operator is used instead of the < operator. The last loop index is 6, not 7 .  On 
the last iteration of the loop, the code throws an ArrayIndexOutOfBoundsException. 
Therefore, option D is correct.
69. B. This array has two elements, making listing.length output 2. While each array 
element does not have the same size, this does not matter because we are only looking at the 
first element. The first element has one. This makes the answer option  B .
70. E. The addFirst() and addLast() methods are on the Deque interface. While  
Array Deque does implement this interface, it also implements Queue. Since the q variable 
is of type Queue, these methods do not compile, and option E is the answer. If the correct 
interface were used, minnie minnie 3 would be printed.
71. D. The code does compile, making option A incorrect. Line 13 creates a fixed-size list. While 
we are using var, the type is List<Integer>. Line 14 successfully changes the contents of 
the list to [3, null, 4]. Line 15 automatically unboxes to the primitive 3 .  Line 16 has 
a problem. The list has a null value at index 1 .  This cannot be unboxed to a primitive and 
throws a NullPointerException. Therefore, option D is the answer. If line 16 were com-
mented out, line 17 would have thrown an exception because Java uses zero based indexes, 
and there is no element at index 3 .
72. F. We need to first sort descendingly and then ascendingly by first character. Options A, B, 
and C are missing the logic to sort descendingly. Options D and E call the andCompare() 
and thenCompare() methods, which do not exist. Option F is correct.
73. B,C. Array indexes begin with zero. FirstName is the name of the class, not an argument. 
The first argument is Wolfie, making option B correct. There is not a second argument, and 
the array is of size 1, so option C is also correct.
74. C. This one is tricky. Line 11 creates an ArrayList with a generic type Object rather than 
Integer. This is allowed since we aren’t trying to assign any of the values to an int or 
Integer after getting them from pennies. This gives us the list [1, 2, 3, 4].
The next trick is that there are two remove() methods available on ArrayList. One 
removes an element by index and takes an int parameter. The other removes an element by 
value and takes an Object. On line 16, the int primitive is a better match, and the element 
with index 2 is removed, which is the value of 3 .  At this point, we have [1, 2, 4].
Then on line 17, the other remove() method is called because we are explicitly using the 
wrapper object. This deletes the object that is equal to 1, and now we have [2, 4]. This 
brings us to option C as the answer.
75. C,D. The code will output 0 when the array is sorted in ascending order since flower 
will be first. Option C is the most straightforward way of doing this, making it one of the 
answers. Reversing the order of the variables or adding a negative sign sorts in descending 
order makes options A, B, E, F, and G incorrect. Doing both is a complicated way of sorting 
in ascending order, making option D the other correct answer.
76. B. The elements of the array are of type String rather than int. Therefore, we use alpha-
betical order when sorting. The character 1 sorts before the character 9, alphabetically mak-
ing option A incorrect. Shorter strings sort before longer strings when all the other characters 
are the same, making option B the answer.
77. D. This code is correct. Line r1 correctly creates a 2D array. The next three lines correctly 
assign a value to an array element. Line r3 correctly outputs 3 in a row!
78. A,D,F. Line 40 does not compile since getOrDefault() requires two parameters. This 
makes option A the first answer. The rest of the code does compile. Option D is the next 
answer because getOrDefault() returns the value from the map when the key is present. 
Finally, option F is correct because getOrDefault() returns the second parameter when 
the key is not present.
79. E. Lines 18 and 19 create a list with five elements. Line 20 makes a set with the same  
five elements. Line 21 does not change the contents of the set since sets must have  
unique  elements. The loop on line 22 tries to delete elements but instead throws a  
Concurrent ModificationException, making option E the answer.
80. C. Option C is correct because all the types being added are of type Exception or direct 
subclasses.
1. F. The source is the first operation, and the terminal operation comes last, making option F 
the answer. You need to know this terminology.
2. B. The lambda expression s -> true is valid, making options A, C, and D incorrect. Paren-
theses, (), are not required on the left-hand side if there is only one variable. Braces, {}, 
are not required if the right-hand side is a single expression. Parameter data types are only 
required if the data type for at least one parameter is specified; otherwise, none are required. 
The remaining choice, the arrow operator, ->, is required for all lambda expressions, making 
option B the correct answer.
3. C. The Supplier functional interface does not take any inputs, while the Consumer 
functional interface does not return any data. This behavior extends to the primitive ver-
sions of the functional interfaces, making option C the correct answer. Option A is incorrect 
because IntConsumer takes a value, while LongSupplier returns a value. Options B 
and D are incorrect because Function and UnaryOperator both take an input and pro-
duce a value.
4. F. A List instance, which inherits the Collection interface, does not have a parallel() 
method. Instead, parallelStream() must be used, making option F correct. If the code
was corrected to use parallelStream(), then the first and third streams would be con-
sistently printed in the same order. Remember that the forEachOrdered() method forces 
parallel streams to run in sequential order. The order of the second operation would be 
unknown ahead of time, since it uses a parallel stream.
5. A,E. The UnaryOperator and BiFunction return a generic argument, such as  
Double, making options A and E correct. Option B is incorrect because all predicate 
functions return boolean. Option C is incorrect because BiOperator does not exist in 
the java.util.function package. The correct name is BinaryOperator. Option D is 
incorrect because all consumer functions return void. Finally, option F is incorrect because 
BiSupplier does not exist in the java.util.function package. Supplier functions 
return values, and Java does not support methods with more than one return type.
6. B. The stream pipeline is correct and filters all values out that are 10 characters or smaller. 
Only San Francisco is long enough, so c is 1 . The stream() call creates a new object, 
so stream operations do not affect the original list. Since the original list is still 3 elements, 
option B is correct.
7. B,C,E. Interface X is tricky. If it returned a boolean primitive, option A would be correct  
as Predicate returns a boolean. However, it returns a wrapper object, so it has to be a 
Supplier, making option B the answer instead.
Interface Y and Z are more straightforward as a Comparator and Consumer, respectively. 
This makes options C and E the final two answers.
8. C. Option A is incorrect because a pipeline still runs if the source doesn’t generate any items 
and the rest of the pipeline is correct. Granted, some of the operations have nothing to do, 
but control still passes to the terminal operation. Option B is incorrect because intermediate 
operations are optional. Option C is the answer. The terminal operation triggers the pipeline 
to run. Option D is incorrect because the code would not compile at all if the version of Java 
were too old.
9. A. The LongSupplier interface does not take any input, making option D incorrect. It also 
uses the method name getAsLong(). The rest of the functional interfaces all take a long 
value but vary on the name of the abstract method they use. LongFunction contains 
apply() and LongPredicate contains test(), making options B and C, respectively, 
incorrect. That leaves us with LongConsumer, which contains accept(), making option A 
the correct answer.
10. F. The correct method to obtain an equivalent sequential stream of an existing stream is 
sequential(), which is inherited by any class that implements BaseStream<T>. Since 
this isn’t an option, option F is correct. Note that unordered() creates a stream that can be 
evaluated in any order, but it can still be processed in a sequential or parallel stream.
11. B. Option A is incorrect because the lambda expression is missing a semicolon (;) at the 
end of the return statement. Option C is incorrect because the local variable test is used 
without being initialized. Option D is also incorrect. The parentheses are required on the 
left-hand side of the lambda expression when there is more than one value or a data type is 
specified. Option B is the correct answer and the only valid lambda expression.
12. B,D. The second line throws a NullPointerException when you pass a null reference 
to the of() method. The others compile and run successfully, making option B correct. The 
first and third lines return false because they represent an empty Optional. This makes 
option D the other answer.
13. D. Both are functional interfaces in the java.util.function package, making option 
A true. Additionally, both lack parameters, making option B true. The major difference bet-
ween the two is that Supplier<Double> takes the generic type Double, while the other 
does not take any generic type and instead uses the primitive double. For this reason, 
options C and E are true statements. For Supplier<Double> in option C, remember that 
the returned double value can be implicitly autoboxed to Double. Option D is the correct 
answer. Lambdas for Supplier<Double> can return a null value since Double is an 
object type, while lambdas for DoubleSupplier cannot; they can only return primitive 
double values.
14. A. Even though a parallel stream is used, the forEachOrdered() method forces the 
stream to operate in the order of its data source. The code compiles and runs without issue 
printing 12345 every time, and making option A correct. If forEach() was used instead, 
then the output would vary at runtime.
15. C. The first line that contains the lambda expression will actually compile with any of the 
functional interfaces listed in the options. The stream operation, though, will compile only 
if ToIntFunction<Integer> is used. It requires this functional interface, which takes a 
generic argument and returns int. For this reason, option C is correct. Option F is incorrect 
because sum() on an IntStream returns an int, not an OptionalInt. Note that the 
peek() operations in this stream have no effect.
16. E. Option A is incorrect because anyMatch() returns a boolean. Option B is incorrect 
because findAny() might not return 1 .  The result could be any of the three numbers. 
Option C is incorrect because there is no first() method available as a terminal operation. 
Option D is tempting because there is a min() method. However, since we are working with 
a Stream (not a primitive stream like IntStream), this method requires a Comparator as 
a parameter. Therefore, option E is the answer.
17. D. Line 8 does not compile. String::new is a constructor reference. This constructor refer-
ence is equivalent to writing the lambda () -> new String(). It participates in deferred 
execution. When it is executed later, it will return a String. It does not return a String on 
line 8, though. The method reference is a Supplier<String>, which cannot be stored in 
list. Since the code does not compile, option D is correct.
18. C. The lambda (s,p) -> s+p takes two arguments and returns a value. For this reason, 
options A and B are incorrect because BiConsumer does not return any values. Option E 
is also incorrect, since Function takes only one argument and returns a value. This leaves 
us with options C and D, which both use BiFunction, which takes two generic arguments 
and returns a generic value. Option D is incorrect because the datatype of the unboxed sum 
s+q is int, and int cannot be both autoboxed and implicitly cast to Double. Option C is 
correct. The sum s+p is of type double, and double can be autoboxed to Double.
19. D. The word reduction is used with streams for a terminal operation, so options A, B, and C 
are incorrect. Option E describes a valid terminal operation like anyMatch(), but is not a 
reduction. Option D is correct because a reduction has to look at each element in the stream 
to determine the result.
20. C,D. The class compiles and runs without throwing an exception, making option C correct 
and options A, B, and F incorrect. The class defines two values that are incremented by mul-
tiple threads in parallel. The first IntStream statement uses an atomic class to update a 
variable. Since updating an atomic numeric instance is thread-safe by design, the first number 
printed is always 100, making option D correct. The second IntStream statement uses an 
int with the pre-increment operator (++), which is not thread-safe. It is possible two threads 
could update and set the same value at the same time, a form of race condition, resulting in a 
value less than 500 and making option E incorrect.
21. A. The filter() method either passes along a given element or doesn’t, making options 
D, E, and F incorrect. The flatMap() method doesn’t pass along any elements for 
empty streams. For nonempty streams, it flattens the elements, allowing it to return zero 
or more elements. This makes option B incorrect. Finally, the map() method applies a 
one-to-one function for each element. It has to return exactly one element, so option A is the 
correct answer.
22. A,B,D. To begin with, ToDoubleBiFunction<T,U> takes two generic inputs and returns  
a double value. Option A is correct because it takes an Integer and Double and returns  
a Double value that can be implicitly unboxed to double. Option B is correct because  
long can be implicitly cast to double. While we don’t know the data types for the input 
arguments, we know that some values, such as using Integer for both, will work. Option  
C cannot be assigned and does not compile because the variable v is of type Object and 
Object does not have a length() method. Option D is correct. The variable y could 
be declared Double in the generic argument to the functional interface, making y/z a 
double return value. Option E is not correct because the lambda only has one parameter. 
Finally, option F is incorrect because the interface uses the class Double rather than primi-
tive double.
23. C. The correct method to obtain an equivalent parallel stream of an existing stream is 
parallel(), which is inherited by any class that implements BaseStream<T>. For this 
reason, option C is correct.
24. A. The lambda is a Function<Integer, ArrayList>. We need a constructor reference 
that uses the new keyword where a method name would normally go in a method reference. 
It can implicitly take zero or one parameters just like a method reference. In this case, we 
have one parameter, which gets passed to the constructor. Option A is correct. Options B, C, 
and D use syntax that is not supported with method references.
25. C. The average() method returns an OptionalDouble. This reflects that it doesn’t make 
sense to calculate an average when you don’t have any numbers. Similarly, max() returns 
an OptionalDouble because there isn’t a maximum of no number. By contrast, counting 
without any numbers gives the long number 0 and summing gives the double number  0 .0 . 
Since only two methods matches the desired return type, option C is correct.
26. D,E. The BiPredicate interface takes two generic arguments and returns a boolean 
value. Next, DoubleUnaryOperator and IntUnaryOperator exist and transform values 
of type double and int, respectively. Last, ToLongFunction takes a generic argument 
and returns a long value. That leaves options D and E, which is the answer. While there are 
ObjDoubleConsumer and ObjIntConsumer functional interfaces, there is no such thing 
as ObjectDoubleConsumer or ObjectIntConsumer. Remember that Object is abbre-
viated to Obj in all functional interfaces in java.util.function.
27. A. The findAny() method can return the first, last, or any element of the stream, regardless 
of whether the stream is serial or parallel. While on serial streams this is likely to be the first 
element in the stream, on parallel streams the result is less certain. For this reason, option 
A is the correct answer. The anyMatch() and count() methods produce the same result, 
regardless of whether the stream is serial or parallel. The rest of the operations force the 
stream to behave in a sequential manner when applied to an ordered stream, even if it is 
parallel. Note that the behavior is not the same on an unordered stream. For example,  
findFirst() can return any element when applied to an unordered stream.
28. C. The result of the source and any intermediate operations are chained and eventually 
passed to the terminal operation. The terminal operation is where a nonstream result is gen-
erated, making option C correct.
29. C. The groupingBy() collector always returns a Map (or a specific implementation  
class of Map), so options D, E, and F are incorrect. The other two are definitely possible.  
To get one, you can group using a Function that returns an Integer such as  
s.collect(groupingBy(String::length)). To get the other, you need to  
group using a Function that returns a Boolean and specify the type, such as  
s.collect(groupingBy(String::isEmpty, toCollection(HashSet::new))). 
Therefore, option C is correct.
30. F. The flatMap() method works with streams rather than collections. Line 18 is problem-
atic because the return value is not a stream. Since the code does not compile, option F is 
correct. If the lambda was changed to x -> x.stream(), option B would be the answer.
31. E. Since no generic type is specified, list is a LinkedList<Object>. Line w compiles 
because no generic type is specified. However, Java only allows you to operate on a stream 
once. The final line of code throws an IllegalStateException because the stream has 
already been used up, making option D correct.
32. D. The code does not compile, so options A, B, and E are incorrect. The 
IntUnary Operator functional interface is not generic, so the argument 
IntUnaryOperator<Integer> in the takeTicket() does not compile, making option 
D the correct answer. The lambda expression compiles without issue, making option C 
incorrect. If the generic argument <Integer> was dropped from the argument declara-
tion, the class would compile without issue and output 51 at runtime, making option B the 
correct answer.
33. A,C,E. Options A, C, and E are the precise requirements for Java to perform a concurrent 
reduction using the collect() method, which takes a Collector argument. Recall 
from your studies that a Collector is considered concurrent and unordered if it has the 
Collector.Characteristics enum values CONCURRENT and UNORDERED, respectively. 
The rest of the options are not required for a parallel reduction.
34. C,E. While it is common for a Predicate to have a generic type, it is not required. How-
ever, it is treated like a Predicate of type Object if the generic type is missing. Since 
startsWith() does not exist on Object, line 28 does not compile.
Line 34 would be a correct lambda declaration in isolation. However, it uses the variable s, 
which is already taken from the main() method parameter. This causes a compiler error 
on line 34 .  These are the only two compiler errors, making option C correct. If Predicate 
were changed to Predicate<String> and lambda variable were changed to x, the 
Consumer would in fact print pink, making option E the other answer.
35. A. Option A is the correct answer because BiPredicate takes two generic types and 
returns a primitive boolean value. Option B is incorrect, since CharSupplier does not 
exist in java.util.function. Option C is also incorrect, since LongFunction takes 
a primitive long value and returns a generic type. Remember, Java only includes primitive 
functional interfaces that operate on double, int, or long. Option D is incorrect because 
UnaryOperator takes a generic type and returns a generic value. Finally, option E is incor-
rect because TriDoublePredicate is not a built-in functional interface.
36. B,E. An accumulator in a serial or parallel reduction should be associative and stateless. In 
a parallel reduction, problematic accumulators tend to produce more visible errors. Option 
A is not associative, since (a-b)-c is not the same as a-(b-c) for all values a, b, and c. 
Options C and D are incorrect because they represent stateful lambda expressions, which 
should be avoided especially on parallel streams. Option F doesn’t even compile, since 
the return type is a boolean, not an Integer. That leaves us with the correct answers, 
options B and E .  While these accumulators may not seem useful, they are both stateless and 
associative, which meets the qualifications for performing a reduction.
37. D. The Optional class has an isPresent() method that doesn’t take any parameters. It 
returns a boolean and is commonly used in if statements. There is also an ifPresent() 
method that takes a Consumer parameter and runs it only if the Optional is nonempty. 
The methods isNotNull() and forEach() are not declared in Optional. Therefore, 
option D is correct.
38. B. The lambda is a Supplier<Double>. Since the random() method is static, we need 
a static method reference. It uses :: to separate the class name and method name. Option 
B is correct. Options A, C, and D use syntax that is not supported with method references.
39. D. Options A and B are incorrect because they are not operations in a stream pipeline. A 
source and the terminal operation are required parts of a stream pipeline and must occur 
exactly once. The intermediate operation is optional. It can appear zero or more times. Since 
more than once falls within zero or more, option D is correct.
40. D. All of the code compiles. The first stream source has three elements. The intermediate 
operations both sort the elements of this stream and then we request one from findAny(). 
The findAny() method is not guaranteed to return a specific element. Since we are not 
using parallelization, it is highly likely that the code will print a. However, you need to 
know this is not guaranteed. Additionally, the stream on line 28 prints Optional[a], 
Optional[b], or Optional[c]. Since only lines 23–26 print a single character, option D 
is the answer.
41. E. First, the forEach() method requires a Consumer instance. Option D can be imme-
diately discarded because Supplier<Double> does not inherit Consumer. For this same 
reason, option C is also incorrect. DoubleConsumer does not inherit from Consumer. 
In this manner, primitive functional interfaces cannot be used in the forEach() method. 
Option A seems correct, since forEach() does take a Consumer instance, but it is missing 
a generic argument. Without the generic argument, the lambda expression does not com-
pile because the expression p<5 cannot be applied to an Object. Option B is also close, 
however, a Double cannot be passed to an Integer. The correct functional interface is 
Consumer<Double>, and since that is not available, option E is the correct answer.
42. A. Option A is the invalid lambda expression because the type is specified for the variable 
j, but not the variable k. The rest of the options are valid lambda expressions. To be a valid 
lambda expression, the type must be specified for all of the variables, as in option C, or none 
of them, as in options B and  D .
43. B. The code compiles and runs without issue. The three-argument reduce() method 
returns a generic type, while the one-argument reduce() method returns an Optional. 
The concat1() method is passed an identity "a", which it applies to each element, result-
ing in the reduction to aCataHat. The lambda expression in the concat2() method 
reverses the order of its inputs, leading to a value of HatCat. For these reasons, option B is 
the correct answer.
44. C. BiFunction<Double,Double,Double> and BinaryOperator<Double> both 
take two Double input arguments and return a Double value, making them equivalent 
to one another. On the other hand, DoubleFunction<Double> takes a single double 
value and returns a Double value. For this reason, it is different from the other two, making 
option C correct and option D incorrect.
45. B,E. For a concurrent reduction, the underlying type should be a thread-safe collection. For 
this reason, option A is incorrect and option E is correct. The streams must all be parallel, 
making option B correct and option F incorrect. Options C and D are incorrect, as there is no 
two-argument version of collect() within the Stream interface.
46. E. Option A is the only one of the three options to compile. However, it results in no lines 
being output since none of the three strings is empty. Options B and C do not even compile 
because a method reference cannot have an operator next to it. Option D does not compile 
because String does not have an isNotEmpty() method. Therefore, option E is correct.
47. C. The source of this stream is infinite. Sorting something infinite never finishes, so the 
stream pipeline never completes. This corresponds to option  C .
48. D. The code compiles and does not throw any exception at runtime, so options A and B are 
incorrect. The code snippet is serial, by default, so the order is predictable, making option 
F incorrect. The peek() method executes on each member of the pipeline, printing five 
numbers as the elements are then collected into a List, which gives us 345 .  They are then 
printed again, making the final output 345345 and option D correct.
49. C. The program does not compile, so option A is incorrect. The Supplier functional inter-
face normally takes a generic argument, although generic types are not strictly required, since
they are removed by the compiler. Therefore, line d1 compiles while triggering a compiler 
warning, and options B and D are incorrect. On the other hand, line d2 does cause a com-
piler error, because the lambda expression does not return a value. Therefore, it is not com-
patible with Supplier, making option C the correct answer.
50. B. First, the class uses a synchronized list, which is thread-safe and allows modification  
from multiple threads, making option E incorrect. The process generates a stream of num-
bers from 1 to 5 and sends them into a parallel stream where the map() is applied, possibly 
out of order. This results in elements being written to db in a random order. The stream 
then applies the forEachOrdered() method to its elements, which will force the parallel 
stream into a single-threaded state. At runtime, line p1 will print the results in order every 
time as 12345 .  On the other hand, since the elements were added to db in a random order, 
the output of line p2 is random and cannot be predicted ahead of time. Since the results may 
sometimes be the same, option B is the correct answer. Part of the reason that the results are 
indeterminate is that the question uses a stateful lambda expression, which, based on your 
studies, should be avoided!
51. B,F. Primitive streams, like LongStream, declare an average() method that returns an 
OptionalDouble object. This object declares a getAsDouble() method rather than a 
get() method. Therefore, option A is incorrect, and option B is correct.
By contrast, the summary statistics classes provide getters in order to access the data. The 
getAverage() method returns a double and not an OptionalDouble, which makes 
option F correct. The other options do not compile.
52. D. Remember that all Supplier interfaces take zero parameters. For this reason, the third 
value in the table is 0, making options A, C, and E incorrect. Next, DoubleConsumer and 
IntFunction each take one value, double and int, respectively. On the other hand,  
ObjDoubleConsumer takes two values, a generic value and a double, and returns void. 
For this reason, option D is correct, and option B is incorrect.
53. F. All Consumer functional interfaces have a void return type. For this reason, the first and 
last values in the table are both void, making options A, B and C incorrect. Int Function 
takes an int and returns a generic value, ruling out option  D . Finally, LongSupplier 
does not take any values and returns a long value. For this reason, option E is incorrect, and 
option F is correct.
54. A. The code compiles and runs without issue. The JVM will fall back to a single-threaded 
process if all of the conditions for performing the parallel reduction are not met. The stream 
used in the main() method is not parallel, but the groupingByConcurrent() method 
can still be applied without throwing an exception at runtime. Although performance will 
suffer from not using a parallel stream, the application will still process the results correctly. 
Since the process groups the data by year, option A is the correct answer.
55. C. This code is almost correct. Calling two different streams is allowed. The code attempts to 
use a method reference when calling the forEach() method. However, it does not use the 
right syntax for a method reference. A double colon needs to be used. The code would need 
to be changed to System.out::println to work and print two lines for each call. Since it 
does not compile, option C is correct.
56. C. First, option A does not compile, since the variables p and q are reversed, making the 
return type of the method and usage of operators invalid. The first argument p is a String 
and q is an int, but the lambda expression reverses them, and the code does not com-
pile. Option B also does not compile. The variable d is declared twice, first in the lambda 
argument list and then in the body of the lambda expression. The second declaration in the 
body of the lambda expression causes the compiler to generate a duplicate local variable 
message. Note that other than it being used twice, the expression is valid; the ternary oper-
ator is functionally equivalent to the learn() method in the BiologyMaterial class. 
Option C is the correct answer since it compiles and handles the input in the same way as the 
learn() method in the BiologyMaterial class. Option D compiles but does not return 
the same result.
57. A,F. This code does compile. Remember that imports are implied, including the static 
import for Collectors. The collector tries to use the number of characters in each stream 
element as the key in a map. This works fine for the first two elements, speak and bark, 
because they are of length 5 and 4, respectively. When it gets to meow, it sees another key 
of 4 .  The merge function says to use the first one, so it chooses bark for the value. Simi-
larly, growl is 5 characters, but the first value of speak is used. There are only two distinct 
lengths, so option A is correct.
If the stream had a null instead of "meow", the code would throw a  
NullPointer Exception, since we need to check the length of the String to determine 
which part of the Map it goes in. Since you cannot call a method on null, option F is correct.
58. A. Option A is correct as the source and terminal operation are mandatory parts of a stream 
pipeline. Option B is incorrect because a Stream must return objects. Specialized interfaces 
like IntStream are needed to return primitives. Option C is incorrect because Stream has 
methods such as of() and iterate() that return a Stream. Option D is incorrect because 
infinite streams are possible.
59. F. Trick question! The correct method to obtain an equivalent parallel stream of an existing 
IntStream is parallel(), but for an IntStream this returns another IntStream, not 
a generic Stream<T>. For this reason, option F is correct.
60. A. This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc. The Predicate 
checks if the element is greater than 5 .  With anyMatch(), the stream pipeline ends once 
element 6 is hit, and the code prints true. For the allMatch() operator, it sees that the  
first element in the stream does not match, and the code prints false. Similarly, the  
noneMatch() operator gets to the point where i is 6 and returns false because there is a 
match. Therefore, option A is correct.
61. D. Option A is incorrect because it doesn’t print out one line. The peek() method is an 
intermediate operation. Since there is no terminal operation, the stream pipeline is not exe-
cuted, so the peek() method is never executed, and nothing is printed. Options B and C 
are incorrect because they correctly output one line using a method reference and lambda, 
respectively, and don’t use any bad practices. Option D is the correct answer. It does output 
one line. However, it is bad practice to have a peek() method that has side effects like mod-
ifying a variable.
62. C. The code does not compile, so option A, D, and E are incorrect. The lambda expres-
sion compiles without issue, making option B incorrect. The task variable is of type 
UnaryOperator<Doll>, with the abstract method apply(). There is no accept() 
method defined on that interface, therefore the code does not compile, and option C is the 
correct answer. If the code was corrected to use the apply() method, the rest of it would 
compile without issue. At runtime, it would then produce an infinite loop. On each iteration 
of the loop, a new Doll instance would be created with 5, since the post-decrement (--) 
operator returns the original value of the variable, and that would be option  D .
63. D. The code compiles and does not throw any exception at runtime, so options A and B are 
incorrect. As an element goes through the pipeline, it is printed once by the peek() method, 
then once by the forEach() method. For example, 0 .1  0 .1  0 .54  0 .54  0 .6  0 .6  0 .3 
0 .3 is a possible output from this code. For this reason, option D is correct.
64. B,D,F. The findAny() method is capable to return any element of the stream regardless of 
whether it is serial, parallel, ordered, or unordered. For this reason, options B, D, and F are 
correct. Option C is actually invalid, as an unordered stream does not have a first element.
65. C. To begin with, Consumer uses accept(), making option A incorrect. Next, Function 
and UnaryOperator use apply(), making options B and D, respectively, incorrect. Finally, 
Supplier uses get(), making option C the correct answer.
66. C. Option D is incorrect as the syntax is fine. Option E is incorrect because there is a 
charAt() instance method. While option B is correct that the method takes in an int 
parameter, autoboxing would take care of conversion for us if there were no other prob-
lems. So, option B is not the answer either. Option A is not true because there are con-
structor and instance method references. This method reference could be assigned to 
BiFunction<String,Integer, Character>. However, it cannot be assigned to a 
Function. This makes option C the correct answer.
67. B,C,D. While the second and third stream operations compile, the first does not. The 
parallel() method should be applied to a stream, while the parallelStream() 
method should be applied to a Collection<E>. For this reason, option A is incorrect, and 
options B and C are correct. Neither the second or third stream operation are expected to 
produce an exception at runtime, making option D correct and option E incorrect. Note that 
calling parallel() on an already parallel stream is unnecessary but allowed. Finally, the 
output of the second and third stream operations will vary at runtime since the streams are 
parallel, making option F incorrect.
68. D. Since the code uses a BiPredicate, it takes two parameters in the test() call. The 
first is the instance of String and the second is the substring value to check. Since both 
parameters are passed in, we use the type of String in the method reference, making option 
D the correct answer.
69. C. This code compiles. It creates a stream of Ballot objects. Then it creates a map with the 
contestant’s name as the key and the sum of the scores as the value. For Mario, this is 10 + 
9, or 19, so option C is correct.
70. D. The map() method can fill in the blank. The lambda converts a String to an int, and 
Java uses autoboxing to turn that into an Integer. The mapToInt() method can also fill 
in the blank, and Java doesn’t even need to autobox. There isn’t a mapToObject() in the 
stream API. Note there is a similarly named mapToObj() method on IntStream. Since 
both map() and mapToInt() work here, option D is correct.
71. A,C. This is a correct example of code that uses a lambda. The interface has a single abstract 
method. The lambda correctly takes one double parameter and returns a boolean. This 
matches the interface. The lambda syntax is correct. Since it compiles, option C is correct. 
Finally, option A is correct because 45 is greater than 5 .
72. C. The reduction is parallel, but since the accumulator and combiner are well-behaved (state-
less and associative), the result is consistent, making option D incorrect. The identity is 1, 
which is applied to every element meaning the operation sums the values (1+1), (1+2), and 
(1+3). For this reason, 9 is consistently printed at runtime, making option C correct.
73. E. The average() method returns an OptionalDouble. This interface has a  
getAsDouble() method rather than a get() method, so the code does compile. However, 
the stream is empty, so the optional is also empty. When trying to get the value on line 12, the 
code throws a NoSuchElementException, making option E correct.
74. B,E. Options A and D are incorrect since they are missing the arrow (->), which makes them 
lambdas. Options C and F are incorrect as they try to mix lambdas and method references. 
This leaves options B and E as the answers.
75. F. Both Collectors.groupingBy() and Collectors.partitioningBy() are  
useful for turning a stream into a Map. The other two methods do not exist. The  
partitioningBy() method automatically groups using a Boolean key. However,  
we can also have a Boolean key with groupingBy(). For example, we could write  
s -> s.length() > 3 .  Therefore, option F is correct.
76. B. Option A is incorrect because "3" is a String, which is not compatible with the 
return type int required for IntSupplier. Option B is the correct answer. Although this 
will result in a divide-by-zero issue at runtime, the lambda is valid and compatible with 
IntSupplier. Option C is incorrect because the lambda expression is invalid. The return 
statement is allowed only inside a set of braces ({}). Finally, option D is incorrect. The 
method reference is used for Consumer, not Supplier, since it takes a value and does not 
return anything.
77. A. The code compiles without issue, so options C and D are incorrect. The value for distance 
is 2, which based on the lambda for the Predicate will result in a true expression, and 
Saved will be printed, making option A correct.
78. E. The correct method to obtain a parallel stream from a Collection<E> is  
parallelStream(), making option E correct.
79. C. The filter() method takes a Predicate, which requires a boolean return type from 
the lambda or method reference. The getColor() method returns a String and is not 
compatible. This causes the code to not compile and option C to be the answer.
80. B,E. The generate() and iterate() sources return an infinite stream. Further, the of() 
source returns a finite stream, which shows option B is one of the answers.
The limit() intermediate operation returns a finite stream. When given an infinite stream, 
the map() intermediate operations keeps the infinite stream, which means option E is the 
other correct answer.
81. E. Like a lambda, method references use type inference. When assigned to a local variable, 
var cannot be used because there is not enough information to infer the type. Due to this, 
lines 17, 18, and 19 do not compile.
Consumer<Object> takes a single Object argument and does not return any data. The 
classes ArrayList and String do not contain constructors that take an Object, so 
lines 14 and 15 do not compile either. Line 16 does support an Object variable, since the 
System.out.println(Object) method exists. For these reasons, option E is the correct 
answer.
82. E. Based on the reduction operation, the data types of w, y, and z are Integer, while  
the data type of x is StringBuilder. Since Integer does not define a length() 
method, both the accumulator and combiner lambda expressions are invalid, making option 
E correct.
83. C,F. The first intermediate operation, limit(1), gets rid of the null. The  
partitioningBy() method returns a map with two keys, true and false, regardless 
of whether any elements actually match. If there are no matches, the value is an empty list, 
making option C correct. If line k is removed, the code throws a NullPointerException, 
since null is neither true nor false. Therefore, option F is the other answer.
84. D. The code does not compile because flatMapToInt() requires a Function with a 
return value of IntStream, not Stream, making option D correct.
85. D. A lambda expression can match multiple functional interfaces. It matches  
DoubleUnaryOperator, which takes a double value and returns a double value.  
Note that the data type of s+1 is double because one of the operands, in this case s, is 
double. It also matches Function<String,String> since the addition (+) operator can 
be used for String concatenation. Finally, it matches IntToLongFunction, since the int 
value s+1 can be implicitly cast to long. On the other hand, the lambda expression is not 
compatible with UnaryOperator without a generic type. When UnaryOperator is used 
without a generic argument, the type is assumed to be Object. Since the addition operator 
is not defined on Object, the code does not compile due to the lambda expression body, 
making option D the correct answer. Note that if the lambda expression did not rely on the 
addition operator, such as s -> s, then UnaryOperator would be allowed by the com-
piler, even without a generic type.
86. B,D. Applying forEachOrdered() to a parallel stream forces the terminal operation to be 
performed in a single-threaded, rather than parallel, manner. For this reason, it is likely that 
it will be slower, making option B correct. Intermediate operations can still take advantage of 
parallel processing, since forEachOrdered() is only applied at the end of the pipeline. For 
this reason, option D is correct.
87. C,F. The code does not compile because the class should be IntSummaryStatistics, not 
IntegerSummaryStatistics. This makes option C correct. The purpose of using the 
summary statistics class is to avoid multiple trips through the stream pipeline, making option 
F the other answer.
88. C. Both lambda and method references can be passed to another method as a parameter and 
executed later ruling out options A and D .  One big difference is with a lambda like: () -> 
s.charAt(3). The s variable must be final or effectively final variable in both lambdas 
and method references, making option B incorrect. However, there isn’t a way to use the 
hard-coded number in a method reference. Therefore, option C is a difference and the answer.
89. E. A stream pipeline is allowed to have zero or more intermediate operations. This means 
both filter() and sorted() can be removed. The source and terminal operations are 
required, so cannot be removed. Therefore, generate() and findFirst() must stay. The 
ifPresent() call is not part of the stream pipeline. It is a method on Optional.
90. B,C,E. The orElseThrow() method throws a NoSuchElementException when the 
Optional is empty. Since this exception is not caught, a stack trace is printed. This matches 
option  B .  The overloaded method that takes a parameter throws the specified exception. 
Since we do catch an IllegalArgumentException, the code prints the message, which is 
option  C . Finally, the orElse() method returns the specified string, and option E is correct.
91. C. Predicate is an interface with one method. The method signature is boolean test(T 
t). Option C is the answer because the method accepts one parameter rather than two.
92. B,C. The BiFunction interface takes two different generic values and returns a generic 
value, taking a total of three generic arguments. Next, ToDoubleFunction takes exactly 
one generic value and returns a double value, requiring one generic argument. The  
ToIntBiFunction interface takes two generic values and returns an int value, for a total 
of two generic arguments. For these reasons, Options A, D, and E have the correct number 
of generics.
BinaryOperator<T> takes two parameters of a generic type and returns the same type. 
Therefore, only one generic is needed when declaring the type. DoubleFunction<R> takes 
a double value and returns a generic result, taking exactly one generic argument, not two. 
This makes the answer options B and  C .
93. C. To execute a parallel reduction with the collect() method, the stream or Collector 
must be unordered, the Collector must be concurrent, and the stream must be parallel. 
Since an unordered Set is used as the data source, the first property is fulfilled. To be a 
parallel reduction, though, Collectors.groupByConcurrent() should be used instead 
of Collectors.groupingBy(). In addition, parallelStream() should be called on 
the Set, instead of stream(). For these two reasons, option C is correct.
94. D. This is a correct stream pipeline. The source creates a stream of three elements. The first 
operation makes a stream of one element, one. Then that single element is made uppercase 
and sorted to complete the intermediate operations. Finally, the terminal operation prints 
ONE, which corresponds to option  D .
95. B. BinaryOperator<Long> takes two Long arguments and returns a Long value. For 
this reason, option A, which takes one argument, and option D, which takes two Integer 
values that do not inherit from Long, are both incorrect. Option C is incorrect because the 
local variable c is re-declared inside the lambda expression, causing the expression to fail 
to compile. The correct answer is option B because intValue() can be called on a Long 
object. The result is then be cast to long, which is autoboxed to Long.
96. A. BooleanSupplier is the only functional interface that does not involve double, 
int, or long, making option A the correct answer. The rest of the functional interfaces are 
not found in java.util.function. Java does not have built-in support for primitive 
functional interfaces that include char, float, or short.
97. D,F. Certain stream operations, such as limit() or skip(), force a parallel stream to 
behave in a serial manner, so option A is incorrect, and option F is correct. Option B is 
also incorrect. The stream must be explicitly set to be parallel in order for the JVM to 
apply a parallel operation. Option C is incorrect because parallel stream operations are not 
synchronized. It is up to the developer to provide synchronization or use a concurrent col-
lection if required. Option D is also correct. The BaseStream interface, which all streams 
inherit, includes a parallel() method. Of course, the results of an operation may change 
in the presence of a parallel stream, such as using a problematic (non-associative) accumu-
lator. For this reason, option E is incorrect.
98. D. The sorted() method allows an optional Comparator to be passed as a reference. 
However, Comparator.reverseOrder() does not implement the Comparator inter-
face. It takes zero parameters instead of the required two. Since it cannot be used as a 
method reference, the code does not compile, and option D is correct.
99. F. The mapToDouble() method compiles. However, it converts 9 into 9.0 rather than 
the single digit 9 .  The mapToInt() method does not compile because a long cannot be 
converted into an int without casting. The mapToLong() method is not available on 
LongStream so it does not compile. It is available on DoubleStream, IntStream, and 
Stream implementations. Since none of the options outputs the single digit 9, option F is 
correct.
100. E. The code does not compile because the lambda expression p -> p*100 is not compat-
ible with the DoubleToIntFunction functional interface. The input to the functional 
interface is double, meaning p*100 is also double. The functional interface requires 
a return value of int, and since double cannot be implicitly cast to int, the code does 
not compile, making option E the correct answer. If the correct cast was applied to make 
(p*100) an int, then the rest of the class would compile and 250 would be printed at 
runtime, making option C correct.
101. A,E. Stateful lambda expressions should be avoided with both serial and parallel streams 
because they can lead to unintended side effects, making option A correct. A common way 
to remove a stateful lambda expression that modifies a List is to have the stream opera-
tion output a new List. For this reason, option E is correct. Options D and F are incorrect 
because while a concurrent or synchronized list may make the stream operation thread-safe, 
they are still stateful lambda expressions.
102. E. The code does not compile, making option E the answer. In particular, the call to 
test() should have one parameter instead of two.
103. B. Lazy evaluation delays execution until it is needed. Option B is the only one that 
matches this requirement. While option A is true, this can be done without lazy evaluation. 
Option C requires parallelization rather than deferred execution. Option D is incorrect as 
data loss is bad. Finally, pipelines are run by the computer, which does not get tired.
104. F. The distinct() and filter() methods can reduce the number of elements in 
a stream but do not change the generic type, making options A and E incorrect. The 
iterate() method creates a new stream and cannot be applied to an existing stream, 
making option B incorrect. The peek() and sorted() methods do not alter the generic 
type of the stream, making options C and D incorrect. For these reasons, option F is correct.
105. B,F. Option B fills in the first blank because BiFunction includes the apply() method. 
DoubleUnaryOperator contains the applyAsDouble() method, making option F 
correct. For the exam, pay attention to methods that have a different name for primitives.
106. D. The forEachOrdered() method is available on streams, not collections. For this 
reason, line q1 does not compile. and option D is correct. If the forEach() method was 
used instead, then the code would compile with the values printed on line q1 varying at 
runtime and the values printed on line q2 being consistent.
107. A. The sorted() method takes an optional Comparator as the parameter, which takes 
two String parameters and returns an int. Option A is correct because the lambda imple-
ments this interface. Option B is incorrect because the method reference doesn’t take any 
parameters, nor does it return an int. While generate() starts with an infinite stream, 
the limit() intermediate operation immediately makes it finite. Finally, the distinct() 
intermediate operation gives us one star instead of three.
108. D. Options A, B, and C are true statements about functional interfaces. A lambda may be 
compatible with multiple functional interfaces, but it must be assigned to a functional inter-
face when it is declared or passed as a method argument. Also, a method can be created 
with the return type that matches a functional interface, allowing a lambda expression to be 
returned. Option D is the correct answer. Deferred execution means the lambda expression 
is not evaluated until runtime, but it is compiled. Compiler errors in the lambda expression 
will still prevent the code from compiling.
109. D. This code generates an infinite stream of the number 1. The Predicate checks if the 
element is greater than 5 .  This will never be true. With allMatch(), the stream pipeline 
ends after checking the first element. It doesn’t match, so the code prints false. Both  
anyMatch() and noneMatch() keep checking and don’t find any matches. However, 
they don’t know if a future stream element will be different, so the code executes infinitely 
until the process is terminated. Therefore, option D is correct.
110. D. To start with, line 5 does not compile because Function takes two generic arguments, 
not one. Second, the assignment statement on line 7 does not end with a semicolon (;), so 
it also does not compile. Finally, the forEach() method on line 10 requires a Consumer, 
not a Function, so this line does not compile. For these three reasons, option D is the 
correct answer.
111. A,D,E. The findFirst() method always returns the first element on an ordered stream, 
regardless if it is serial or parallel, making options A and E correct. Option D is also correct, 
as it is free to return any element if the stream is unordered. Option C is actually invalid, as 
an unordered stream does not have a first element.
112. E. The only one of these references to compile is option D. However, the original code 
prints Carrying 1 .  The version with a method reference would just print 1 .  Option E is 
the answer because this is not the same output.
113. F. A stream cannot be used again once it is executed. Line 21 creates a stream. Line 22 
creates a second stream; however, the reference is lost on line 23 .  Lines 23 and 24 add 
intermediate operations to the stream that was created on line 21 .  Due to lazy evaluation, 
they do not run it. Line 25 does execute the stream pipeline and prints 0 .  However, line 
26 attempts to execute the same stream and throws an IllegalStateException. This 
matches option  F .
114. A,B,F. Options A and B are correct because the type may be var or omitted in a lambda. 
If there are multiple parameters, all must be handled the same way. Option C is tricky but 
incorrect. While a lambda can have zero parameters, a Predicate cannot. A Predicate 
is defined as a type mapping to a boolean.
Option D is clearly incorrect as -> separates the parts of a lambda. Options E and F are 
similar. Option E is incorrect because return is allowed only when the braces are present. 
Option F is correct.
115. E. The newValue variable is locally scoped to the lambda. It is not available outside the 
lambda, so the println() does not compile, and option E is the answer.
116. D. The DoubleToLongFunction interface takes a double argument and returns a long 
value. Option A is compatible since the int value 1 can be implicitly cast to long, and 2L 
is already a long. Option B is also compatible, since the double value  10 .0*e is explicitly 
cast to int then implicitly cast to long. Next, option C is compatible because an explicit 
cast of the double to a long value is used. Option D cannot be assigned and is the correct 
answer. Although the Double class does have a longValue() method, the left-hand side 
of the lambda expression must use the primitive double, not the wrapper Double. This 
lambda expression violates the signature of the functional interface, since it allows Double 
values to be sent to the interface, including those that could be null.
117. B,D. Option A is incorrect because sets are unordered. Options C and F are incorrect 
because the correct method call is parallelStream(). Option E is incorrect because the 
accumulator and combiner in the divide() method are not well-behaved. In particular, 
they are not associative and in a parallel stream, could produce various results at runtime. 
On a serial ordered stream, though, the results will be processed sequentially and in a pre-
dictable order, making option B correct. Option D is correct because the stream has only 
one element, so the identity is the only thing that will be applied.
118. C. Four of the five examples print miny. Option C does not compile. The difference is that 
partitioningBy() requires a Predicate that returns a boolean. When getting a 
question like this on the exam, focus on the differences between the provided options.
119. D. The correct method to obtain an equivalent parallel stream of an existing stream is 
parallel(), which is inherited by any class that implements BaseStream<T> including 
the primitive streams. For this reason, option D is correct.
120. C. Method references are a shorter way of writing lambdas, and all method references can 
be expanded to lambdas. However, this does not apply in reverse. Consider the lambda:  
() -> s.charAt(n). The n variable can only be an effectively final variable in lambdas, 
but not in method references. Since only method references can always be converted, option 
C is correct.
121. D. First, options A and B are incorrect because the second functions for both return 
a double or Double value, respectively. Neither of these values can be sent to a 
UnaryOperator<Integer> without an explicit cast. Next, option C is incorrect. The 
first functional interface Function<Double,Integer> takes only one input, but the dia-
gram shows two inputs for the first functional interface.
That leaves us with option  D . The first functional interface  
BiFunction<Integer,Double,Integer> takes an int, which can be implicitly auto-
boxed to Integer, and a Double and returns an Integer. The next functional interface, 
BinaryOperator<Integer>, takes two Integer values and returns an Integer value. 
Finally, this Integer value can be implicitly unboxed and sent to IntUnaryOperator, 
returning an int. Since these behaviors match our diagram, option D is the correct answer.
122. C,E. The DoublePredicate interface takes a double value and returns a boolean 
value. LongUnaryOperator takes a long value and returns a long value.  
ToInt BiFunction takes two generic values and returns an int value. ShortSupplier 
and ToStringOperator are not built-in functional interfaces. Recall that Java only 
includes primitive functional interfaces that operate on double, int, or long. For this 
reason, Options C and E are correct.
123. D. The lambda expression is invalid because the input argument is of type Boss, and Boss 
does not define an equalsIgnoreCase() method, making option D the correct answer. If 
the lambda was corrected to use s.getName() instead of s, the code would compile and 
run without issue, printing [JENNY, GRACE] at runtime and making option A the correct 
answer.
124. E. Serval is not a valid interface let alone a functional interface. The cat() method 
specifies an implementation, but does not have one of the modifiers that allows a body: 
default, private, or static. For this reason, option E is correct. If cat() was made 
an abstract method, then Serval would be a valid functional interface with n -> true 
being a valid lambda that matches it.
125. A. Let’s use the process of elimination here. Comparator returns an int, causing lines 17 
and 18 to not compile. Supplier does not take any parameters further, ruling out lines 21 
and 22 .
Predicate at least has the right number of parameters and the correct boolean return 
type. However, line 19 is not correct because the parentheses are missing around the type 
and variable. The parentheses can be omitted only if no type declaration is present, making 
line 20 correct. Since only one of these lines of code compiles, option A is the answer.
126. A. Option A is the answer because there is a getCount() method that returns a long 
rather than a method named getCountAsLong(). Option B is incorrect because there is 
in fact a getMax() method. Option C is incorrect because toString() is declared on 
Object, which means it is inherited by all classes.
127. A. The method reference System.out::println takes a single input and does not 
return any data. Consumer<Sheep> is compatible with this behavior, making option A the 
correct answer. Note that option B does not even compile because void cannot be used as 
a generic argument. Similarly, option C does not take a parameter. Option D is also incor-
rect, since System.out::println() does not return any data, and UnaryOperator 
requires a return value.
128. C,E,F. The correct method to obtain a parallel stream of an arbitrary stream is 
parallel(), while the correct method to obtain a parallel stream that operates on a  
Collection is parallelStream(). For this reason, options C, E, and F are correct. 
Note that option E retrieves a parallel stream of an already parallel stream, which is 
allowed.
129. A,F. The code, as written, prints rabbit, since it starts with the letter r. This is option A. 
The prefix variable is effectively final and, therefore safe to use in a lambda. Uncomment-
ing line 7 changes the prefix variable, and it is no longer effectively final. Since this causes 
a compiler error, option F is the other answer.
130. B. The code compiles, so options E and F are incorrect. The stream operations on 
lines 12–13 reduce the stream to the values [2, 3, 4]. Line 14 then converts the 
Stream<Integer> to an IntStream. On line 15, the first element of the IntStream is 
skipped, so the stream has only two elements [3, 4]. On line 16–17, the IntStream is 
converted to a Stream<Integer>, then a DoubleStream. Finally, on lines 18–19 the sum 
of the remaining elements is calculated and printed. Since  7 .0 is printed, option B is correct.
131. B. Since the first two rows are already finite streams, boxes M and N do not require an 
intermediate operation to complete, so options D, E, and F are incorrect. Box P does not 
need an intermediate operation either, since findFirst() will cause the stream to termi-
nate, making options A and C incorrect. Box O does need to be filled in with code such as 
limit(1). This allows the code to terminate, and option B is the answer.
132. C. Since the first two rows are already finite streams, boxes M and N meet this criteria. The 
last two rows can be filled in with code such as sorted(), which does not terminate for an 
infinite stream. Therefore, neither allows the code to terminate, and option C is the answer.
133. C. A Comparator takes two parameters, so options A and B are incorrect. Option D 
doesn’t compile. When returning a value using braces, a return keyword and semicolon 
are required. Option C is a correct implementation.
134. E. The methods anyMatch(), allMatch(), and noneMatch() take a Predicate as a 
parameter. This code does not compile because the parameter is missing, making option E 
correct.
135. B. Since the lambda references an effectively final variable, the method reference needs to 
as well. Option B is a correct method reference that meets this criteria. Options A and C 
use syntax that is not supported with method references. Option D is incorrect because the
Predicate passes only one value at runtime, so one of the instance variable or method 
parameter would need to be supplied.
136. E. Both pred4 and pred5 are valid as they use a type or var without final. Both pred1 
and pred3 are valid because the final modifier can only be used if a type or var is speci-
fied. Since pred2 is missing a data type and is the only line that does not compile, option E 
is the answer.
137. A. This code does compile, making options D and E incorrect. It correctly uses a 
Predicate<String> and removes all the elements from names and prints out 0 .  There-
fore, option A is the answer.
138. B. Since it’s not a primitive stream, the underlying type is Stream<Integer>, which 
means the data type of x is Integer. On the other hand, the data type of w, y, and z is 
Float. Because Integer and Float both define a floatValue() method, all of the 
lines compile. The code snippet prints  9 .0 at runtime, making option B correct.
139. B. The flatMap() method is used to turn a stream of collections into a one-dimensional 
stream. This means it gets rid of the empty list and flattens the other two. Option A is 
incorrect because this is the output you’d get using the regular map() method. Option B is 
correct because it flattens the elements. Notice how it doesn’t matter that all three elements 
are different types of Collection implementations.
140. D. Pay attention to the data types. The forEach() method is looping through a list of 
objects. This is a good example of using a lambda with list. By contrast, the Predicate 
passed to removeIf() uses an Integer. Since Integer is not compatible with String, 
line 9 does not compile.
141. C. To start with, IntFunction<Integer> takes an int value and returns an Integer. 
Line 8 takes an Integer instead of int as the input argument, and is therefore not com-
patible. Line 9 is compatible, since the return type null can be used as an Integer return 
type. Line 10 is also valid. An int can be autoboxed to Integer. Lines 11 and 12 do not 
compile because they do not take a parameter. Since only two statements compile, option C 
is the correct answer.
142. C,D,F. Using a parallel stream does not guarantee concurrent execution or a specific 
number of threads, making option A incorrect. Option B is also incorrect, as stateful 
lambda expressions should be avoided with all streams, serial or parallel. In fact, if a state-
ful lambda expression is used, the result of the stream may change, making option F correct 
and option E incorrect. Option C is correct, as a parallel stream may improve performance. 
Option D is also correct, though, as a parallel stream may add extra overhead to a stream 
that is forced into a serial operation, such as when the findFirst() method is called.
143. A. The code compiles, so options D and E are incorrect. The code first splits the stream 
into a Map<Boolean, List<String> based on whether the landmark contains a space. 
Using the flatMap() method, it then takes the List<String> values of the Map and 
reforms them as a Stream<String>. This new stream is similar to the original stream, 
although with elements in a possibly different order. Finally, the groupingBy() collector 
splits the stream based on whether it does not start with an "S". Since Set and Map were 
used, the order may vary, but option A is one possible output.
144. E. Option A doesn’t compile because the get() method on Optional doesn’t take any 
parameters. Options B, C, and D do compile, but print Cupcake since the Optional is not 
empty. Therefore, option E is correct.
145. F. There is no source in this attempt at a stream pipeline. While a Collection does have 
some of the same methods as a stream, such as forEach(), the limit() method is not 
one of them, so the code as written causes a compile error. Since this error is not on line x, 
option F is the answer. If stream() were inserted before limit(), then ONE would be 
printed.
146. E. The num variable is not effectively final because the value changes. This means it cannot 
be used in a lambda and the code does not compile, which is option  E .
147. C. There is not a stream pipeline method called sort(). There is one called sorted(). 
Since the code does not compile, option C is correct. If this was fixed, option A would be 
correct since the Comparator sorts in ascending order.
148. A. A lambda can only implement an interface with a single abstract method ruling out 
option B .  Developers can write their own functional interfaces, making option A correct.
149. C. The primitive Supplier functional interfaces, such as BooleanSupplier and 
LongSupplier, do not have a get() method. Instead, they have methods such as 
getAsBoolean() and getAsLong(), respectively. For this reason, the first line of the 
checkInventory() method does not compile, making option C the correct answer. If the 
method call was changed to getAsBoolean(), then the rest of the code would compile 
without issue, print Plenty! at runtime, and option A would be the correct answer.
150. E. The code does not compile because the collector returns a ConcurrentMap, which 
requires a BiConsumer in the forEach() method. For this reason, option E is correct.
1. F. The module-info.java file is used to declare a module. You must memorize the name 
of this file.
2. E. The service locator contains a load() method, not an exports() method, making 
option E the answer.
3. B,D. A service is comprised of the interface, any classes the interface references, and a way to 
look up implementations of the interface. Option B covers the lookup, and option D covers 
the interface itself.
4. B. A named module must be on the module path and contain a module-info file. Only 
dog.bark meets this criterion, making option B the answer.
5. C. An automatic module must be on the module path but does not contain a module-info 
file. Option C is correct because dog.hair matches this description.
6. E. You need to know about three types of modules for the exam: automatic, named, and 
unnamed. There is no such thing as a default module. The question was trying to trick you, 
and option E is correct.
7. C. An unnamed module must be on the classpath. It is rare to have a module-info file in 
an unnamed module, but it is allowed. Therefore, both dog.fluffy and dog.husky meet 
this criterion, making option C correct.
8. B,F. It is recommended to specify all exports directives in the module-info file. While it 
is legal to use the --add-exports option, it is not recommended, making option B correct. 
You do not need to know how to use it for the exam, just that it is not a good idea. There is 
no equivalent option for requires, making option F correct.
9. B. Since Java does not allow dashes in identifier names, the second and fourth declarations 
are invalid. Additionally, access modifiers are not permitted in module declarations, making 
the third and fourth declarations invalid. The only one that is legal is the first declaration, so 
option B is correct.
10. D. The consumer is generally separate ruling out options A, B, and C. The service provider is 
decoupled from the service provider interface ruling out option F .  It is most logical to com-
bine the service locator and service provider interface because neither has a direct reference 
to the service provider. Therefore, option D is correct.
11. C. The java command has an option to list all the modules that come with the JDK. 
Option C is correct since that option is called --list-modules. The other options are 
not supported by the java command. Options B and E are similar to options that exist: 
--describe-module and --show-module-resolution. But neither gives a list of all 
the modules that come with the JDK.
12. C. The rules for determining the name include removing the extension, removing numbers, 
and changing special characters to periods (.). This leaves us with dog.arthur, which is 
option C . 
13. C. All parts of a modules service must point to the service provider interface. This tells us the
service provider interface must be X, ruling out options A, B, and E .  Now, we have to decide 
if Y or Z are the service provider interface. We can tell because nothing has a direct depen-
dency on the service provider. Since this makes the service provider Y, the answer is option C .
14. B. The consumer depends on the service provider interface and service locator, but not 
the service provider. Only W has two arrows starting from it so, it must be the consumer. 
This rules out options C, D, and E .  The service locator references the service provider inter-
face directly and the service provider indirectly, making the service locator Z and option B 
the answer.
15. C. A cyclic dependency is when two things directly or indirectly depend on each other. If 
chicken.jar depends on egg.jar, and egg.jar depends on chicken.jar, we have 
a cyclic dependency. Since only two JAR files are needed to create this situation, option C is 
the answer.
16. E. The ServiceLoader class has a load() method that returns a Collection of  
Provider, not a stream. Since the call to stream() is missing, option E is the answer. If the 
call to stream() were added, option D would be the answer.
17. C. Each module is required to have its own module-info.java file in the root directory 
of the module. For module com.ny, that is location W, and for module com.sf, that is loca-
tion Y. Therefore, option B is correct.
18. E. Options A, C, and D are incorrect because export and require are not keywords in 
modules. Option B is incorrect because that directive goes in the com.ny module, not the 
com.sf one. Option E is correct rather than option F because the requires directive refer-
ences a module name rather than a package.
19. D. Options A and B are incorrect because export is not a keyword in modules. Option 
E belongs in the com.sf module, not the com.ny one. Option F is incorrect because the 
requires directive references a module name rather than a package. Finally, option D is 
the answer rather than option C because the exports directive references a package name 
rather than a module.
20. E. The Maple class is intended to be an implementation of the Tree interface. However, this 
interface needs to be accessible. This module is missing a requires nature.sapling; 
statement, making option E the correct answer.
21. B. The –d option specifies the directory. The –p option specifies the module path. The –m 
option is not available on the javac command.
22. A,C,E. The java.base module is automatically available to any module without specifying 
it, making option A correct. Options C and E are also correct because java.desktop and 
java.sql are modules supplied with the JDK. You do need to be able to identify built-in 
modules for the exam.
23. A,C. Option A is correct because a top-down migration starts by moving all the modules to 
the module path as automatic modules. Then, the migration changes each module from an 
automatic module to a named module, making option C the other correct answer.
24. A. Option A is correct because a consumer has two dependencies. It requires both the ser-
vice provider interface and the service locator.
25. A,C. Option A is correct, and option B is incorrect as we want to create named modules 
when possible. We also need to be on the lookout for cyclic dependencies. While option 
D would work, it is better to be more granular and create a third module as in option C . 
Option E is incorrect because dots are used as separators in names.
26. B. The jdeps command lists information about dependencies within a module. The –s 
option provides a summary of output rather than verbose output, making option B the 
correct answer. There is no –d option. The jmod command is for working with JMOD files.
27. C. Option C is correct because a service provider requires the interface. It also provides 
the implementation.
28. E. When running a module, the module name is listed before the slash, and the fully qualified 
class name is after the slash. Option E is the only one that meets this criterion.
29. B. An unnamed module is on the classpath. While it is permitted to have a module-info 
file, the file is ignored if present. An automatic module is on the module path and does not 
have a module-info file. A named module is required to have a module-info file, mak-
ing option B the correct answer.
30. B. Option B is correct because a service locator uses the interface. It also requires the 
service provider interface module and exports the package with the locator.
31. A,B. Option A is correct because modules provide a mechanism to export specific packages. 
This creates module-level access since some packages can be used only in a module. Option 
B is correct because jlink allows creating a distribution with just the parts of the JDK that 
are needed. Option C is not correct because modules are usually distributed as a JAR file. 
Option D is incorrect because modules actually require one extra file: module-info.java. 
Option E is incorrect because var can be used with or without modules. Finally, option 
F is incorrect because “write once, run anywhere” is a core benefit of Java independent 
of modules.
32. E. A consumer requires both the service locator and service provider interface. A service 
locator and service provider interface need to have an exports statement. A service provider 
needs a provides directive. Since none of them matches, option E is the correct answer.
33. F. An unnamed module is permitted to have a module-info file, but the file is ignored 
if present. An automatic module does not have a module-info file. A named module is 
required to have a module-info file. Therefore, option F is correct.
34. A. A module-info file is required to start with module rather than class. Therefore, the 
first line doesn’t compile, and option A is correct.
35. B. You need to know these keywords: exports, requires, requires  
transitive, provides, opens, and uses. Of these, only uses is in the list of candi-
dates in the question. Note that export and require are invalid because they should be 
exports and requires, respectively.
36. D. Option D is correct because a service provider interface exposes the interface without 
depending on any of the other options.
37. D,E,F. The java.base module is automatically available to any module without specifying 
it. However, this question tries to trick you with option A by specifying jdk.base instead. 
Similarly, java.desktop exists, but not jdk.deskop, making option C wrong. Options D, 
E, and F are correct because jdk.javadoc , jdk.jdeps, and jdk.net are modules sup-
plied with the JDK. You do need to be able to recognize the names of built-in modules.
38. B,C,F. A top-down migration starts by moving all the modules to the module path as 
automatic modules, making options B and F correct. A bottom-up migration moves each 
module after all modules it depends on have been migrated, making option C correct.
39. B. The service locator contains a load() method, making option B correct.
40. E. Module names are permitted to be any valid variable name with the addition of dot sep-
arators (.). The only one that is problematic is com-leaf because dashes are not allowed, 
making option E correct. As a reminder, numbers are permitted as long as they are not the 
first character in a segment. Capital letters are discouraged but allowed.
41. A. Option A is correct because ServiceLoader allows you to make your application 
extensible. A service can be added without recompiling the entire application. It is a class, but 
the service provider implementation does not reference it, making options C and D incorrect. 
Option B is not a feature of Java.
42. A,F. Code on the classpath has not yet been migrated to modules and can reference any code 
in the application. This is true whether that code is in automatic, named, or unnamed mod-
ules, matching option A .  Code on the module path operates in a stricter world and cannot 
reference code on the classpath. Since unnamed modules cannot be accessed in this situation, 
option F is the second answer.
43. C. Option A is incorrect because it exports the package to all modules. Option C is correct 
because it limits package sharing to the com.park module. Option E is incorrect because a 
package must be exported from the module that contains it. Options B and D are incorrect 
because from is not valid syntax.
44. F. It is not possible to provide access outside the module while also limiting access within the 
com.duck module. Options A and C are tempting because they do provide access in  
com.park. However, they do not prevent the Egg class in the com.egg package from access-
ing the com.duckling package. Remember that the com.egg package is in the com.duck 
module, so the access cannot be restricted. Therefore, option F is correct. 
45. E. The correct way to specify this is requires com.duck; requires com.bread;. 
There is no way to combine two module requires statements into one. Additionally, note 
that the requires statement works with a module name, not a package name.
46. E. Only the service provider has a provides directive. Since it is not part of the service, 
option E is the correct answer.
47. D. Both options A and B note that the JAR depends on the jdk.unsupported module. 
However, they do not list suggested replacements. Options C and E are invalid because flags 
of this format need two dashes. Option D is correct and option F is incorrect because the 
desired flag is --jdkinternals. Note that --jdk-internals is also acceptable.
48. C. Option C is correct because only unnamed modules are on the classpath. 
49. D. The service locator contains a ServiceLoader call to look up the service loader. It takes 
the type of class it looked up as a parameter and returns a generic, making option D the 
correct answer.
50. B,D. Option B is correct because it depends on the change. If a method is added to the ser-
vice provider interface or a public method is changed, the service providers must be recom-
piled. However, if a change is made that does not affect the service provider, such as a new 
static method, recompilation is not needed. Option D is also correct because return types 
and parameter types are considered part of the service.
51. D. Unnamed modules are on the classpath. Option D is correct because automatic and 
named modules are on the module path.
52. F. The consumer needs to depend on the shared module, making it X. The shared module 
then has to be Z, and the service provider has to be Y. However, the service provider should 
not know about the consumer, and the dotted line in the diagram does not make sense. This 
means none of the options can create a valid scenario, and option F is the correct answer.
53. B. Without any command line flags, jdeps lists packages and module dependencies. The 
-s flag provides a summary omitting the package name, which means option B is the 
correct answer.
54. B,C,F. Options A, D, and E are incorrect because they are benefits of Java even without 
modules. Option B is correct because the module-info file clarifies dependencies. Option 
C is correct because a smaller deployment package can be faster. Finally, option F is correct 
because the module system prevents the same package from being used from multiple 
JAR files.
55. F. The first clue is that the -m and -p options are on the java command. Beyond that, you 
need to memorize the name of the --show-module-resolution option.
56. B. This module is a service provider interface. The only requirement is that the module  
needs to export the package containing the interface. In this case, that is the  
animal.insect.api.bugs package, which matches option B .
57. A,E. This module is a service provider. It needs a requires directive for the service pro-
vider interface, which is option A .  It also needs a provides directive, which specifies both 
the interface and implementation. Option E has both in the correct order.
58. C,F. This module is a service locator. It needs three directives: exports, requires, and 
uses. The requires directive specifies the module it depends on, which is option C .  The 
uses directive specifies the service provider interface it references, which is option F .
59. A,B. This module is a consumer. It needs two requires directives. Option A represents the 
service provider interface, and option B represents the service locator. The uses directive 
should be in the service locator, not the consumer.
60. A. Without any command line flags, jdeps lists packages and module dependencies, making 
option A correct. Option D will also list the packages; however, it is longer than option A .
61. C. The com.light module does not have any dependencies, so it is fine. However,  
com.animal and com.plant depend on each other giving us a cyclic dependency. Finally, 
com.worm depends on all the modules but does not introduce any more problems. It will 
not compile until com.animal or com.plant are fixed, but is not part of the cycle itself. 
Option C is correct, since only two modules are part of the cycle.
62. C. The -d option is a shorthand for --describe-module on both the jar and java 
commands. Therefore, option C is correct.
63. C. The javac command takes -p for the module path rather than -m. Since there is no –m 
on the javac command, option C is the correct answer.
64. A. Option B is tempting because the java.lang package is available to all classes. How-
ever, the question asks about modules. Option A is the correct answer because the  
java.base module is available to all modules. The other options are incorrect because 
those modules do not exist.
65. A,B,C. The jmod command has five possible modes: create, extract, describe, 
list, and hash.
66. A. There is no such thing as a side-to-side migration, ruling out option B. In a top-down 
migration, all modules are moved to the module path first, making option C incorrect. In a 
bottom-up migration, modules are moved, starting with those without dependencies. There-
fore, option A is correct.
67. C,E. In a bottom-up migration, the lowest-level modules are migrated to named modules on 
the module path first. This makes option E one of the answers. The modules that remain on 
the classpath are unnamed modules, making option C the other answer.
68. D. The com.magic module exports only one package. This makes the  
com.magic.unicorn package accessible, but not the com.magic.dragon package.  
Both packages in com.science are accessible because it is an automatic module. When a 
module on the module path does not contain a module-info file, all packages are exported. 
This gives us three packages that are accessible and a correct answer of option D .
69. A. Modules on the module path cannot access anything from the classpath, making option A 
the correct answer.
70. E. Option E is correct as this code does compile. While it is uncommon, a module is not 
required to have any directives in the body. Similarly, module names are lowercase and have 
more than one component by convention. None of these problems prevents the file from 
compiling, though.
71. E. One of the benefits of services is not having to recompile existing code when adding a 
new implementation. This makes option E the correct answer.
72. C. The java command uses -m and --module to supply the module name. The jdeps 
command uses -s and --summary to specify the output should be limited. Option C 
matches both of these.
73. B. A service is comprised of the interface, any classes the interface references, and a way to 
look up implementations of the interface. It does not include the implementation. This makes 
option A the correct answer.
74. E. Option E is correct because both java and jdeps meet the criteria. The jar command 
does as well although the options mean different things than working with modules.
75. A,E. This question is tricky because the service provider code is shown, but the question 
asks about the service locator, and you need to infer information about the service provider 
interface. The requires directive is option A due to process of elimination. Option B is 
incorrect because the requires directive references a module name rather than an interface. 
Option C is incorrect because we need the service provider interface module, and it refers 
to the service provider module. Option E is easier, since the uses directive works with an 
interface name.
76. A,F. A bottom-up migration leaves unnamed modules on the classpath until they are 
migrated to the module path, making option A correct and option D incorrect. A top-down 
migration immediately moves all modules to the module path as automatic modules making 
options B and E incorrect. Therefore, option F is the other correct answer.
77. D. The ServiceLoader class has a load() method that returns a Collection of  
Provider. Option D is correct because we need to convert the Provider into a Mouse.
78. B,C,E. The mammal module depends on two other modules. Since requires references 
module names, options C and E are correct. The module also has one package, which is 
referenced in the exports directive. This makes option B correct as well.
79. C. The transitive keyword goes after requires, ruling out all but options C and D. 
Just like requires, requires transitive references a module name, narrowing it 
down to option C .
80. D. Any requires directives must reference unique modules. Using the transitive keyword 
does not change this requirement, making option D the correct answer.
81. D. There can be multiple service providers for a single service provider interface, making 
option D the correct answer.
82. A,D,E. The java.logging, java.management, and java.naming modules exist, mak-
ing options A, D, and E correct. Option B is tempting. However, jdk.javadoc exists, not 
java.javadoc. Options C and F are completely made up.
83. B,E. Option E is correct because all modules on the classpath are unnamed modules. On 
the module path, we can have automatic or named modules. In this case, it is an automatic 
module because there is no module-info.class at the root of the JAR. Having that file in 
another directory is ignored. This makes option B the other answer.
84. A. The consumer needs to depend on the shared module, making it X. The shared module 
then has to be Z, and the service provider has to be Y. This makes option A correct.
85. B,D. The method call of ServiceLoader.load(Poodle.class), takes a param-
eter making option B correct and option A incorrect. When using a Stream, you call 
Provider::get, making option D the other answer. Option C is incorrect because you 
don’t need to call the get() method when using a loop.
86. B. The rules for determining the name include removing the extension, removing num-
bers and changing special characters to periods (.). Additionally, we remove the version 
information from the end, which is  1 .0 .0-SNAPSHOT. Finally, we normalize the duplicate 
dots, which gives us option B: lizard.cricket. 
87. D. The jar file format is most common. The JMOD jmod format is used as well. Therefore, 
option D is correct.
88. B. Option B is correct because a service provider should not contain an exports directive. 
The service locator is used to reference any implementation exposed by provides.
89. A. The com.light module is a dependency for all the other modules but does not depend 
on them. Similarly, the com.animal module is a dependency for the two higher-level mod-
ules but does not depend on them. Finally, the com.plant module is a dependency for the 
com.worm module but does not depend on it. While the modules are not defined in this 
order, the question is about cyclic dependencies rather than order of compilation. There is no 
cyclic dependency, making option A correct.
90. C,E. The jdeps command outputs requires mandated java.base except when run 
in summary mode, making option C correct. Since this module is an implicit dependency in 
all modules, option E is also correct.
1. C. The code does not compile because Callable must define a call() method, not a 
run() method, so option C is the correct answer. If the code was fixed to use the correct 
method name, then it would complete without issue, printing XXXXXXXXXXDone! at run-
time. The f.get() call will block and wait for the results before moving on to the next iter-
ation of the for loop.
2. A,D. Option A is correct, as ExecutorService does not define nor inherit an overloaded 
method execute() that takes a Callable parameter. ExecutorService defines 
two shutdown methods, shutdown() and shutdownNow(), one of which is shown 
in option B .  Option D is correct, as exit() does not exist and is not one of shutdown 
methods. The ExecutorService interface defines the two submit() methods shown 
in options C and E .  Because ExecutorService extends Executor, it also inherits the 
execute(Runnable) method presented in option F .
3. F. The code compiles and runs without issue. Even though the thread-safe Atomic Boolean 
is used, it is not used in a thread-safe manner. The flip() method first retrieves the 
value and then sets a new value. These two calls are not executed together in an atomic or 
synchronized manner. For this reason, the output could be true or false, with one or more 
of the flips possibly being lost, and making option F correct.
4. C. Option A is incorrect, although it would be correct if Executor were replaced with 
ExecutorService. Option B is also incorrect, but it would be correct if start() were 
replaced with run(). Option C is correct and is a common way to define an asynchronous 
task using a lambda expression. Option D is incorrect, as Runnable does not inherit a 
begin() method.
5. A. If the tryLock() method returns true, then a lock is acquired that must be released. 
That means the lockUp() method actually contains two calls to lock the object and only 
one call to unlock it. For this reason, the first thread to reach tryLock() obtains a lock that 
is never released. For this reason, Locked! is printed only once, and option A is correct. If 
the call to lock() inside the if statement was removed, then the expected output would be 
to print the statement five times.
6. C. CopyOnWriteArrayList makes a copy of the array every time it is modified,  
preserving the original list of values the iterator is using, even as the array is modified.  
For this reason, the for loop using copy1 does not throw an exception at runtime.  
On the other hand, the for loops using copy2 and copy3 both throw  
Concurrent ModificationException at runtime since neither allows modification 
while they are being iterated upon. Finally, the ConcurrentLinkedQueue used in copy4 
completes without throwing an exception at runtime. For the exam, remember that the
Concurrent classes order read/write access such that access to the class is consistent across 
all threads and processes, while the synchronized classes do not. Because exactly two of the 
for statements produce exceptions at runtime, option C is the correct answer.
7. C. Resource starvation is when a single active thread is perpetually unable to gain access to a 
shared resource. Livelock is a special case of resource starvation, in which two or more active 
threads are unable to gain access to shared resources, repeating the process over and over 
again. For these reasons, option C is the correct answer. Deadlock and livelock are similar, 
although in a deadlock situation the threads are stuck waiting, rather than being active or 
performing any work. Finally, a race condition is an undesirable result when two tasks that 
should be completed sequentially are completed at the same time.
8. E. The class does not compile because the Future.get() on line 8 throws a checked 
InterruptedException and a checked ExecutionException, neither of which is 
handled nor declared by the submitReports() method. If the submitReports() and 
accompanying main() methods were both updated to declare these exceptions, then the 
application would print 1null at runtime. For the exam, remember that Future can be 
used with Runnable lambda expressions that do not have a return value but that the return 
value is always null when completed.
9. A,B. Options C, D, E, and F are all proper ways to obtain instances of  
Executor Service. Remember that newSingleThreadExecutor() is equivalent  
to calling newFixedThreadPool(int) with a value of 1 . The correct answers are  
options A and B, as neither of these methods exist.
10. A. The code compiles without issue but hangs indefinitely at runtime. The application defines 
a thread executor with a single thread and 12 submitted tasks. Because only one thread is 
available to work at a time, the first thread will wait endlessly on the call to await(). Since 
the CyclicBarrier requires four threads to release it, the application waits endlessly in a 
frozen condition. Since the barrier is never reached and the code hangs, the application will 
never output Ready, making option A the correct answer. If newCachedThreadPool() 
had been used instead of newSingleThreadExecutor(), then the barrier would be 
reached three times, and option C would be the correct answer.
11. E. Trick question! ExecutorService does not contain any of these methods. To obtain an 
instance of a thread executor, you need to use the Executors factory class. For this reason, 
option E is the correct answer. If the question had instead asked which Executors method 
to use, then the correct answer would be option C .  Options A, B, and D do not create 
enough threads for a CyclicBarrier expecting to reach a limit of five concurrent threads. 
Option C, on the other hand, will create threads as needed and is appropriate for use with a 
CyclicBarrier.
12. C. Part of synchronizing access to a variable is ensuring that read/write operations are 
atomic or happen without interruption. For example, an increment operation requires 
reading a value and then immediately writing it. If any thread interrupts this process, then 
data could be lost. In this regard, option C shows proper synchronized access. Thread 2 
reads a value and then writes it without interruption. Thread 1 then reads the new value and 
writes it. The rest of the answers are incorrect because one thread writes data to the variable
in-between another thread reading and writing to the same variable. Because a thread is 
writing data to a variable that has already been written to by another thread, it may set 
invalid data. For example, two increment operations running at the same time could result in 
one of the increment operations being lost.
13. F. The code compiles and runs without issue. The two methods hare() and tortoise() 
are nearly identical, with one calling invokeAll() and the other calling invokeAny(). 
Calling the invokeAll() method causes the current thread to wait until all tasks are fin-
ished, while calling the invokeAny() method will cause the current thread to wait until 
at least one task is complete. Both ExecutorService methods operate synchronously, 
waiting for a result from one or more tasks, but each method call has been submitted to the 
thread executor as an asynchronous task. For this reason, both methods will take about one 
second to complete, and since either can finish first, the output will vary at runtime, making 
option F correct. Note that this program does not terminate, since the ExecutorService is 
not shut down.
14. B,D. ConcurrentSkipList does not exist as a concurrent collection, making option A 
incorrect. ConcurrentSkipListSet implements the SortedSet interface, in which the 
elements are kept sorted, making option B correct. ConcurrentSkipListMap implements 
the SortedMap interface, in which the keys are kept sorted, making option D correct. The 
other options define structures that are ordered, but not sorted. Remember, if you see  
SkipList as part of a concurrent class name, it means it is sorted in some way.
15. C. The code compiles without issue, so options D and E are incorrect. The f1 declaration 
uses the version of submit() in ExecutorService, which takes a Runnable and returns 
a Future<?>, while the f2 declaration uses an overloaded version of submit(), which 
takes a Callable expression and returns a generic Future object. The call  f1 .get() 
waits until the task is finished and always returns null, since Runnable expressions have 
a void return type, so [Filing]null is printed first. The call to  f2 .get() returns then 
prints  3 .14159 .  For these reasons, option C is the correct answer.
16. C,D. The code compiles and runs without issue. While an AtomicLong is used, there are 
two calls on this variable, the first to retrieve the value and the second to set the new value. 
These two calls are not executed together in an atomic or synchronized manner. For this 
reason, the incrementBy10() method is not thread-safe, and option C is correct. That 
said, the code performs in single-threaded manner at runtime because the call to get() in 
the main() method waits for each thread to finish. For this reason, the output is consistently 
1000, making option D correct.
17. D. The synchronized block used in the getQuestion() method requires an object 
to synchronize on. Without it, the code does not compile, and option D is the correct 
answer. What if the command was fixed to synchronize on the current object, such as using 
synchronized(this)? Each task would obtain a lock for its respective object and then 
wait a couple of seconds before requesting the lock for the other object. Since the locks are 
already held, both wait indefinitely, likely resulting in a deadlock. We say most likely because 
even with corrected code, a deadlock is not guaranteed. It is possible, albeit very unlikely, for 
the JVM to wait five seconds before starting the second task, allowing enough time for the 
first task to finish and avoiding the deadlock completely.
18. B. Options A, D, and E include method names that do not exist in  
Scheduled ExecutorService. The scheduleAtFixedRate() method creates a  
new task for the associated action at a set time interval, even if previous tasks for the same 
action are still active. In this manner, it is possible multiple threads working on the same 
action could be executing at the same time, making option B the correct answer. On the 
other hand, scheduleWithFixedDelay() waits until each task is completed before 
scheduling the next task, guaranteeing at most one thread working on the action is active 
in the thread pool.
19. F. The application compiles, so option D is incorrect. The stroke variable is thread-safe 
in the sense that no write is lost, since all writes are wrapped in a synchronized method, 
making option E incorrect. The issue here is that the main() method reads the value of 
getStroke() while tasks may still be executing within the ExecutorService. The 
shutdown() method stops new tasks from being submitted but does not wait for previously 
submitted tasks to complete. Therefore, the result may output 0, 1000, or anything in  
between, making option F the correct answer. If the ExecutorService method  
await Termination() is called before the value of stroke is printed and enough time 
elapses, then the result would be 1000 every time.
20. C. A race condition is an undesirable result when two tasks that should be completed 
sequentially are completed at the same time. The result is often corruption of data in some 
way. If two threads are both modifying the same int variable and there is no synchroniza-
tion, then a race condition can occur with one of the writes being lost. For this reason, option 
C is the correct answer. Option A is the description of resource starvation. Options D and 
E are describing livelock and deadlock, respectively, while option B is the potential result of 
either of those events occurring.
21. B. The class compiles without issue. The class attempts to create a synchronized version 
of a List<Integer>. The size() and addValue() help synchronize the read/write 
operations. Unfortunately, the getValue() method is not synchronized so the class is 
not thread-safe, and option B is the correct answer. It is possible that one thread could add 
to the data object while another thread is reading from the object, leading to an unex-
pected result.
22. D. The post-decrement operator (––) decrements a value but returns the original value.  
It is equivalent to the atomic getAndDecrement() method. The pre-increment  
operator (++) increments a value and then returns the new value. It is equivalent to the  
increment AndGet() atomic operation. For these reasons, option D is the  
correct answer.
23. C. Line 13 does not compile because the execute() method has a return type of void, not 
Future. Line 15 does not compile because scheduleAtFixedRate() requires four argu-
ments that include an initial delay and period value. For these two reasons, option C is the 
correct answer.
24. B. When a CyclicBarrier goes over its limit, the barrier count is reset to zero. The appli-
cation defines a CyclicBarrier with a barrier limit of 5 threads. The application then sub-
mits 12 tasks to a cached executor service. In this scenario, a cached thread executor will use 
between 5 and 12 threads, reusing existing threads as they become available. In this manner,
there is no worry about running out of available threads. The barrier will then trigger twice, 
printing five values for each of the sets of threads, for a total of ten W characters. For this 
reason, option B is the correct answer.
25. D. The application does not terminate successfully nor produce an exception at runtime, 
making options A and B incorrect. It hangs at runtime because the CyclicBarrier limit is 
5, while the number of tasks submitted and awaiting activation is 12 .  This means that two 
of the tasks will be left over, stuck in a deadlocked state, waiting for the barrier limit to be 
reached but with no more tasks available to trigger it. For this reason, option D is the correct 
answer. If the number of tasks was a multiple of the barrier limit, such as 15 instead of 12, 
then the application will still hang because the ExecutorService is never shut down, and 
option C would be correct. The isShutdown() call in the application finally block does 
not trigger a shutdown. Instead, shutdown() should have been used.
26. C. The Lock interface does not include an overloaded version of lock() that takes a time-
out value and returns a boolean. For this reason, the code does not compile, and option 
C is correct. If tryLock(long,TimeUnit) had been used instead of lock(), then the 
program would have been expected to print TV Time three times at runtime.
27. B. The for loops using copy1 and copy4 both throw a  
ConcurrentModification Exception at runtime, since neither allows  
modification while they are being iterated upon. Next, CopyOnWriteArrayList makes 
a copy of the collection every time it is modified, preserving the original list of values the 
iterator is using. For this reason, the for loop using copy2 completes without throwing 
an exception or creating an infinite loop. On the other hand, the loop with copy3 enters 
an infinite loop at runtime. Each time a new value is inserted, the iterator is updated, and 
the process repeats. Since this is the only statement that produces an infinite loop, option B 
is correct.
28. E. The shutdown() method prevents new tasks from being added but allows existing 
tasks to finish. In addition to preventing new tasks from being added, the shutdownNow() 
method also attempts to stop all running tasks. Neither of these methods guarantees any task 
will be stopped, making option E the correct answer. Options C and D are incorrect because 
they name methods that do not exist in ExecutorService.
29. E. The program compiles and does not throw an exception at runtime. The class attempts 
to add and remove values from a single cookie variable in a thread-safe manner but fails 
to do so because the methods deposit() and withdrawal() synchronize on differ-
ent objects. The instance method deposit() synchronizes on the bank object, while the 
static method withdrawal() synchronizes on the static Bank.class object. Since the 
compound assignment operators (+=) and (-=) are not thread-safe, it is possible for one call 
to modify the value of cookies while the other is already operating on it, resulting in a loss 
of information. For this reason, the output cannot be predicted, and option E is the correct 
answer. If the two methods were synchronized on the same object, then the cookies vari-
able would be protected from concurrent modifications, printing 0 at runtime.
30. A. The code attempts to search for a matching element in an array using multiple threads. 
While it does not contain any compilation problems, it does contain an error. Despite cre-
ating Thread instances, it is not a multithreaded program. Calling run() on a Thread runs
the process as part of the current thread. To be a multithreaded execution, it would need to 
instead call the start() method. For this reason, the code completes synchronously, waiting 
for each method call to return before moving on to the next and printing true at the end of 
the execution, making option A the correct answer. On the other hand, if start() had been 
used, then the application would be multithreaded but not thread-safe. The calls to update 
foundMatch are not synchronized, and even if they were, the result might not be available 
by the time print() in the main() method was called. For this reason, the result would 
not be known until runtime.
1. D. The code does not compile because Path.get() is not a valid NIO.2 method, making 
option D correct. Either Paths.get() or Path.of() should be used instead. If the  
correct method was used, then DirectoryNotEmptyException would be the correct 
answer. The AtomicMoveNotSupportedException in option A is possible only  
when the ATOMIC_MOVE option is passed to the move() method. Similarly, the  
FileAlreadyExists Exception in option C is possible only when the  
REPLACE_EXISTING option is not passed to the move() method.
2. A. The constructor for Console is private. Therefore, attempting to call new 
Console() outside the class results in a compilation error, making option A the correct 
answer. The correct way to obtain a Console instance is to call System.console(). Even 
if the correct way of obtaining a Console had been used, and the Console was available at 
runtime, stuff is null in the printItinerary() method. Referencing stuff 
.activities results in a NullPointerException.
3. D,F. BufferedWriter is a wrapper class that requires an instance of Writer to operate 
on. Since FileOutputStream does not inherit Writer, the code does not compile, and 
option D is correct. If FileWriter was used instead of FileOutputStream, then the 
code would compile without issue and print 1 .  The try-with-resources statement closes 
System.out before the catch or finally blocks are called. When the finally block is 
executed, the output has nowhere to go, which means the last value of 3 is not printed, mak-
ing option F correct.
4. F. The code does not compile. There are no createDirectory(), createDirectories(),  
and delete() methods defined on the Path interface. Instead, the NIO.2 Files class should 
be used. Since four lines of code do not compile, option F is the correct answer. If the lines were 
corrected to use the Files class, then the application would print an exception at line k1, as the 
directory already exists.
5. A,C. Generally speaking, classes should be marked with the Serializable interface if they 
contain data that we might want to save and retrieve later. Options B, D, E, and F describe 
the type of data that we would want to store over a long period of time. Options A and C, 
though, define classes that manage transient or short-lived data. Application processes change 
quite frequently, and trying to reconstruct a process is often considered a bad idea.
6. D. First, p2 is an absolute path, which means that p1.resolve(p2) just returns p2.  
For this reason, options B and C are incorrect. Since p1 is a relative path, it is appended  
onto p2, making option D correct and option A incorrect. Option A would be correct if 
normalize() was applied.
7. B. Writer is an abstract class, so options A, D, and E are incorrect. Classes extend abstract 
classes; they do not implement them, making option B correct. Note that InputStream, 
OutputStream, and Reader are also abstract classes.
8. D. After calling createDirectories(), the directory /home is guaranteed to exist if it 
does not already. The second argument of the copy() command should be the location of 
the new file, not the folder the new file is placed in. Therefore, the program attempts to  
write the file to the path /home. Since there is already a directory at that location, a  
FileAlreadyExistsException is thrown at runtime, making option D correct.
9. E. The code does not compile because readAllLines() returns a List<String>, not a 
stream, making option E the answer. If the correct method lines() was used instead, then 
five lines would be printed at runtime.
10. E. The size variable is properly serialized with a value of 4. Upon deserialization, none of 
the class elements that assign a value to an instance variable are run, leading to size being 
deserialized as 4 .  Since the name variable is marked transient, this value is deserialized as 
null. For these reasons, option E is correct.
11. B. The readPassword() returns a char array for security reasons. If the data was stored 
as a String, it would enter the shared JVM string pool, potentially allowing a malicious 
user to access it, especially if there is a memory dump. By using a char array, the data can be 
immediately cleared after it is written and removed from memory. For this reason, option B is 
the correct answer.
12. A. While you might not be familiar with FilterOutputStream, the diagram shows that 
the two classes must inherit from OutputStream. Options B, C, and E can be eliminated as 
choices since PrintOutputStream and Stream are not the name of any java.io classes. 
Option D can also be eliminated because OutputStream is already in the diagram, and you 
cannot have a circular class dependency. That leaves us with the correct answer, option A, 
with BufferedOutputStream and PrintStream both extend FilterOutputStream. 
Note that ByteArrayOutputStream and FileOutputStream referenced in Options C 
and D, respectively, do not extend FilterOutputStream, although knowing this fact was 
not required to solve the problem.
13. D. Line 15 is the first line to not compile, as relativize() is an instance method, not a 
static method. Line 16 also does not compile, as size(), not length(), should be used 
to retrieve a file size. Finally, line 17 does not compile because view is an attribute class, not  
an attribute view. For line 17 to compile, line 13–14 would have to use  
Files.getFileAttributeView() with BasicFileAttributeView.class as the 
class. The rest of the lines do not contain any compiler errors, making option D correct.
14. C. The code compiles and runs without issue. The first two values of the  
ByteArray InputStream are read. Next, the markSupported() value is tested. Since -1 
is not one of the possible options, we assume that ByteArrayInputStream does support
marks. Two values are read and three are skipped, but then reset() is called, putting the 
stream back in the state before mark() was called. In other words, everything between mark() 
and reset() can be ignored. The last value read is 3, making option C the correct answer.
15. B. The class compiles and runs without issue, so option F is incorrect. The class defines three 
variables, only one of which is serializable. The first variable, chambers, is serializable, 
with the value 2 being written to disk and then read from disk. Note that constructors and 
instance initializers are not executed when a class is deserialized. The next variable, size, 
is transient. It is discarded when it is written to disk, so it has the default object value of 
null when read from disk. Finally, the variable color is static, which means it is shared 
by all instances of the class. Even though the value was RED when the instance was serialized, 
this value was not written to disk, since it was not part of the instance. The constructor call 
new Valve() between the two try-with-resources blocks sets this value to BLUE, which is 
the value printed later in the application. For these reasons, the class prints 2,null,BLUE, 
making option B the correct answer.
16. A,D. Simplifying the path symbols, options B, C, and F become  
/objC/forward/Sort.java, which applying the symbol link becomes  
/java/Sort.java. Option E just becomes /java/Sort.java, without any path  
symbols involved. Option A is correct, as the resolve() method concatenates the path to 
be /objC/bin/objC/forward/Sort.java. Option D is also correct, as the simplified 
path is /objC/java/forward/Sort.java. In both of these cases, the symbolic link  
/objC/forward cannot be applied.
17. D. The skip(1) method just reads a single byte and discards the value. The read() method 
can be used for a similar purpose, making option D the correct answer. Option A is incorrect 
because there is no jump() method defined in Reader. Options B, C, and E are incorrect 
because they cannot be used to skip data, only to mark a location and return to it later.
18. F. Trick question! The code does not compile; therefore, option F is correct. The  
toRealPath() interacts with the file system, and therefore throws a checked  
IOException. Since this checked exception is not handled inside the lambda expression, 
the class does not compile. If the lambda expression was fixed to handle the IOException, 
then the expected number of Path values printed would be six, and option C would be the 
correct answer. A maxDepth value of 1 causes the walk() method to visit two total levels, 
the original /flower, and the files it contains.
19. D. The statements in options A, B, and C are each correct, making option D correct. If 
System.console() is available, then the program will ask the user a question and then 
print the response to the error stream. On the other hand, if System.console() is not 
available, then the program will exit with a NullPointerException. It is strongly recom-
mended to always check whether System.console() is null after requesting it. Finally, 
the user may choose not to respond to the program’s request for input, resulting in the 
program hanging indefinitely.
20. E. The code compiles, so option C is incorrect. Not all InputStream classes support the 
mark() operation. If mark() is supported, then 7 is printed at runtime. Alternatively, if 
mark() is not supported, then an IOException will be printed at runtime. For this reason, 
option E is correct. Always remember to call markSupported() before using a mark() 
operation on an InputStream.
21. A. The Files.find() method requires a maxDepth value as the second parameter.  
Since this parameter is missing, the method does not compile, and option A is correct. If a 
maxDepth parameter was added, then the method would compile but not print anything at 
runtime since the stream does not include a terminal operation.
22. F. Serializable is a marker interface, which means it does not contain any abstract 
methods that require implementation, making option F correct. The interface is only meant 
to indicate the object is capable of serialization.
23. B. First, the class compiles without issue. It is not without problems, though. The  
Files.isSameFile() method call on line j1 first checks if the Path values are 
equivalent in terms of equals(). One is absolute, and the other is relative, so this test will 
fail. The isSameFile() method then moves on to verify that the two Path values reference 
the same file system object. Since we know the directory does not exist, the call to  
isSameFile() on line j1 will produce a NoSuchFileException at runtime, making 
option B the correct answer. 
24. D. Both stream statements compile without issue, making options A, B, and C incorrect. 
The two statements are equivalent to one another and print the same values at runtime. For 
this reason, option D is correct. There are some subtle differences between the two methods 
calls. The walk() call does not include a depth limit, but since Integer.MAX_VALUE is 
the default value, the two calls are equivalent. Furthermore, the walk() statement prints 
a stream of absolute paths stored as String values, while the find() statement prints a 
stream of Path values. If the input p was a relative path, then these two calls would have 
very different results, but since we are told p is an absolute path, the application of  
toAbsolutePath() does not change the results.
25. A,E. An attribute view has the advantage of reading all of the file information on a single 
trip, rather than multiple trips to the file system making option A correct. Option B is incor-
rect because nothing guarantees it will perform faster, especially if the Files method is only 
being used to read a single attribute. Option C is also incorrect because both sets of methods 
have built-in support for symbolic links. Options D and F are incorrect because memory and 
resource leaks are not related to reading file attribute views. Finally, option E is correct, as 
NIO.2 supports file-system dependent attribute view classes.
26. A,C,F. Since you need to read primitives and String values, the InputStream classes are 
appropriate. Therefore, you can eliminate options B and D since they use Reader classes. 
Option E is incorrect, as this is not a java.io class. The data should be read from the file 
using an FileInputStream class, buffered with a BufferedInputStream class for 
performance, and deserialized into Java-accessible data types with an ObjectInputStream 
class, making options A, C, and F correct.
27. B. The method compiles, so option A is incorrect. The method reads all of the elements of 
a directory tree, keeping only directories. The forEach() method does not print anything, 
though, making option B correct. If the lambda in the forEach() method was modified to 
print something, such as s -> System.out.println(Files.isDirectory(s)), then 
it would print true at least once for the coffee directory. It would then print true for each 
directory within the directory tree.
28. D,F. The code compiles and runs without issue, so options A and B are incorrect. The 
problem with the implementation is that checking if ios.readObject() is null is not the 
recommended way of iterating over an entire file. For example, the file could have been writ-
ten with writeObject(null) in between two non-null records. In this case, the reading 
of the file would stop on this null value, before the end of the file has been reached. For this 
reason, option D is the correct answer. Note that the valid way to iterate over all elements  
of a file using ObjectInputStream is to continue to call readObject() until an  
EOFException is thrown. Finally, score is marked transient, which means the default 
int value of 0 will be set when the class is deserialized, making option F correct.
29. A,C. The Console class contains readLine() and readPassword() methods, but not 
a read() method, making option A one of the correct answers, and options D and E incor-
rect. It also contains a reader() method that returns a Reader object. The Reader class 
defines a read() method, but not a readLine() method. For this reason, option C is the 
other correct answer, and option B is incorrect. Recall that a BufferedReader is required 
to call the readLine() method.
30. F. The relativize() method requires that both path values be absolute or relative. Based 
on the details provided, p1 is a relative path, while p2 is an absolute path. For this reason, 
the code snippet produces an exception at runtime, making option F the correct answer. If the 
first path was modified to be absolute by dropping the leading dot (.) in the path expression, 
then the output would match the values in option A .
31. E. The code compiles without issue. Even though tricks would be dropped in the  
normalized path /bag/of/disappear.txt, there is no normalize() call, so  
path.subpath(2,3) returns tricks on line 5 .  On line 6, the call to getName() throws 
an IllegalArgumentException at runtime. Since getName() is zero-indexed and con-
tains only one element, the call on line 6 throws an IllegalArgumentException, mak-
ing option E the correct answer. If getName(0) had been used instead of getName(1), 
then the program would run without issue and print /home/tricks.
32. A,F. The lines() method returns Stream<String>, while the readAllLines() 
method returns List<String>, making option A correct and option D incorrect. Neither 
method is guaranteed to be faster or slower than the other, making options B and E  
incorrect. The lines() method lazily reads the file as the stream is processed, while the 
readAllLines() method reads the entire file into memory at once. For this reason, the 
readAllLines() method may require more memory to hold a large file, making option F 
correct and option C incorrect.
33. A. First, the code compiles. The format of the String on line v1 is valid, making option D 
incorrect. While System.console() throws a NullPointerException if it is not avail-
able, System.in does not, making option E incorrect.
The first part of the code runs without issue, printing a message such as  
bone fetched in  1 .8 seconds. The I/O stream System.in is closed at the end of the 
try-with-resources block. That means calling readLine() again results in an operation on a 
closed stream, which would print an exception at runtime and make option C correct, except 
System.err is already closed due to the try-with-resources block! Therefore, only one mes-
sage is printed, and option A is correct.
34. D. The Files.delete() and Files.list() declare a checked IOException that must 
be handled or declared. For this reason, the code does not compile, and option D is correct.
35. B,F. All of the options compile except option E, since FileInputStream does not have 
a readLine() method. A BufferedReader should be used instead. Options A and C 
suffer from the same problem. If the file is not exactly a multiple of 123 bytes, then extra 
information will be written to the file from the end of the data array. Option D is incor-
rect because the second argument should be an offset, and the third argument should be the 
number of bytes to read from the data array.
Option B is correct and uses an array to read a fixed number of bytes and then writes that 
exact number of bytes to the output file. Option F is also correct, although it does not use an 
array. Instead, a single byte is read and written on each iteration of the loop.
36. F. The Bowl class does not implement the Serializable interface; therefore, attempting 
to write the instance to disk, or calling readObject() using ObjectInputStream, will 
result in a NotSerializableException at runtime. Remember, all instance members of 
a class must be serializable or marked transient for the class to properly implement the 
Serializable interface and be used with Java serialization. For this reason, option F is the 
correct answer. If the Bowl class did implement Serializable, then the value of name and 
sugar would be CornLoops and 0, respectively, since none of the constructors, initializers, 
or setters methods are used on deserialization, making option B the correct answer.
37. B. The program compiles and runs without issue, making options C and D incorrect. The 
first variable, halleysComet, is created with subpath(1,5) and normalize() being 
applied right away, leading to halleysComet being assigned a value of   m1 .meteor. The 
second variable, lexellsComet is assigned a value on line 14, but lines 15–16 do not 
include an assignment operation. Since Path instances are immutable, the changes are lost. 
For this reason, the two objects are not equivalent on lines 18–19, and option B is correct. If 
lexellsComet was assigned the value created on line 15–16, though, then the path value 
of lexellsComet would be   m1 .meteor and option A would be correct.
38. F. When data is deserialized, none of variable initializers, instance initializers, or constructors 
is called. The class can have static initializers, but they are not called as part of deserializa-
tion. Finally, there is no restoreObject() method that is used in standard deserialization. 
For these reasons, option F is correct.
39. A,B,E. The code moves a file from /nursery/sapling.seed to the new location of  
/forest, not /forest/sapling.seed. For this reason, options C and D are both incor-
rect. If there is no file or directory at /forest, then the program completes successfully.  
If a file already exists at that location, then an exception is thrown since the  
REPLACE_EXISTING flag is not set. For these reasons, options A and B are both correct. 
Since the ATOMIC_MOVE flag is set, option E is correct, and option F is incorrect.
40. C. The program compiles and runs without issue, making options A, D, and E incorrect.  
The program uses Files.list() to iterate over all files within a single directory.  
For each file, it then iterates over the lines of the file and sums them. For this reason, option 
C is the correct answer. If the count() method had used Files.walk() instead of  
Files.lines(), then the class would still compile and run, and option B would be the 
correct answer. Note that we had to wrap Files.lines() in a try/catch block, because 
using this method directly within a lambda expression without one leads to a compila-
tion error.
1. B. This class does not implement Serializable, so option A is incorrect. This code is well 
encapsulated because the instance variables are private. While the instance variable refer-
ences do not change after the object is created, the contents fauna can be modified, so it is 
not immutable. For these reasons, option B is correct.
2. C,E. Options B, D, and F are not supported options in Java. The serialVersionUID class 
variable can be used in serialization, but it relates to the version of the class stored, not the 
choice in fields serialized, making option A incorrect. That leaves options C and E as the 
correct answers. The serialPersistentFields class variable defines a whitelist of fields 
to serialize, while the transient modifier constructs a blacklist of fields to skip.
3. B. The method compiles, so option E is incorrect. It is recommended to use a  
PreparedStatement with bind variables, over a Statement, to avoid SQL injection. 
Since the data type of the variable is String, it needs to be escaped making this method at 
risk for SQL injection.
Further, there is no risk of a resource leak that could be exploited in a denial of service 
attack. The Connection object is declared immediately before the try-with-resources block 
and closed by it, so it cannot be left open. For these reasons, option B is correct.
4. B. Option B is correct because mutability means the state can change, and immutability 
means it cannot. The other options are invalid. In option C, rigidity is not a common 
programming term.
5. C,D,E. A denial of service attack is about overloading the system with too much data or too 
many requests to process legitimate incoming requests. Option A is incorrect, and option C 
is correct because a try-with-resources or finally block should be used to close resources 
to prevent a resource leak. Option B is incorrect because SQL injection is a form of injection 
attack, not one based on volume or resources. Option D is correct because a malicious attack could
send a lot of bad requests with huge files. Option E is also correct as numeric overflow can be 
used to overwhelm a system. Option F is incorrect because immutability does not usually play a part 
in DoS attacks.
6. A,D. The policy compiles and uses correct syntax, making option A correct. However, it gives 
permissions that are too broad. The user needs to be able to read a recipe, so write permis-
sions should not be granted, making option D also correct.
7. C,F. Inclusion attacks occur when multiple files or components are embedded within a single 
entity, such as a zip bomb or the billion laughs attack. Both can be thwarted with depth limits, 
making option C and F correct. The rest of the options are not related to inclusion attacks.
8. B,D,E. Immutable objects are ones that are not modified after they are created. Immutable 
objects can have public constructors. There is no need to change the access modifier to
private, making option A incorrect. All instance variables should be private in an immu-
table class to prevent subclasses and classes within the package from modifying them outside 
the class, making option B correct and option C incorrect. They should not have any setter 
methods, making option D correct. The class should also either be marked final or con-
tain final methods to prevent subclasses from altering the behavior of the class, making 
option E correct. Finally, option F is incorrect as String is immutable, so a defensive copy is 
not required. Note that if species were a mutable type, like List, a defensive copy would 
be required.
9. A,C,F. The best way to protect a sensitive class is to prevent the class from being extended or 
prevent any of its methods from being overridden. Options A and C accomplish this. Option 
F also is appropriate. By marking all constructors private, only static methods that the 
class controls can be used to obtain instances of the object. Options B and D are incorrect 
because they do not prevent methods from being overridden that could change the behavior 
of the class. Option E is incorrect because constructors cannot be marked final.
10. C. The class compiles, so option E is incorrect. It is recommended to use a  
PreparedStatement over a Statement to avoid SQL injection although it is not strictly 
necessary. In this case, because the data type of the variable is int, Java already prevents a 
malicious String from being entered into the query. Therefore, this method is not at risk for 
SQL injection, making option B incorrect.
On the other hand, the code is a risk of a resource leak that could be exploited in a denial 
of service attack. While the Connection object doesn’t need to be declared in the try-with-
resources block, it should be declared right before it. In this case, there’s a line in between, 
con.createStatement(), that could throw an exception, thereby preventing the  
Connection from ever being closed. For these reasons, option C is correct.
11. B,F. Line p1 only partially validates the input from the user, since it performs a case insensi-
tive match. Therefore, the code executed on line p2 could be any variant of the magic word 
such as Abracadabra, aBraCadAbra, abracaDABRA, etc. In this manner, the user has 
access to many system properties to read from on line p2, making option B correct. The code 
also does not protect its input because trick is returned to the user, who is free to modify 
the List. Instead, an immutable collection should be returned on line p3, making option 
G correct.
12. E. By definition, you cannot change the value of an instance variable in an immutable class. 
There are no setter methods, making option A incorrect. While option B would allow you 
to set the value, the class would no longer be immutable. Option C is incorrect because that 
would not modify the original instance. Option E is correct. If you are an advanced devel-
oper, you might know that you can use reflection to change the value. Don’t read into ques-
tions like this on the exam. Reflection isn’t on the exam, so you can pretend it doesn’t exist.
13. F. The class is not marked Serializable, meaning none of the changes will work and 
making option F correct. If it was corrected to implement Serializable, then it  
would serialize all of the fields, not just flour as written. This is because  
serial PersistentFields is declared without the static modifier. Alternatively, all of 
the other fields besides flour could be marked transient to achieve the desired result.
14. B,D. Ensuring resources are released helps prevent a denial of service attack. Stream 
methods, such as Files.lines(), do not automatically close the file. Option B is correct 
since the programmer needs to do it. Without this, the system could run out of file resource 
handles as part of a denial of service attack.
When a resource is locked using an instance of the concurrent Lock interface, it should be 
unlocked in a finally block to ensure this step is not missed. Therefore, option D is the 
other correct answer. Without this, it’s possible an acquired lock is kept indefinitely, and a 
deadlock ensues as part of a denial of service attack.
15. C. A distributed denial of service attack is a denial of service attack that comes from multiple 
sources, making option C correct. There is no such thing as a million frowns attack. The rest 
of the answers are real attacks but can be executed from a single source.
16. B. The method only grants someone access if they appear in either the approved or 
rejected list. The combined data set forms a conceptual whitelist, making option B correct. 
The variable names chosen were meant to be tricky. If the code was checked to block people 
from the rejected list as well, then it would be both a whitelist and blacklist implementation.
17. B,F. The clone() method is inherited from the Object class. For this reason, it can be 
called on any Object without resulting in a compiler error, making options A and C incor-
rect. Option B is correct and defines the default behavior of clone() if the class does not 
implement Cloneable. On the other hand, if a class implements Cloneable but does not 
override clone(), then Java will perform a shallow copy by default, making option D incor-
rect. Finally, if the class implements Cloneable and overrides clone(), then the behavior 
of the clone() method is entirely dependent on the implementation. For this reason, option 
F is correct, and option E is incorrect.
18. A,D,F. Sensitive information should not be written to System.out, System.err, or a 
stack trace. For this reason, option A is correct, and option C is incorrect. It is preferable 
to use char[] instead of String for sensitive data so that it does not enter the String 
pool and become available as part of a memory dump. For this reason, option D is correct, 
and option B is incorrect. Note that Console does have a readPassword() method that 
returns char[]. Finally, the correct Java policy permission to prevent write access is to only 
grant read access, making option F correct and option E incorrect.
19. E,F. Encrypting or customizing the handling of certain sensitive fields are good reasons to 
customize the serialization process via methods, making options E and F correct. Options 
A, B, and D are invalid and are not reasons to customize the process. Option C is incorrect 
as the transient modifier or serialPersistentFields can be used to exclude fields 
from serialization without the need to add any serialization methods.
20. D. A good solution when input validation fails is to stop processing a request and throw 
an Exception to the calling method to deal with the problem, making option D correct. 
Options A and B are incorrect because throwing Error should be avoided for situations 
where the application can recover. Also, assertions are often disabled at runtime. Option C is 
incorrect as the user should not be allowed to continue if they have provided invalid input. 
Finally, option E is incorrect for obvious reasons.
21. C,E. When invoking doPrivileged(), make sure there is no chance for a user to pass 
their own, unprotected values into the request. Since a constant SCORES is used to read the 
system property on line m2, rather than user provided input, the code is safe from tainted 
inputs from the user. The code validates its inputs enough that an injection attack is not pos-
sible, making option E correct.
22. E. The GetField class is used with the readObject() method, making option E correct. 
There is also a PutField class used with the writeObject() method that you should be 
familiar with for the exam.
23. A. An immutable class must not allow the state to change. The Flower class does this 
correctly. While the class isn’t final, the getters are, so subclasses can’t change the value 
returned. The Plant class lacks this protection, which makes it mutable. Option A is correct.
24. B,F. Option A is incorrect because access control restricts who can do something rather 
than preventing an injection attack. Option B is correct because unsanitized input from the 
command line can do something undesirable like delete a file. Option C is incorrect because 
the programmer typed those constants rather than a hostile party.
Option D is incorrect because changing the values of an object is not an injection  
attack. Option E is incorrect because serialization is writing data to disk rather than  
executing. Option F is correct because XML parsing can load hostile values into your 
program.
25. A,B. The code is well encapsulated because all instance variables are private, making 
option A correct. It is susceptible to a denial of service attack since there is no input vali-
dation. For example, if the maximum integer value of 2,147,483,647 is passed, then it will 
make a huge number of calls to the database, potentially tying up the system and blocking 
valid requests. For this reason, option B is correct. To fix this code, a limit on the inputted 
value should be used. Option E is incorrect because the class is thread-safe since the instance 
methods are all synchronized. The rest of the options do not apply to this class.
26. F. Confidential information includes things like credit card numbers and passwords. Options 
A, B, and C are incorrect because they expose confidential information to the environment in 
which the application is running. Option D is incorrect because it allows the data to enter the 
String pool, where it can get printed if a memory dump occurs. Option E is incorrect, as 
passwords should not be sent over email. For these reasons, option F is correct.
27. B,C,F. While it is permitted to declare a resource outside a try-with-resources statement and
still have it be protected, declaring two is not recommended. In particular, if  
con.create Statement() fails, then the Connection is not closed. For this reason, the 
code is susceptible to denial of service attacks, making option B correct.
While it does not use a PreparedStatement, the code is safe from SQL injection because 
the query does not take any parameters, making option C correct. Finally, if the method com-
pletes without throwing an exception, then that means the try-with-resources block was suc-
cessfully entered. In this case, all resources would have been closed properly making option F 
correct.
28. D. This class does not implement Serializable, so option A is incorrect. This code is well
encapsulated because the instance variables are private. The algae and wave variables 
are immutable because they are marked final, and there are no methods that can change 
them. The getAlgae() method creates a defensive copy, preventing direct access to the 
algae object. Finally, the sun variable is initialized to 0 and is not able to be changed after 
its creation. The setSun() method is missing a this reference, so the assignment sun = 
sun assigns the method parameter sun to itself. For these reasons, the class is immutable, 
and option D is correct.
29. A,D,F. This class implements Serializable and contains serializable instance variables 
making option A correct. This code is not well encapsulated because the instance variables 
are public, which matches option D .  While a defensive copy of fauna is made in the getter, 
the instance variable is public, and elements can be added or removed directly. Therefore, 
the object is not immutable, and option F is correct.
30. A,E,F. A malicious attacker could extend this class and override the security check() 
method, so marking it final is a good idea, making option A correct. Next, the Console 
class offers a readPassword() method that does not echo what the user types and uses 
char[] instead of String to avoid a password entering the String pool. For these rea-
sons, option E is correct. Finally, line 10 prints the user’s password to the System.out 
log file, which is a terrible security idea. It should be changed or removed, making option F 
correct. The rest of the options are incorrect and do not improve the security of this class.
31. B,D. The read methods are used as part of deserialization, not serialization, making options 
A and E incorrect. Option B and D are correct because they use the correct method parame-
ters and return types for writeReplace() and writeObject().
32. B. An inclusion attack is one in which multiple components are embedded within a single 
file, such as zip bomb or XML exploit (billion laughs attack). Since the maximum file size is 
given to be small, this would be the most likely type of attack used, making option B correct. 
Note that if the file size was not limited, then this could be a regular denial of service attack 
in which a large file is sent repeatedly to overwhelm the system.
33. B,C,F. Caching permissions for a user is allowed, so option F is correct. That said, the  
security on using the cached data must be checked. The class is missing calls to  
AccessController.checkPermission() before lines h1 and h2 .  On line h1, this can 
result in a user reading a cached permission they do not have access to, making option B 
correct. On line h2, security permissions could be elevated since access is not checked,  
making option C correct.
34. F. The query uses a PreparedStatement so that the name is properly escaped. For this 
reason, SQL injection is not possible, and option F is correct. For the exam, you don’t need to 
know how to write a query to cause SQL injection, just how to prevent it.
35. B,D,E. An immutable class can have public constructors, so option A is incorrect. Options 
B, D, and E make up the requirements for an immutable class. Option D can be fulfilled by 
making the class final or marking the methods final. Option C is incorrect because in-
stance variables can still be declared with a value or set by an instance initializer. Option F is
also incorrect. While it is common to mark instance variables final, as long as there is no 
way for them to be changed after the constructor is executed, the class can still be considered 
immutable.
36. A,C. A denial of service attack is one in which one or more requests attempt to overwhelm 
the system and disrupt legitimate requests. Option A is an access or confidentiality problem. 
Option C is about gaining access or changing data that the user should not be permitted 
to. Options B, D, E, and F are all denial of service attacks because they increase load in an 
attempt to bring a system down. Remember, a zip bomb is when a small file is expanded to 
become a much larger file.
37. B,D,E. The Fruit class must implement Cloneable; otherwise, an exception would 
be thrown at runtime, making option E correct. The Fruit class must also override the 
clone() method. If it did not, then a shallow copy would be performed on the sweet 
object, resulting in the code printing true at runtime. Since this is not the case, option D is 
correct. Finally, we’ve already ruled out a shallow copy, so by process of elimination it must 
perform a deep copy. For this reason, option B is correct.
38. C,E. The primary way SQL injection occurs is from concatenating SQL queries without 
properly escaping the values. Avoiding concatenation and using a PreparedStatement 
with bind variables are the commonly accepted ways to prevent this. For these reasons, 
options C and E are correct.
Option A is incorrect because a database that takes no query parameters of any kind would 
be pretty limited in its capabilities. For example, it would be challenging to log a user in if 
you couldn’t search for that user. Option B is also incorrect, as you can’t prevent a SQL injec-
tion after it is already successful. Option D is incorrect, as a resource leak is more susceptible 
to a denial of service attack in which resources are exploited, rather than SQL injection in 
which data is manipulated. Finally, option F is incorrect, as avoiding using a relational data-
base is not a commonly accepted practice for avoiding SQL injection.
39. C. Option C is the correct answer. A hacker could override the setSecret() method 
to first steal the inputted secret value and email it herself and then pass the data along 
to the parent by calling super.setSecret() without anyone noticing any difference. 
One fix would be to mark this method final in the Secret class or make the Secret 
class final.
Option B is incorrect because variables can only be hidden, not overridden, so declaring a 
new mySecret variable would not grant access to the parent variable. Option D is incorrect 
as overriding this method won’t allow the attacker to access the mySecret variable directly. 
Option E is trivially incorrect, as private methods cannot be overridden. Finally, option 
F is incorrect as adding a constructor does not grant access to private members in the 
parent class.
40. B. An immutable class must not allow the state to change. In the Faucet class, the caller has 
a reference to the List being passed in and can change the size or elements in it. Similarly, 
any class with a reference to the object can get the List by calling get() and make these 
changes. The Faucet class is not immutable. The Spout class shows how to fix these prob-
lems and is immutable, making option B correct.
1. E. Connection is a JDK interface for communicating with the database.  
PreparedStatement and ResultSet are typically used to write queries and are also in 
the JDK. Driver is tricky because you don’t write code that references it directly. However, 
you are still required to know it is a JDBC interface. DriverManager is used in JDBC code 
to get a Connection. However, it is a concrete class rather than an interface. Since only four 
out of the five are JDBC interfaces, option E is correct.
2. F. Database-specific implementation classes are not in the java.sql package. The imple-
mentation classes are in database drivers and have package names that are specific to the 
database. Therefore, option F is correct. The Driver interface is in the java.sql package. 
Note that these classes may or may not exist. You are not required to know the names of any 
database-specific classes, so the creators of the exam are free to make up names.
3. D. All JDBC URLs begin with the protocol jdbc followed by a colon as a delimiter. Option 
D is the only one that does both of these, making it the correct answer.
4. A. The Driver interface is responsible for getting a connection to the database, making 
option A the answer. The Connection interface is responsible for communication with the 
database but not making the initial connection. The Statement interface knows how to run 
the SQL query, and the ResultSet interface knows what was returned by a SELECT query.
5. C. Connection is an interface. Since interfaces do not have constructors, option D is incor-
rect. The Connection class doesn’t have a static method to get a Connection either, 
making option A incorrect. The Driver class is also an interface without static methods, 
making option B incorrect. Option C is the answer because DriverManager is the class 
used in JDBC to get a Connection.
6. F. The DriverManager.getConnection() method can be called with just a URL. It 
is also overloaded to take the URL, username, and password. Since this is not one of the 
options, the answer is option F .
7. D. This code is missing a call to rs.next(). As a result, rs.getInt(1) throws a  
SQLException with the message Invalid cursor state – no current row. 
Therefore, option D is the answer.
8. E. The execute() method is allowed to run any type of SQL statements. The  
executeUpdate() method is allowed to run any type of the SQL statement that returns 
a row count rather than a ResultSet. Both DELETE and UPDATE SQL statements are 
allowed to be run with either execute() or executeUpdate(). They are not allowed to 
be run with executeQuery() because they do not return a ResultSet. Therefore,  
option E is the answer.
9. A. This code uses a PreparedStatement without bind variables (?). While it would be 
better to use bind variables, this code does run. The ResultSet has one value and does 
print Mei Xiang successfully. Therefore, option A is the answer.
10. F. While the table has two columns, the SQL query has only one bind variable (?). Therefore, 
the code throws an exception when attempting to set the second bind variable, and option F 
is correct.
11. B. This code is correct. It executes the first update to add the first row and then sets the 
parameters for the second. When it updates the second time, it adds the second row. There-
fore, option B is the answer.
12. E. CallableStatement and PreparedStatement are interfaces that extend the 
Statement interface. You don’t need to know that for the exam. You do need to know that 
a database driver is required to provide the concrete implementation class of Statement 
rather than the JDK. This makes option E correct.
13. B. Unlike arrays, JDBC uses one-based indexes. Since num_pages is in the second column, 
the parameter needs to be 2, ruling out options A and C .  Further, there is not a method 
named getInteger() on the ResultSet interface, ruling out option D .  Since the proper 
method is getInt(), option B is the answer.
14. B,D. Since JDBC does not begin indexes with zero, option A is incorrect, and option B is 
correct. Similarly, the second parameter is at index 2, so option C is incorrect, and option D 
is the other answer. Note that setObject() can be called instead of a more specific type.
15. D. Option A does not compile because you have to pass a column index or column name to 
the method. Options B and C compile. However, there are not columns named 0 or 1 .  Since 
these column names don’t exist, the code would throw a SQLException at runtime. Option 
D is correct as it uses the proper column name.
16. D. A JDBC URL has three components separated by colons. All three of these URLs meet 
those criteria. For the data after the component, the database driver specifies the format. 
Depending on the driver, this might include an IP address and port. Regardless, it needs to 
include the database name or alias. The first and second URLs could both be valid for-
mats because they mention the database box. However, third is incorrect because it has 
jdbc@ instead of jdbc:. Therefore, option D correct.
17. C,D. JDBC uses Java and SQL, so it is not language independent, making option A incorrect. 
It is used with relational databases, ruling out option B .  A CallableStatement supports 
stored procedures, not a PreparedStatement, making option E incorrect.
Options C and D are correct. Using bind variables with a PreparedStatement produces 
code that is easier to read than one with a lot of String concatenation. Further, when used 
properly, a PreparedStatement prevents SQL injection.
18. B. Connection is an interface rather than a concrete class. Therefore, it does not have 
a constructor and line s1 does not compile. As a result, option B is the answer. Option A 
would be the answer if the code new Connection() was changed to DriverManager 
.getConnection().
19. E. When manually closing database resources, they should be closed in the reverse order 
from which they were opened. This means the ResultSet object is closed before the 
Statement object and the Statement object is closed before the Connection object. 
This makes option E the answer.
20. A. This code correctly obtains a Connection and PreparedStatement. It then runs a 
query, getting back a ResultSet without any rows. The rs.next() call returns false, so 
nothing is printed, making option A correct.
21. F. The SQL query has two bind variables, but the code sets only one. This causes a  
SQLException when executeQuery() is called, making option F the answer.
22. A. This code uses a PreparedStatement and properly sets a bind variable (?). The 
ResultSet has one value and does print Mei Xiang successfully. Therefore, option A is 
the answer.
23. C. Option A is incorrect because Driver is an interface, while DriverManager is a 
concrete class. The inverse isn’t true either; DriverManager doesn’t implement Driver. 
Option B is incorrect because the Connection implementation comes from a specific data-
base driver JAR. Option C is correct as bind variables (?) are used.
24. A. The count(*) function in SQL always returns a number. In this case, it is the number 
zero. This means line r1 executes successfully because it positions the cursor at that row. 
Line r2 also executes successfully and prints 0, which is the value in the row. Since the code 
runs successfully, option A is the answer.
25. B. This code is correct. It executes the first update to add the first row and then sets the 
parameters for the second. For the second update, only one parameter is set. The other is 
reused since it was set earlier. Therefore, option B is the answer.
26. A,D. The PreparedStatement interface extends the Statement interface, which  
matches option D .  One of the benefits of a PreparedStatement is performance. While a 
PreparedStatement may not be faster if run only once, it will quickly become so. There-
fore, option A is the other correct answer.
27. E. In JDBC, the bind variable is always a question mark (?), making option A incorrect. A 
PreparedStatatement is not limited to specific types of SQL, making options B and C 
incorrect as well. This makes option E the correct answer.
28. F. While this code compiles, it isn’t right. Since we have a SELECT statement, we should be 
calling execute() or executeQuery(). Option F is the answer because the code throws 
an exception when attempting to call executeUpdate().
29. D. When running a query on a PreparedStatement, Java closes any already open 
ResultSet objects associated with the statement. This means that rs1 is closed on line 8 .
Therefore, it throws a SQLException on line 9 because we are trying to call next() on a 
closed ResultSet, and option D is correct.
30. C. This question is trickier if you know more JDBC than is on the exam. If you know only 
what is on the exam, you would assume the createStatement() method doesn’t exist. 
However, it does, and stmt is a Statement object. Since setString() does not exist on 
Statement, the code does not compile. This means the answer is option C regardless of 
your level of knowledge of JDBC .
1. A,E,F. Oracle defines a locale as a geographical, political, or cultural region, making options 
A, E, and F correct. A local address and city are too granular for a locale. Also, time zones 
often span multiple locales.
2. E. Java starts out by looking for a properties file with the requested locale, which in this case 
is the fr language. It doesn’t find it, so it moves onto the default locale en_US, which it does 
find, making option E correct.
3. C. Currencies vary in presentation by locale. For example, 9,000 and 9.000 both represent 
nine thousand, depending on the locale. Similarly, for dates, 01-02-2022 and 02-01-2022 
represent January 2, 2022, or February 1, 2020, depending on the locale. This makes option 
C the answer.
4. E. The Locale object provides getDefault() and setDefault() methods for working 
with the default locale, so option E is correct. The rest of the methods do not exist in the 
Locale class.
5. B. Calling Locale.setDefault() changes the default locale within the program. It does 
not change any settings on the computer. The next time you run a Java program, it will have 
the original default locale rather than the one you changed it to.
6. C. The code compiles and runs without issue. The data is in a valid date format, so the text 
is parsed as January 21, 2022 .  Date values are indexed from 1, not 0, making option C the 
correct output. Note that a date formatter is able to format a date/time value, as the time 
element can be discarded.
7. E. The first line of the method is correct, as Properties inherits Map and has a get() 
method. The get() method does not have an overloaded version that takes a default value, 
though. For this reason, the second and third get() calls do not compile, and option E is 
correct. If getProperty() were instead used on the second and third call, then the output 
would be bag null trick.
8. F. Options A and B are incorrect because formatDate() is not a valid method name in 
DateTimeFormatter. Option E is incorrect because the code compiles if either option 
C or D is used. Both options C and D will produce an exception at runtime, though, as the 
date pattern is invalid. In particular, the apostrophe in o'clock should be escaped. Option 
C is also incorrect because there is no hour value h for a LocalDate. If the pattern string 
was corrected with o''clock, then option D would be correct and print March at 5 
o'clock at runtime.
9. A,B. In Java, a locale can be represented by a language code in lowercase, or a language 
and country code, with language in lowercase and country in uppercase. For these reasons, 
options A and B are correct. Options C, D, and E are incorrect because the lowercase lan-
guage must be before the uppercase country. Option F is incorrect because the language is 
missing. Remember, the exam won’t expect you to know which language and country codes 
exist, but it will expect you to know how to use them.
10. F. Java starts out by looking for a properties file with the requested locale, which in this  
case is the fr_CH language and country. It doesn’t find Colors_fr_CH.properties,  
so it moves onto the locale with just a language code fr. It also does not find  
Colors_fr.properties. It then moves on to the default locale it_CH checking  
Colors_it_CH.properties, but there is still no match. It drops the country code and 
checks it for Colors_it.properties, but still doesn’t find a match. Lastly, it checks for 
a Colors.properties file but since that’s not an option, it fails. The result is a  
MissingResourceException is thrown at runtime, making option F correct.
11. C. The code compiles, so option D is incorrect. In this sample, the default locale is set to US, 
while the default locale format is set to GERMANY. Neither is used for formatting the value, as 
getCurrencyInstance() is called with UK as the locale. For this reason, the £ symbol is 
used, making option C correct.
12. D. The getBundle() does not find Cars_de_DE.properties or  
Cars_de.properties, so it moves on to the default locale. Since Cars_en.properties 
is available, it will use this file, falling back to Cars.properties if any values are not 
available. Therefore, it selects engine and horses from the first file, and country from 
the second file, printing engine 241 earth and making option D correct.
13. F. The getBundle() method matches Cars_fr_FR.properties. It will then fall back to 
Cars_fr.properties (which does not exist) and Cars.properties if the value is not 
available. For this reason, the first and third values would be France and moteur. While 
the second value horses is in the default locale, it is not available if the requested locale has 
been found. As a result, the code throws a MissingResourceException, making option 
F the answer.
14. A. The getBundle() method matches Cars_fr_FR.properties. It will then fall  
back to Cars_fr.properties (which does not exist) and Cars.properties if  
the value is not available. For this reason, the first value printed is moteur from  
Cars.properties, while the next two values printed are autoroute and France  
from Cars_fr_FR.properties, making option A correct.
15. F. There are no get() or of() methods in Locale. You need to use a constructor or a 
predefined Locale constant to obtain a Locale reference. Therefore, option F is the correct 
answer. Options B and C are close in that Locale.ITALIAN does reference a Locale 
object. However, it should not be passed to the nonexistent get() method.
16. A. Java starts out by looking for a properties file with the requested locale, which in this case 
is the zh_CN language and country. It doesn’t find it, so it moves onto the locale with just a 
language code zh, which it also does not find. It then moves on to the default locale en_US, 
but there is still no match. It drops the country code and does find a match with en, making 
option A correct.
17. D. This code compiles and runs without exception, making option D the correct answer. Line 
3 uses a predefined Locale constant. Line 5 passes a language and country code for English 
in Australia. Line 7 incorrectly passes capital letters as a language code. However, Java auto-
matically converts it to lowercase without throwing an exception. The three lines printed by 
the code are ko, en_AU, and en.
18. E. Java starts out by looking for a properties file with the requested locale, which in this case 
is the ca_ES language and country. It doesn’t find it, so it moves onto the locale with just a 
language code ca, which it does find, making option E correct.
19. F. The parse() method properly reads the date as April 1, 2022. The format() tries to 
use a date/time formatter on a date, which produces an exception at runtime since the time 
element is missing. For this reason, option F is correct.
20. A. The first line of the method retrieves the value for the property with key rocket, which 
is saturn5 .  The next line retrieves the value for earth, but since it’s not found, null is 
returned. The last functions similarly to the previous line but uses ? as the default value 
since earth is not set. The code then prints saturn5 null ?, making option A the 
correct answer.
21. B,D. Options B and D correctly print the same string value in the specified format. Option 
A is incorrect because  <06 .92>  is printed instead of  <06 .9>.  Options C and E are incor-
rect, because (among other things) commas are printed as part of both of the first two values. 
Option F is incorrect because  <2 .1>  <6 .9> is printed instead of  <02 .1>  <06 .9>.
22. B. The class on line p1 should be Properties rather than Property. As written, it is 
incorrect and does not compile, making option B the correct answer.
23. B. Java starts out by looking for a properties file with the requested locale, which in this case 
is the en language. It finds it right away, making option B correct.
24. C,D. In Java, a locale can be represented by a language code in lowercase, or a language 
and country code, with language in lowercase and country in uppercase. Option C is invalid 
because both values are lowercase. Option D is invalid because the value is in uppercase. The 
rest of the options are valid locale formats. Remember, the exam won’t expect you to know 
which language and country codes exist, but it will expect you to know how to use them.
25. B. The code compiles, so option D is incorrect. While three distinct locale values are set, the 
one that is used for formatting text is Category.FORMAT. For this reason, the GERMANY 
locale is used to formatting the data with the € symbol, making option B correct.
26. D. The date/time pattern uses single quotes to escape the date/time values, meaning the 
output is yyyy-MM for all valid inputs. For this reason, option D is correct. If the single 
quotes were removed, then 2022-03 2022-01 would be the correct output.
27. D. The method creates a resource bundle using a builder but never sets it. Since we don’t 
know the default locale of the code, the answer depends on where it is executed, making 
option D correct.
28. A. This code sets the default locale to English and then tries to get a resource bundle for 
container. It finds the resource bundle container_en.properties as the most 
specific match. Both keys are found in this file, so option A is the answer.
29. E. The Locale constructor that takes a single argument expects a language code, not a 
concatenation of language and region codes. Therefore, the language is set as en_us, not 
en, with no region code set. Since no properties files match the language en_us, the default
container.properties is used. Since type is not found in this properties file, a  
MissingResourceException is thrown at runtime.
30. A. The code compiles, so option E is incorrect. Java starts out by looking for a properties  
file with the requested locale, which in this case is the fr language. It doesn’t find  
Forest_fr.properties, so it moves onto the default locale en. It also doesn’t find 
Forest_en.properties. It settles on Forest.properties without throwing an 
exception, so option F is incorrect. The first argument to MessageFormat.format() 
should be a pattern String value. Since trees is sent, the output of the formatting string is 
trees, making option A correct. If rb.getString("trees") was passed instead of just 
trees, then the output would be evergreen pretty.
1. B. The default modifier along with a value is used to mark an annotation element as 
optional, as opposed to required.
2. B,C. Annotations are about storing metadata, or data about data. The maximum number 
of tickets per person and total number of people the theater can hold define rules that are 
unlikely to change frequently, so they are best stored with annotations. The number of people 
attending, price, and time the ticket is sold are likely to change frequently and should be part 
of the transactional information for the ticket. The seat assignment also changes for every 
ticket sold.
3. F. CelestialBody is not an annotation definition because it is not declared with the  
@interface type, making option F correct. If the correct declaration was used, then option 
A would be the correct answer. Options B and C are incorrect, because lightYears is 
a constant and cannot be set as part of the annotation. Options C and E are also incor-
rect because they are missing a name element. Option D is incorrect because there is no 
value() element.
4. C. Option C uses the correct values and allows all three annotations to compile. Option A is 
incorrect because the class declaration usage does not compile. Using option B or E does not 
allow any of the annotations to compile. Option D allows the class and constructor annota-
tions to compile, but not the method usage.
5. B,C,F. Options B, C, and F are each marker annotations because they do not contain any ele-
ments. Option A is incorrect because @Target requires an ElementType[] value. Option 
D is incorrect because @Retention requires a RetentionPolicy value. Option E is 
incorrect because @Repeatable requires a Class value.
6. B,D,F. Option B is correct and relies on the fact that the single element value() can be 
used without an element name. Option D is correct because the annotation has a default 
value; therefore, value is optional. Option F is correct and uses the correct name for value. 
Options A, C, and E are incorrect because they use the wrong name for the element.
7. D. Lines 3 and 6 do not compile because wrapper classes are not permitted as annotation 
element types. Line 5 does not compile because a constant must be declared with a value. For 
these reasons, option D is correct. The rest of the lines compile without issue.
8. C,E. Options A and D are incorrect. An interface can define a method and be extended, but 
an annotation cannot. Neither type can declare constructors, making option B incorrect. 
Annotations and interfaces can both declare constants and be applied to a class declaration, 
making options C and E correct. Interfaces use the interface type, while annotations use 
the @interface type, making option F incorrect.
9. F. The class compiles as is but generates warnings for unchecked/unsafe operations  
with the planets.add(5) operation, so options A and B are incorrect. Inserting  
@Suppress Warnings(), though, will cause a compiler error as it requires at least one 
value. For this reason, option F is correct. If @SuppressWarnings("unchecked") was 
used instead, then inserting it on lines m1 and m2 would allow the code to compile without 
any warnings.
10. F. An annotation can be applied to all of these Java declarations, making option F correct.
11. A,B,E. The @Override annotation is always optional for methods and never required. For 
this reason, options A and E are correct, and options C and F are incorrect. Option B is correct 
because adding it to a method that is not actually overriding an inherited method will cause a 
compiler error. Option D is incorrect because it can be applied only to method declarations.
12. B. The declaration compiles, so option F is incorrect. The Bread annotation is declared with 
one required element, while Toast is declared with no required elements. For these reasons, 
option B is correct, and option E is incorrect. Options A and C are incorrect because neither 
annotation contains a value() element. Option D is incorrect because wheat is a constant, 
not an element.
13. B,D,E. An annotation may omit the element name if it contains an element named value, 
declared as value(), making option B correct and option F incorrect. Additionally, it may 
contain any number of additional elements, provided none of them is required, making 
option E correct. Finally, the element may optionally have a default value, making option D 
correct. The other options are incorrect statements that contradict the correct answers.
14. F. Trick question! By default, annotations are not present at runtime. To print a non-null 
value, both @Retention(RetentionPolicy.RUNTIME) and @Inherited would 
be required, making option F correct. The @Retention annotation would preserve the 
annotation for runtime, while the @Inherited annotation would apply it to the sub-
class Cheetah.
15. B. Only line 3 contains a compiler error, as an element declared in an annotation must use 
parentheses after its name, making option B correct. If value() was used instead of value, 
then the code would compile.
16. B. A default annotation element value must be a non-null constant expression. Since  
lastName() provides a null value by default, the declaration of Friend contains a  
compiler error. The declaration of MyFriends does not contain any compiler errors, so 
option B is correct.
17. B,C,D. An annotation element type must be a primitive type, a String, a Class, an enum, 
another annotation, or an array of any of these types. For this reason, options B, C, and D 
are correct. Option A is incorrect because Object is not supported. While primitives are sup-
ported, wrappers are not, making option E incorrect. Option F is also incorrect as local vari-
able type inference with var is not permitted, even if a default value is provided.
18. D,E. Gift is a repeatable annotation. It requires specifying a container type annotation 
using the Class object, making option D correct. The containing type annotation referenced 
must declare a value() element that is an array of the repeatable annotation, making 
option E correct.
19. B,C,F. Option A is incorrect, as annotations generally contain information that is constant 
throughout the program execution. Option B is correct. For example, adding an @Override 
annotation to a method that is not a valid override will trigger a compiler error. Option C 
is also correct and is the primary purpose of annotations. Options D and E are incorrect, 
as annotations can be applied to a variety of types including lambda expression variables 
and other annotations. Finally, option F is correct. Annotations are optional metadata, and 
removing all of them from a class does not cause a compiler error.
20. A,B,E. Options A, B, and E are correct and rely on the fact that the element name is optional 
for an annotation with a single element named value(). Option E also relies on annota-
tions supporting a single element for an array. Note that the array provided is not required to 
have any elements. Option C is incorrect because Java does not automatically convert from a 
List to an array. Option D is incorrect because the annotation contains a required element. 
Finally, option F is incorrect because default is the wrong element name.
21. B,D. The @SafeVarargs annotation requires the method to which it is applied con-
tain a varargs parameter and be unable to be overridden, aka marked static, final, or 
private. Options B and D fulfill this requirement. Options A and E are missing a modifier 
that prevents them from being overridden. Options C and F are missing a vararg parameter. 
While a primitive array int[] can be passed to a method containing a varargs param-
eter, to apply the @SafeVarargs annotation, the method must be declared with a varargs 
annotation.
22. A. The correct annotation that preserves information about annotations in generated  
Javadoc files is @Documented. The rest are incorrect.
23. F. The @Retention annotation can be applied only to an annotation declaration, not a 
class declaration, making option F the correct answer. Applying it to a class will result in a 
compiler error. If Corn were an annotation, though, then RetentionPolicy.RUNTIME 
would be correct.
24. E. Lines 3 and 8 do not compile because annotation elements must be public, implicitly or 
explicitly. Line 8 also does not compile because continue is a keyword in Java. Line 5 does 
not compile. While arrays are permitted as element types, collections like List are not.
Line 6 does not compile because annotation elements cannot be marked final, as they are 
implicitly abstract. For these reasons, option E is correct. Line 4 compiles because an 
annotation can declare another annotation as the element type. Line 7 also compiles. While 
the public and abstract modifiers aren’t required for an annotation element, they can be 
specified.
25. A,B,F. An annotation element can include a default value if it is a non-null constant 
expression. Options A, B, and F fulfill this criteria. Option C is incorrect because it creates a 
new object. Option D is incorrect because it uses method calls. Option E is incorrect because 
null is not permitted.
26. B,C. @Weather is the repeatable annotation, so it can be used twice on the same type dec-
laration, making option C correct. A containing type annotation @Forecast takes an array 
of the repeatable annotation @Weather, making option B also correct. Options A and F are 
incorrect, as those represent an annotation that takes an array of String values. Option D 
and E are incorrect because the repeatable and containing type annotations are reversed.
27. A,D. To correctly apply the @FunctionalInterface annotation, the interface must pass 
the single abstract method test. Also, note that none of the default or static methods 
contributes to the abstract method count.
Dog contains a single abstract method play(), so it will compile, making option A correct. 
Webby extends Dog with the same abstract method as Dog. It also declares toString(), 
but since this is inherited from java.lang.Object, it does not count as an abstract 
method. Therefore, Webby passes the single abstract method test for functional interfaces, 
making option D correct. Astra is incorrect because it contains two abstract methods, 
play() and fetch(). KC is incorrect because it does not extend Dog and does not con-
tain any abstract methods. Finally, Georgette is incorrect because it contains two abstract 
methods, play() and jump().
28. B. The declaration of Colors and Bouncy compile without issue. The declaration of  
Trampoline does not compile, though. The Bouncy annotation has two required elements, 
value() and size(), so the name of the element value cannot be dropped. For this 
reason, option B is correct.
29. B,F. The @Inherited annotation determines whether annotations applied to a supertype 
are applied to its subtypes, while the @Documented annotation allows annotations to be 
included in generated Javadoc. For these reasons, options B and F are correct.
30. D. The SystemPlanner class compiles although it contains two warnings. First, the  
ProjectPlanner class is used, which is deprecated. Second, the create() method uses 
an unchecked/unsafe operation taking a String for the generic type. For this reason, both 
unchecked and deprecation options are required for the code to compile without any 
warnings. Option D uses the correct format for passing an array to an annotation. Note that 
ignoreAll is not a known parameter that the JVM accepts.